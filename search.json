[{"title":"LLM Deepseek相关","url":"/2025/01/27/AI/LLM%20Deepseek%E7%9B%B8%E5%85%B3/","content":"基本原理\r\n\r\ntoken 一个词语或者词组，--(embedding)\r\n---&gt;对应一个向量，表示含义\r\n每次根据前文预测下一个词语\r\nAttention层+多层感知层+Attention层+.....\r\nAttention层：pass information around the token into its vector\r\n\r\n查询矩阵 * 嵌入向量 -&gt; 查询向量 （like looking for adj of\r\nit，降维)\r\n键向量，回答查询 （降维）\r\n每个查询向量和键向量的相似度（ \\(n^2\\)，n为上下文长度 ) -&gt; the embeddings\r\nof x attend to the embedding of y\r\n值矩阵 * 嵌入向量：值向量 （shape与嵌入向量相同）\r\n值向量用相关性为权重进行加权相加\r\n（每个位置只被此位置前面的token影响：掩码）-&gt; \\(\\Delta E\\)\r\n值参数矩阵太大 -&gt; 变成两个参数矩阵相乘 （\\(V_{up} * V_{down} (* E)\\))\r\n单头和多头 不同的注意力模式（W，K，V参数矩阵不一样）-&gt; 所有 \\(\\Delta E\\) 相加\r\n\r\nV_up 合起来为输出矩阵\r\n\r\n自注意力和交叉注意力\r\n\r\n多层感知层：每个token单独处理，存储事实\r\n\r\n\\(W_{up} \\times E + B_{up}\\)\r\n（注意升维了）\r\n\r\nReLU函数激活（得到的值叫做神经元）\r\n\\(W_{down} \\times E + B_{down}\\)\r\n（注意降维了）\r\n事实存储在wup的行向量（像embedding一样代表一种特征）和对应的wdown的列向量的关系中\r\n\r\n\r\n\r\n\r\n ##\r\nDeepseek原理 - MLE多头潜在注意力 = 多头自注意力+低秩联合压缩 - MoE\r\n每个token激活8个专家，共享专家+路由专家 -\r\n辅助损失的主要作用 是在训练过程中鼓励 token\r\n更均匀地分配给不同的专家。无辅助损失的负载均衡策略：采用\r\n动态偏置项（Bias Term）\r\n来调整专家的选择概率。监控每个专家的负载来调整概率。 - MTP\r\n同时预测多个后续token - train： - PP：流水线 -&gt; DualPipe -\r\nEP：专家并行 - DP：数据并行 - 大多数核心计算内核，即 GEMM（General\r\nMatrix Multiply）操作，以 FP8 精度实现。保持以下组件的原始精度（例如\r\nBF16 或 FP32）：嵌入模块、输出头、MoE\r\n门控模块、归一化操作符和注意力操作符。 - Adam\r\n它是一种自动调整学习率的算法，优化器 - Wgrad\r\n操作（权重反向传播，Weight Gradient） - 通信带宽是 MoE\r\n模型训练的关键瓶颈。 ### 部署 -\r\n“部署”指的是将训练好的模型应用到实际场景中的过程，使其能够在特定环境中运行并提供服务\r\n-\r\nMoE的全对全通信：跨节点通信使用高速网络（如InfiniBand，IB）；节点内通信在节点内部，通过GPU之间的NVLink\r\n-\r\n预填充和解码：推理的两个阶段，预填充是用prompt生成第一个输出token，解码是一个一个输出token。预填充阶段计算密集，适合高性能计算资源；解码阶段计算稀疏，适合低延迟优化\r\n- KV\r\nCache：在自回归生成任务中，模型每次生成一个新token时，都需要计算当前token与之前所有token之间的注意力关系。KV\r\nCache 通过缓存之前计算过的K和V矩阵，避免重复计算，从而显著提高推理效率。\r\n## 通道\r\n在图像处理或卷积神经网络（CNN）中，“通道”通常指特征图的一个维度，直接对应某个卷积核的输出。但在Transformer中，“通道”并不是一个原生术语，而是可以借用过来描述多头注意力输出的结构：\r\n- 隐式通道：拼接后的输出向量（例如 512 512 512\r\n维）可以被看作包含 h h h 个“通道”，每个通道的长度是 dhead d_{head}\r\ndhead​（例如 64 64 64）。这里的“通道”实际上是每个注意力头的输出片段。 -\r\n特征表示：每个“通道”（即每个头的输出）捕获输入数据的不同方面，例如语法、语义、上下文关系等。\r\n因此，在这种意义上，可以说“一个通道对应一个注意力头的输出”。但需要注意：\r\n-\r\n这些“通道”在拼接后会被线性变换（通过一个全连接层），最终输出不再保留明确的“通道”边界，而是融合成了一个统一的\r\ndmodel d_{model} dmodel​ 维向量。 -\r\n“通道”在这里更多是一个概念上的类比，而不是像CNN中那样有明确的物理分离。\r\n低秩分解\r\n在多头注意力机制（MHA）中，键（K）和值（V）矩阵通常需要占用大量内存。通过低秩分解，可以将K和V矩阵压缩为一个低秩的潜在表示（如\r\n），从而减少存储需求。\r\n","tags":["AI"]},{"title":"GIT","url":"/2024/02/23/%E5%85%B6%E4%BB%96/GIT/","content":"git rm 会删除工作区文件！\r\n创建仓库\r\n$ mkdir learngit //在此处建立一个文件夹$ cd learngit //到文件夹里面$ pwd //看看我在哪个文件夹/Users/michael/learngit$ git init //把这个目录变成Git可以管理的仓库\r\n注意记事本\r\n千万不要使用Windows自带的记事本编辑任何文本文件。\r\ngit add a.txt\r\n把修改添加到暂存区\r\nGit管理的是修改，不是文件\r\ngit commit -m \"提交说明\"\r\n把暂存区的修改提交到仓库\r\nls\r\n查看此文件夹下的文件\r\ngit status\r\n查看的状态\r\n\r\n没有add的修改\r\n没有commit留在暂存区的修改\r\n\r\ngit diff a.txt\r\n查看改变后的和在仓库里的版本的差别\r\ngit diff：工作区和暂存区\r\ngit diff --staged： 暂存区和仓库\r\ngit diff   \r\ngit diff   和工作区\r\ngit log\r\n查看历史记录\r\n--pretty=oneline\r\n查看版本号\r\ngit log --oneline\r\n版本表示\r\n用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，往上100个版本HEAD~100。\r\nReset\r\n\r\n使用 --soft\r\n选项，你可以重置HEAD到指定的提交，但不会影响工作目录或暂存区。\r\n使用\r\n--hard，你可以重置HEAD到指定的提交，并且清除工作目录和暂存区的所有更改。\r\n\r\n撤回版本回退\r\n找到那个append GPL的commit id是1094adb...，于是就可以指定回到未来的某个版本：\r\n$ git reset --hard 1094aHEAD is now at 83b0afe append GPL\r\n版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。\r\ngit reflog\r\n记录你的每一次命令（commit，reset……）\r\n和那个命令的版本号\r\ngit checkout -- a.txt\r\n总之，就是让这个文件回到最近一次git commit或git add时的状态。\r\n删除之后也可以\r\n撤销修改\r\n1.没有git add时（在工作区），用git checkout -- file\r\n2.已经git add时（在暂存区），先git reset HEAD &lt;file&gt;回退到1.，再按1.操作\r\n3.已经git commit时，用git reset回退版本\r\n删除\r\ngit rm删掉，并且git commit\r\n没git rm之前可以checkout恢复\r\n$ git rm --cached README 在仓库里删除但是工作区保留\r\n分支\r\n\r\ngit switch -c dev\r\n创建dev分支，然后切换到dev分支\r\ngit switch dev 切换到dev分支\r\ngit branch dev 创建\r\ngit branch -d dev 删除dev分支\r\ngit merge dev 合并指定分支到当前分支。\r\ngit merge dev\r\n合并冲突时会把当前分支的工作区的此文件变成这个样子\r\nGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADCreating a new branch is quick &amp; simple.=======Creating a new branch is quick AND simple.&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1\r\n可以手动修改之后再提交\r\n注意merge的是修改，不是文件\r\n\r\n改变分支策略\r\ngit merge --no-ff -m &quot;commit describtion&quot; dev\r\nmerge的同时commit\r\n临时储藏分支\r\n把工作区存起来，不用commit，直接switch到另一个分支\r\n存入：$ git stash\r\n查看stash：git stash list\r\n恢复：一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；\r\n另一种方式是用git stash pop，恢复的同时把stash内容也删了：\r\n在另一个分支上重复一个提交（修改）\r\n$ git cherry-pick 4c805e2\r\n把另一分支上的4c805e2提交重复，注意是重复内容，但commit号是另一个\r\n别名 alias\r\ngit config --global alias.ch checkout\r\n以后就可以用ch代表checkout\r\n给提交弄上标签\r\n轻量标签\r\n$ git tag v1.0 给HEAD（lastest commit）打上标签\r\n$ git tag 看有什么标签\r\n$ git tag v1.0 f52c633 给commit\r\nid为f52...的提交打上标签\r\n附注标签\r\n$ git tag -a v1.4 -m \"my version 1.4\"\r\ngit show &lt;tagname&gt;\r\n查看标签信息，这个标签有哪些提交\r\n共享标签\r\ngit push\r\n命令并不会传送标签到远程仓库服务器上，在创建完标签后你必须显式地推送标签到共享服务器上\r\n$ git push origin v1.5\r\n删除标签\r\n$ git tag -d v1.4-lw\r\n$ git push origin --delete &lt;tagname&gt;\r\n还需删除远程标签\r\n远程库 remote\r\n\r\n把本地仓库推送到github上（添加远程库）\r\n名字即简写，代替整个 URL\r\ngit remote add origin2 http...\r\n$ git push origin dev\r\n把本地dev分支推送到远程库里\r\n$ git remote -v 需要读写远程仓库使用的 Git\r\n保存的简写与其对应的 URL。\r\n克隆仓库\r\n$ git clone https://github.com/libgit2/libgit2 mylibgit\r\n在当前目录下创建一个名为 “mylibgit” 的目录作为仓库\r\n要只克隆一个特定分支，你可以使用 --single-branch 选项来限制克隆的分支。以下是使用 git clone 命令只克隆一个分支的示例：\r\n\r\ngit clone --single-branch --branch &lt;branch-name&gt; &lt;repository-url&gt;\r\n\r\n$git fetch &lt;remote&gt;\r\n访问远程仓库，从中拉取所有你还没有的数据\r\n他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。\r\n你必须先抓取他们的工作并将其合并进你的工作后才能推送。\r\n$ git remote remove paul 移除远程库\r\nGit中的\"upstream\r\nbranch\"（上游分支）是指本地分支所跟踪的远程分支。当你执行git push命令时，Git会将本地分支的更改推送到相应的远程分支。错误消息中提供了一个解决方案，即使用git push --set-upstream origin master命令。这个命令将推送当前分支的更改到远程仓库的\"master\"分支，并将其设置为当前分支的上游分支（也就是将本地分支与远程分支进行关联）。\r\n\r\n多人协作的工作模式\r\n\r\n首先，可以试图用git push origin &lt;branch-name&gt;推送自己的修改；\r\n如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；\r\n如果合并有冲突，则解决冲突，并在本地提交；\r\n没有冲突或者解决掉冲突后，再用git push origin &lt;branch-name&gt;推送就能成功！\r\n\r\n（如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;。）\r\nrebase\r\n\r\ngit rebase &lt;branch&gt;：将当前分支上的提交应用到 &lt;branch&gt; 分支上。\r\nrebase操作可以把本地未push的分叉提交历史整理成直线；\r\nrebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。\r\n\r\n图形界面工具\r\nSource Tree\r\n重命名\r\n$ git mv README.md README\r\n其实，运行 git mv 就相当于运行了下面三条命令：\r\n$ mv README.md README$ git rm README.md$ git add README\r\n.gitignore\r\nGithub上传项目时，可能会遇到文件上传不上去，可以检查.gitignore用记事本打开看看文件的名字是否在里面，然后删除保存即可。\r\nto be learned\r\nhttps://www.jianshu.com/p/098d85a58bf1\r\nPull Request\r\nhttps://juejin.cn/post/6844903821521469448\r\n","tags":["GIT"]},{"title":"机器学习","url":"/2025/05/07/AI/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/","content":"Cov(x,y)\r\n是第一个和第二个分量之间的协方差 \r\n好的，我们来计算协方差矩阵 Σ=(2.54.25​4.257.3​)\r\n的特征值和对应的特征向量，并指出第一个主成分方向。\r\n1. 计算特征值：\r\n特征值 λ 是通过解以下特征方程得到的：\r\ndet(Σ−λI)=0\r\n其中，I 是 2×2 的单位矩阵。\r\n所以，我们得到两个特征值：\r\nλ1​=29.8+9.76166​≈219.56166​≈9.78083\r\nλ2​=29.8−9.76166​≈20.03834​≈0.01917\r\n2. 计算对应的特征向量：\r\n对于每个特征值 λ，我们需要解 (Σ−λI)v=0 来找到对应的特征向量\r\nv=(v1​v2​​)。\r\n对于特征值 λ1​≈9.78083：\r\n这给我们两个线性方程：\r\n\\(−7.28083v1​+4.25v2​=0\\) \\(4.25v1​−2.48083v2​=0\\)\r\n从第二个方程，我们可以得到：\r\nv1​≈0.5837v2​\r\n如果我们令 v2​=1，那么 v1​≈0.5837。所以，对应于 λ1​ 的特征向量 v1​\r\n大致为：\r\nv1​≈(0.58371​, 1)\r\n\r\n主成分是与协方差矩阵的特征向量相对应的方向，特征值的大小表示了该方向上的数据方差。第一个主成分方向是与\r\n最大 特征值相对应的特征向量。\r\n1. 计算总方差：\r\n总方差是所有特征值的总和。在主成分分析中，总方差代表了原始数据集中总的信息量（或者说总的散布程度）。\r\n总方差 =λ1​+λ2​≈9.78083+0.01917=9.8\r\n2. 计算每个主成分的方差贡献率：\r\n每个主成分的方差贡献率是该主成分的特征值占总方差的比例。它表示了该主成分所解释的原始数据变异性的百分比。\r\n第一个主成分的方差贡献率：\r\n​λ1/(λ1​+λ2)​​×100%≈9.89.78083​×100%≈0.99804×100%≈99.804%\r\n第二个主成分的方差贡献率：\r\nλ2/(λ1​+λ2)​​​×100%≈9.80.01917​×100%≈0.001956×100%≈0.196%\r\n3. 解释方差贡献率的意义：\r\n\r\n第一个主成分的方差贡献率约为 99.804%。\r\n这意味着第一个主成分单独就解释了原始数据中大约 99.804%\r\n的变异性。换句话说，原始数据的大部分信息都能够被这个主成分所捕获。如果我们只保留第一个主成分，我们仍然能够保留原始数据中绝大部分的散布和模式。\r\n第二个主成分的方差贡献率约为 0.196%。\r\n这表明第二个主成分只解释了原始数据中非常小的一部分变异性（约\r\n0.196%）。这意味着在第一个主成分已经捕获了几乎所有重要信息后，第二个主成分所包含的额外信息量非常有限。\r\n\r\n","tags":["AI"]},{"title":"LinuxLearning","url":"/2024/02/23/%E5%85%B6%E4%BB%96/LinuxLearning/","content":"linux\r\nbasic order\r\n\r\nls -l:详细信息\r\n\r\n第一个属性：文件类型+属主权限+属组权限+其他用户权限（d目录，-文件，l链接文件）（权限：r可读\r\nw可写 x可执行 -没有 'rwx' 'r-x'）\r\n\r\npwd 显示目前所在的目录\r\ncd . is itself\r\ntouch:create file mkdir:create dir\r\ncp A B cope A to B 可以将SOURCE文件复制为DEST文件;\r\n如果DEST是一个目录, 则将SOURCE文件复制到该目录下.\r\nmv SOURCE DEST可以将SOURCE文件重命名为DEST文件; 如果DEST是一个目录,\r\n则将SOURCE文件移动到该目录下.\r\nrm FILE\r\nman : learn the use of a order\r\nA | B的含义是创建两个进程A和B,\r\n并将A进程的标准输出连接到B进程的标准输入\r\nfind [目录路径] [expression] expression中:-name\r\n[pattern]（可用*和？） -type [type] -mtime +/-n\r\ncat 查看文件 ## 文本处理\r\ncat tac(从最后一行倒着显示) -b 显示的时候，在最开始输出行号\r\nmore/less 一页一页地翻　/string可以查找　(in less)?string\r\n向下查找\r\nhead/tail -n number 最前或最后几行\r\ngrep [options] pattern [files] -n：显示匹配行的行号。\r\n-r：递归查找子目录中的文件。 grep 'a*' x.txt　正则要加'' ##\r\n更改权限\r\nchown [who] [file] :change owner (更改文件目录)\r\nchmod [ugoa] [+-=] [rwx]\r\n(u文件所有者,g所在组,o所有其他用户,a所有用户) chmod [num] [file]\r\nr=4,w=2,x=1 如770就是rwxrwx--- ## 进程 进程就是一个正在运行的程序 在\r\nLinux 中，默认提供了 6 个文字界面登录窗口和一个图形界面，可以使用\r\nalt+F{1-7}来切换不同的终端机界面 每一个进程都有一个ＰＩＤ\r\n前景和背景(背景不能直接ctrl+c停止) 将 目前\r\n的工作丢到背景中_暂停_：ctrl+z ### jobs 观察目前的背景工作状态：jobs\r\n[-lrs] r:run s:stop '[2]+'里的+:the lastest job '[1]-'里的-:the second\r\nlastest job ### fg fg 取出＋的工作,即lastest\r\nfg num取出[num]工作 ### bg\r\n让工作在背景下的状态变成运行中：bg ### kill kill -9 %num强制结束[num]\r\nkiil -9 PID -15 正常结束 -SIGHUP 重启 -SIGINT 终止 -SIGKILL 强制终止\r\n-SIGSTOP ctrl+z -SIGTERM = -15\r\n### killall 用命令名字终止 -i:will ask you one by one ### priority nice\r\nwaiting for learning ### ps 只能查询自己 bash 进程的 ps -l\r\n可以查询所有系统运行的进程 ps aux Ｓ状态　R(running) S(sleep)\r\nD(sleep但不能唤醒) T(stop) Z ppid:父进程的PID SZ:用掉多少内存\r\nTIME:使用掉的 CPU 时间 PRI/NI:执行的优先级，越小越快 ### top -p [pid]\r\n指定看某些pid 在 top 执行过程中可以使用的按键指令：P(sort by\r\n%cpu),M(memory) ### pstree -A -p：并同时列出每个 process 的 PID\r\n看进程的相关性 ## bash (shell)\r\n只要能够操作应用程序的接口都能够成为壳程序 别名　alias lm='ls -al'\r\n\r\n变量\r\necho \\({aaa} 显示变量的值\r\naaa=lyx 赋值，字符串\r\nname=\\){aaa}+12138 ${}返回变量的值，否则是字符串 cd\r\n/lib/modules/${uname -r}/kernel 用 env\r\n观察环境变量与常见环境变量说明\r\n通配符\r\nls -l /usr/bin/X*　所有Ｘ开头的文件 ## 快捷键 ctrl+a\r\nctrl+e　到命令行首或尾 ## 端口 端口是设备与外界通讯交流的出口\r\nlsof -i 8080：查看8080端口占用 ## 重定向和ｐｉｐｅ\r\n标准输入&lt; 标准输出&gt; 错误输出2&gt; 单个符号是覆盖数据，2\r\n个符号的是追加数据\r\n硬链接和软链接\r\n在Linux文件系统中，磁盘中的文件都有一个索引编号（Inode\r\nIndex），在Linux中，可以多个文件名指向同一索引节点，这种就是硬链接。\r\n软链接（soft link），也叫符号链接（symbolic\r\nlink），是指向另一个文件的特殊文件，可以简单理解为一个快捷方式\r\n","tags":["Linux"]},{"title":"Vim","url":"/2025/01/20/%E5%85%B6%E4%BB%96/Vim/","content":"\r\n选中(), &#123;&#125;, []内的东西\r\n\r\nv/y/d + i/a + (/&#123;/[\r\ni: inner, a: around\r\n\r\n多文本替换的操作指令是 :substitute，一般直接用 :s；替换的完整指令公式是：:[range]s[ubstitute]/&#123;pattern&#125;/&#123;string&#125;/[flags]；\r\ngb 命令可以选中与我们光标所在的单词相同的且未被选中的第一个单词（当前往下搜索）\r\ndie删除整个文件中的文字 （e: entire）\r\nhttps://www.golang-mix.com/code/58 （很全）\r\nhttps://harttle.land/2016/08/08/vim-search-in-file.html\r\n（查找和替换）\r\n\r\n寄存器\r\nVim 有 48\r\n个寄存器，y, d, p 等命令一般使用匿名寄存器 \"\"，\r\n支持剪切板的 Vim\r\n会支持额外的选区寄存器 \"* 和 \"+。 更多 Vim\r\n寄存器的信息，可以参考这篇文章：Vim\r\n寄存器完全手册。\r\n\"* 和 \"+ 在 Mac 和 Windows\r\n中，都是指系统剪切板（clipboard），例如 \"*yy 即可复制当前行到剪切板。\r\n其他程序中复制的内容也会被存储到这两个寄存器中。 在 X11\r\n系统中（绝大多数带有桌面环境的 Linux 发行版），二者是有区别的：\r\n\r\n\"* 指 X11 中的 PRIMARY\r\n选区，即鼠标选中区域。在桌面系统中可按鼠标中键粘贴。\r\n\"+ 指 X11 中的 CLIPBOARD\r\n选区，即系统剪切板。在桌面系统中可按 Ctrl+V 粘贴。\r\n\r\n上述哪个寄存器对应于你的剪切板和 Linux 发行版有关，在配置 Vim\r\n前可以测试一下。 比如用 Vim 打开一个文件，在 normal 模式下（进入 Vim\r\n后默认的模式）键入 gg\"*yG，\r\n来把当前文件内容拷贝到 \"* 寄存器。键入 gg\"+yG 拷贝到 \"+ 寄存器。\r\n到目前为止，你已经可以通过命令来拷贝粘贴内容了。接下来我们希望通过\r\nVim 配置， 让匿名寄存器和系统剪切板同步。\r\n","tags":["Vim","学习笔记"]},{"title":"Python 爬虫","url":"/2024/02/23/%E5%85%B6%E4%BB%96/Python%20%E7%88%AC%E8%99%AB/","content":"基本\r\nPython virtual environment (venv)\r\n$ pip list\r\n这将显示当前虚拟环境中安装的所有软件包及其版本号。\r\nrequest库\r\nr = requests.get(URL)# or put/delete/head/options\r\nresponse = requests.get(url, params = p_data)# p_data 是dict结构， 给url添加参数response.encodingr.status_code == requests.codes.ok # 相当于r.ok# status_code 状态码对象\r\nr.content 是字节形式内容，text是编码后的内容（一般是Unicode编码）\r\n当http状态码为418时，可以发送user-agent\r\nheaders=&#123;\t&#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36&#x27; &#125;\r\nBeautifulSoup 和 lxml\r\nbs1 = BeautifulSoup(ht.content, 'lxml')\r\nlxml是xml和html的解析器\r\nbs1.prettify(),用于美化HTML或XML文档的输出。\r\nfrom lxml import html # 若换为etree则为普通树结构text = requests.get(url).textht = html.fromstring(text)h1Ele = h1.xpath(&#x27;//*[@id=&quot;firstHeading&quot;]&#x27;)[0] # 所有元素中id属性为~的\r\nbs1.find() and find_all() and\r\nselect()\r\nXPath\r\n[[MongoDB]]\r\n详见 https://cuiqingcai.com/202243.html\r\n还有自己的程序\r\n疑问\r\n","tags":["Python"]},{"url":"/2025/03/22/%E5%85%B6%E4%BB%96/database_cmu15445/","content":"\r\n"},{"title":"大二下总结","url":"/2025/08/19/%E5%85%B6%E4%BB%96/%E5%A4%A7%E4%BA%8C%E4%B8%8B%E6%80%BB%E7%BB%93/","content":"大学的时间越来越快了，一直以为自己是刚进大学的小东西，现在已经变成经验丰富的学长了。这个学期也总是纠结和焦虑着，但是当真正看到自己的出路的时候，反而没那么紧张了。突然发现，所有的出路，好像都还可以，大学两年的所有努力，所有焦虑，都日积月累，变成了现在的资本。\r\n我慢慢打开眼界，也发现很多以为遥不可及的东西也都像是一个草台班子，科研，公司，创业……，发现技术能力不是一切，发现我也许也能做很多事。\r\n这学期最开始在速通 LLM 推理，发现 ai 不是那么玄乎。然后迷上了\r\ncmu15445，虽然仍然没有做完，但是学到了很多工程化的东西。真的很漂亮的工程代码，真的很有意思很有热情的老师。打系统能力赛，看到了另一个极端的史山。后来开始面试，兜兜转转又回到前端，感觉前端底层更有意思了。\r\n后来开始接触创业，见到了和cmu15445完全相反的一面： vibe coding\r\n对前后端的熟练，以及大家对前后端的观念的改变（也受了很多委屈吧），希望以后能更有自信更快得走出去。\r\n实习也让我看到了很有意思的前端框架，发现大厂真的对整个前后端的框架和实现做了很多很多的事情，也遇到了梦中情组。还有面试很有意思。\r\n我也要在很喜欢的联创当上组长了，希望能为联创做一些事情。\r\n","tags":["生活","总结"]},{"title":"组原","url":"/2025/04/05/%E5%85%B6%E4%BB%96/%E6%95%B0%E7%94%B5+%E7%BB%84%E5%8E%9F/","content":"注意补码的移位和扩展都是符号扩展 ## 数电 - 最小项 A是最高位 - ieee754\r\n1 8 23 ；1 11 52 ## 编码 - 为保持与十进制数的唯一对应，\r\n2421码不使用0101～ 1010等6种状态。\r\n5不是0101而是1011开始。对9的自补，按位取反=9-x。 -\r\n余三：无权码（8421，2421是有权），对9自补（按位取反=15-(x+3)=(9-x)+3 -\r\n格雷：格雷码任意两个相邻数仅有一位不同  - 码距:\r\n同一编码体系中，任意两个合法编码（value）之间二进制数（key）不同位数的最小值。校验码中增加冗余项的目的就是为了扩大码距\r\n- 检错和纠错： d-1 and (d-1)//2 -\r\n奇偶校验：最后一位看前面1个数的奇偶，只能验错，2位 - ## 运算器 -\r\n多路分配器就是多路选择器反过来 - 加法器 - 串行：行波进位加法器：\\(S_t = X_t \\oplus Y_t \\oplus C_t\\) \\(C_{t+1} = X_t Y_t + (X_t \\oplus Y_t) C_t\\)\r\n- 可控加减法：y^=ifsub c0=ifsub - 溢出 Cn ^ Cn+1 ,\r\nCn+1是符号位运算后的溢出 - 并行：先行进位加法器 -  - Ci+1 = Gi+PiCi\r\n-&gt; Ci = f(G, P, C0) - Ci+4 = G*i+P*iCi -&gt; Ci*4 = f(G, P,\r\nC0)\r\n-  - 乘法器 -\r\n原码一位乘法：类似快速幂 1. if (y0 == 1) p+=x; else p+=0; 2. (c_out + p\r\n+ y）&gt;&gt;=1 =&gt; reg , i++ until i == n\r\n（移位的时候答案p0变成y的高位，n次做完之后移位之后放入寄存器的就是答案 -\r\n补码一位乘法： -\r\n阵列乘法器  -\r\n一行内的进位不与此行更高位关联，而是和下一行的更高位，从而做到并行 o(n)\r\n- 除法器 - 原码不恢复余数法：\\(R_{i+1} =\r\n2R_i+(-1)^{q_i = seg(R_i)}y\\) 1. Ri +=(-1)^q0 * y 2. q =\r\nq&lt;&lt;1+(Ri &gt; 0) 3. Ri &lt;&lt;=1 - 阵列除法器 （O(n^2)） - （其中CAS是可控加减法单元，斜着不变是y）\r\n## 同步时序电路 特征方程 \r\n钟控：只有ck为1的时候随便变 ## 存储器\r\nSRAM,DRAM,ROM\r\n题\r\n1、某动态存储器存储单体的容量是\\(64K*8\\)位,采用双译码结构且地址线平均送到两个译码器，刷新周期是2ms\r\n(abc) A.动态存储器的刷新按行进行 B.该动态存储器的刷新地址计数器的模为2^8\r\nC.该动态存储单体地址线之和为16\r\n2、下列属于导致DRAM 比SRAM慢的原因是abc A.DRAM需要刷新操作 B.DRAM\r\n读写过程中其地址分行、列分时传送，行列地址线复用\r\nC.读操作前先要进行预充操作 D.DRAM的容量比SRAM容量大\r\n集中刷新虽然保持了存储单体的高速特性，但存在死时间 00001111\r\n异步刷新方式既保持了存储单体的高速特性，也不存在死时间 00001000001\r\n分散刷新由于刷新次数过多，大大降低了存储单体的性能 010101\r\n读操作也具有刷新功能 某DRAM芯片地址引脚数据为12根，则其容量为16M\r\n掩模ROM（MROM）是只读存储器，由厂家写入固定程序，用户无法修改；PROM可由用户编程一次，写入后不可改写；EPROM可通过紫外线擦除并重新编程；EEPROM支持电擦除和重写，适合频繁更新数据；Flash\r\nMemory则是一种非易失性存储器，支持快速擦写，广泛用于存储卡和U盘等设备。\r\n位/字扩展\r\n\r\n位扩展  #\r\n或者上面横线表示：低电平有效 WE write enable （ROM没有） MREQ memory\r\nrequest CS chip select 片选（选哪一片） R/W 高写 （R/W#为低电平（写））\r\nA D A高3位给mux，D平分 先看要多少片，再看扩展方向\r\n主存\r\n主存一般按字节编址 -&gt; xxx*8位（地址范围*存储单元)\r\ncache\r\n\r\n时间局部性和空间局部性\r\nfor(int i = 1; i &lt;= 100;i++) sum+=a[i] i,sum\r\n时间，a空间\r\n命中率，缺失率，访问效率 （命中访问时间 /\r\n平均访问时间）（最理想就是都命中：1）\r\n写穿（每次写都会写到主存） and 写回\r\n写分配法：要写的块未命中，则先从主存弄到cache。否则直接写到主存里\r\n块包含若干个字，是cache和主存直接传递信息的单位\r\n映射\r\n\r\n全相联映射\r\n\r\naddress = tag + offset\r\ntag作为key，用相联存储器（CAM，查找表，并发比较）\r\n\r\n直接相联映射\r\n\r\naddress = tag + index + offset\r\nindex是行号，所有行号相同的地址都会存储在一个地方（冲突）（相当于hash），index的范围就是cache的行数\r\n\r\n组相联映射\r\n\r\n前两者折中\r\n先直接相联，但是每个组号（上面的行号）相同的会对于一个CAM（k行-&gt;k路）\r\n\r\n\r\ncache的总容量 = n * (有效位+tag+块大小) 注意B和bit转换 ###\r\n虚拟存储器 MMU：通过虚拟地址找到物理地址的硬件\r\nTLB：页表的cache（把vpn分为tag+offset） PTE：页表\r\nPTEA：页表地址=base+虚拟页号 PPN：物理页号 物理地址PA=物理页号+页偏移\r\n01C60H 中的H是十六进制的意思 \r\n\r\n指令系统\r\n寻址方式\r\n指令寻址 - 顺序寻址 - 跳转寻址 操作数寻址 + 立即寻址 +\r\n地址码字段是操作数本身(相当于不用寻址,直接就是操作数) + 直接寻址 +\r\n间接寻址 + 需要两次访存,速度慢,已经淘汰 + 寄存器寻址 + 寄存器间接寻址 +\r\n相对寻址 PC+X + 基址/变址寻址 ，\r\nMOV  DX, D[EBP] （E = (EBP)*16 +D）\r\n（区别是概念上的，基址+偏移量（哪个是寄存器）） + 复合寻址\r\n注意问的是数据还是地址\r\n操作码扩展\r\n操作码字段不固定 双操作数操作码k位，有m条，则有 \\((2^k - m) * 2^t\\)\r\n可以单，t是单操作数多出来的\r\n相对寻址，注意pc+=当前指令字节数 1byte=8bit ## cpu ### 指令类型\r\nR型指令格式：opcode | rs | rt | rd | shamt | funct\r\nI型指令格式：opcode | rs | rt | immediate\r\n\r\n传统三级时序硬布线\r\n机器周期 Mif Mcal Mex 3机器周期*4节拍（T） B ： 结果反馈信号 \r\n单周期\r\nclk只控制写，在每个指令的数据通路末端，reg，mem，pc\r\n多周期\r\n加了IR,DR,A,B,C\r\n微指令\r\nbeq的第二个指令的下址是00000，因为p_eq=1，如果eq=0，转到取值，如果eq=1，p_eq对应的分支地址\r\nP0分支地址通过IR指令字来\r\n中断\r\nt当多个设备同时发中断请求时，CPU优先响应优先级高中断请求。t当CPU正在处理某个中断请求时，如果有更高优先级的中断请求，则高级中断可以中断正在被服务的低级中断；t同级中断不能中断同级中断；\r\n关中断，保护断点，中断源识别 \r\n","tags":["硬件","底层原理"]},{"title":"css学习笔记","url":"/2024/02/23/%E5%89%8D%E7%AB%AF/CSS/","content":"css学习笔记\r\n选择多个元素\r\np,li,h1&#123;\tColor:red;&#125;\r\n选择器\r\n\r\n通用选择器（选择全部）：*\r\n伪类\r\n属性选择器\r\na:hover {color :red;}当鼠标停在a上时\r\n\r\n属性\r\ncolor\r\nFont-family字体\r\nFont-size\r\nText-align向哪里对齐\r\nPadding 内边距\r\nMargin 外边距\r\n\r\n当只指定一个值时，该值会统一应用到全部四个边的外边距上。\r\n指定两个值时，第一个值会应用于上边和下边的外边距，第二个值应用于左边和右边。\r\n指定三个值时，第一个值应用于上边，第二个值应用于右边和左边，第三个则应用于下边的外边距。\r\n指定四个值时，依次（顺时针方向）作为上边，右边，下边，和左边的外边距。\r\nauto\r\n\r\n让浏览器自己选择一个合适的外边距。有时，在一些特殊情况下，该值可以使元素居中。\r\ncolor：元素内容（通常是文本）的颜色\r\nbackground-color：元素内容和内边距底下的颜色\r\nWidth height\r\ncss变量\r\n必须以--开头\r\n定义：--aa:50px;\r\n应用：height:var(--aa);\r\ncss动画\r\nhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_animations/Using_CSS_animations\r\ntransition and transform\r\nflex布局\r\ndisplay:flex\r\n主轴和交叉轴\r\nflex-direction:row 或 row-reverse 或\r\ncolumn 或 column-reverse（主轴）\r\n宽度\r\nauto\r\n足够大时相当于 width=max-content（一直不换行）\r\n当元素宽度远远超过容器宽度时，相当于\r\nwidth=min-content（最大单词的距离）\r\n设置宽度\r\n\r\nflex-basis 基础长度\r\nflex-grow 生长的权值 （\\(\\sum_i\r\n(flexBasis_i+flexGrow_i*x)=contentWidth\\) 这样求x）\r\n（0：最大就是basis）\r\n实现某元素的宽度是其他元素的宽度的5倍：flex-basis：0px\r\n（1：容器不够时均匀缩小）\r\nflex-shrink\r\n缩小的权值（如果子元素宽度和大于了容器宽度）\r\n（\\(\\sum_i\r\n(flexBasis_i-flexShrink_i*x)=contentWidth\\) 这样求x）\r\nflex:&lt;grow&gt; &lt;shrink&gt; &lt;basis&gt;\r\n默认 flex:0 1 auto;= flex:initial\r\nnone = 0 0 auto\r\n\r\n对齐\r\n（包括内部的文字也算一个item）\r\n\r\n主轴上\r\nalign-items（一个主轴上）\r\nstretch 所有的元素行高都一样（默认）\r\n在交叉轴起点/终点/中间对齐 align-items : flex-start flex-end\r\ncenter\r\nbaseline 不管字体大小，都在文字的基线来对齐\r\nalign-content（多个主轴上）\r\n同下（justify-content）\r\n交叉轴上\r\njustify-content : flex-start flex-end center\r\nspace-between 中间相同空隙，首尾紧靠两边\r\nspace-around 中间相同空隙，首尾与两边的空隙是中间的1/2\r\nspace-evenly 中间与首位的空隙都相同\r\n换行\r\nflex-wrap:wrap 保证宽度的同时换行\r\n顺序\r\norder\r\n无障碍人士\r\ncss过渡动画\r\n过渡不行时试试\r\nsetTimeout(() =&gt; &#123;element.style.top = \"100px\";&#125;,1);\r\ndiscussion\r\ncursor属性\r\ncursor属性用于指定鼠标指针在元素上的样式。它可以改变鼠标指针的外观，以提供视觉反馈或指示用户可以执行的操作。\r\ndefault箭头 pointer手指，可点击 text文本\r\n选择器\r\n相邻兄弟选择器 ‘+’\r\ninput[type=\"checkbox\"]:checked + label 是一个 CSS\r\n选择器，用于选择被选中的复选框（checkbox）后面紧邻的\r\n&lt;label&gt; 元素。\r\n一般兄弟组合器 ~\r\n后一个节点在前一个节点后面的任意位置，并且共享同一个父节点。\r\n后代选择器 ‘ ’（空格）\r\n要实现当某个元素被覆盖时，其子元素的样式发生改变，可以使用 CSS\r\n中的后代选择器（descendant selector）和伪类选择器（pseudo-class\r\nselector）。\r\n首先，您可以使用后代选择器来选择被覆盖元素的子元素。后代选择器使用空格来表示元素之间的层级关系。\r\n&gt; : 直接子代选择器\r\n:nth-child\r\n不是真的子元素，是这个选择器选择的第n个，比如下面选择的都是&lt;li&gt;\r\n/* 选择第3个子元素 */ li:nth-child(3) /* 选择所有3的倍数位置的子元素 */ li:nth-child(3n) /* 选择所有3的倍数位置的子元素，并减去2 */ li:nth-child(3n-2)\r\n属性选择器\r\nlink\r\n分组选择器 ，\r\n,\r\n是将不同的选择器组合在一起的方法，它选择所有能被列表中的任意一个选择器选中的节点。\r\n:where\r\n:where(h1, h2, h3) 将选择\r\n&lt;h1&gt;、&lt;h2&gt; 和\r\n&lt;h3&gt; 元素 :where(section, article) p\r\n选择器将选择 &lt;section&gt; 和\r\n&lt;article&gt; 元素中的所有 &lt;p&gt;\r\n元素，并将样式规则应用于它们。\r\n:not\r\n是一个CSS伪类选择器，用于选择不符合指定选择器的元素。\r\np:not(.red) 选择器将选择所有 &lt;p&gt;\r\n元素，但排除了具有 red 类的元素\r\n修改属性\r\n嗯，你提到的labelElement.for = 'myInput'语法是无效的，因为for是label元素的保留属性，不能直接通过赋值来修改。\r\n要修改label元素的for属性，你可以使用setAttribute()方法，如下所示：\r\nconst labelElement = document.getElementById(&#x27;myLabel&#x27;);labelElement.setAttribute(&#x27;for&#x27;, &#x27;myInput&#x27;);\r\n这样，label元素的for属性就会被设置为\"myInput\"，与id为\"myInput\"的表单元素关联起来。\r\n请注意，使用setAttribute()方法可以在任何情况下修改元素的属性。\r\ncss函数\r\nCSS中有一些内置的函数，可以用于处理值、生成动态效果或执行其他操作。以下是一些常见的CSS函数：\r\n\r\nrgb() 和\r\nrgba()：用于设置颜色值，接受红、绿、蓝和透明度参数。\r\n   color: rgb(255, 0, 0);       /* 红色 */   background-color: rgba(0, 0, 255, 0.5);  /* 半透明蓝色 */   ```2. `hsl()` 和 `hsla()`：用于设置颜色值，接受色调、饱和度、亮度和透明度参数。   ````css   color: hsl(120, 100%, 50%);       /* 饱和度为100%，亮度为50%的绿色 */   background-color: hsla(240, 100%, 50%, 0.5);  /* 半透明的饱和度为100%，亮度为50%的蓝色 */   3. `calc()`：用于执行数学计算，可以在CSS属性中使用。   ````css   width: calc(100% - 20px);   /* 宽度为父元素宽度减去20像素 */   4. `var()`：用于引用CSS自定义属性的值。   ````css   --primary-color: blue;   color: var(--primary-color);   /* 使用自定义属性的值作为颜色 */   5. `url()`：用于引用外部资源，如图像、字体等。   ````css   background-image: url(&quot;path/to/image.jpg&quot;);   /* 引用图像资源 */\r\n\r\ncss单位\r\n\r\npx\r\n百分比（%）：百分比单位相对于父元素的相对值。\r\nem：em单位是相对于元素的字体大小。如果修改的属性为font-size，则相对于父元素的字体大小。\r\nfont-size: 1.2em;   /* 相对于父元素字体大小的1.2倍 */margin: 0.5em;      /* 相对于元素字体大小的0.5倍 */\r\n视窗单位（vw、vh、vmin、vmax）：视窗单位是相对于视窗大小的相对值。\r\nwidth: 50vw;    /* 相对于视窗宽度的50% */height: 25vh;   /* 相对于视窗高度的25% */\r\n\r\n背景图片自适应\r\n&lt;div    :style=&quot;&#123;      backgroundImage: `url($&#123;backgroundImageUrl&#125;)`,      height: &#x27;100%&#x27;,    &#125;&quot;    class=&quot;bg-cover w-full absolute&quot;    id=&quot;container&quot;\r\n","tags":["前端","CSS"]},{"title":"HTML","url":"/2024/02/23/%E5%89%8D%E7%AB%AF/HTML/","content":"简介\r\n&lt;!doctype html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot; /&gt;        &lt;title&gt;test&lt;/title&gt;        &lt;link style=&quot;&quot;    &lt;/head&gt;    &lt;body&gt;            &lt;/body&gt;&lt;/html&gt;\r\n&lt;head&gt; 不可见的东西\r\n&lt;body&gt; 可见的东西\r\n:src\r\n&lt;h1&gt;\r\n\r\n\r\n:标题\r\n&lt;p&gt;段落\r\n&lt;ul&gt;\r\n\r\n列表：·或者1./里面用\r\n\r\n表示一行\r\n\r\n就是\r\n\r\n\r\n\r\n就是\r\n\r\n\r\n:href\r\nhtml5语义化标签\r\n引入代码文件\r\nbody最后：\r\n&lt;script src=&quot;aaa.js&quot;&gt;&lt;/script&gt;\r\nhead里： &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;\r\n&lt;label&gt;标签\r\n&lt;label&gt;元素可以通过两种方式与相关的表单元素关联起来：使用for属性或者将表单元素放置在&lt;label&gt;标签内部。当使用for属性时，for属性的值应该与相关表单元素的id属性值相匹配。这样，当用户点击&lt;label&gt;元素时，相关的表单元素就会获得焦点或选中。\r\n这提供了更大的点击区域，使用户更容易选择或输入数据。使用&lt;label&gt;元素可以增加HTML文档的语义化。\r\n","tags":["前端","HTML"]},{"title":"Node.js","url":"/2024/02/23/%E5%89%8D%E7%AB%AF/Node.js/","content":"node.js\r\n基本操作\r\nnode aa.js 运行\r\n第一行总是写上'use strict';是因为我们总是以严格模式运行JavaScript代码，避免各种潜在陷阱。\r\n此外，文件名只能是英文字母、数字和下划线的组合。\r\n看到只有&gt;是在Node交互式环境下\r\n两次ctrl+c退出node环境\r\nnode --use_strict calc.js 开启严格模式\r\n模块：完成一种功能的单独一个文件\r\nmodule.exports = greet;\r\n把greet函数作为入口（hello.js文件中）\r\nvar aa = require(\"./hello\");\r\n引入的hello模块作为变量保存在aa变量中，aa就是hello中的greet\r\n位于同一个目录，所以我们用了当前目录. 。\r\nglobal\r\n唯一的全局变量\r\nprocess\r\n\r\n如果我们想要在下一次事件响应中执行代码，可以调用process.nextTick()\r\n如果我们响应exit事件，就可以在程序即将退出时执行某个回调函数：\r\n// 程序即将退出时的回调函数:process.on(&#x27;exit&#x27;, function (code) &#123;    console.log(&#x27;about to exit with code: &#x27; + code);&#125;);\r\n\r\nfs模块\r\n读写文件\r\n异步读文件\r\nvar fs = require(&#x27;fs&#x27;);fs.readFile(&#x27;sample.txt&#x27;, &#x27;utf-8&#x27;, function (err, data) &#123;    if (err) &#123;        console.log(err);    &#125; else &#123;        console.log(data);    &#125;&#125;);\r\n但正常读取时err=null\r\n\r\n文本文档 data是String\r\n二进制文件 data是Buffer 一个包含零个或任意个字节的数组\r\nlet a = new Buffer(&#x27;END.&#x27;, &#x27;utf-8&#x27;);//string to buffer by utf-8\r\n\r\n同步读文件\r\nvar data = fs.readFileSync(&#x27;sample.txt&#x27;, &#x27;utf-8&#x27;);\r\n异步写文件\r\nvar data = &#x27;Hello, Node.js&#x27;;fs.writeFile(&#x27;output.txt&#x27;, data, function (err) &#123;    if (err) &#123;        console.log(err);    &#125; else &#123;        console.log(&#x27;ok.&#x27;);    &#125;&#125;);\r\n文件信息\r\nfs.stat(&#x27;sample.txt&#x27;, function (err, stat) &#123;    if (err) &#123;        console.log(err);    &#125; else &#123;        // 是否是文件:        console.log(&#x27;isFile: &#x27; + stat.isFile());        // 是否是目录:        console.log(&#x27;isDirectory: &#x27; + stat.isDirectory());        if (stat.isFile()) &#123;            // 文件大小:            console.log(&#x27;size: &#x27; + stat.size);            // 创建时间, Date对象:            console.log(&#x27;birth time: &#x27; + stat.birthtime);            // 修改时间, Date对象:            console.log(&#x27;modified time: &#x27; + stat.mtime);        &#125;    &#125;&#125;);\r\nstream\r\n支持“流”这种数据结构，还是在fs模块中的\r\n读\r\nvar rs = fs.createReadStream('sample.txt', 'utf-8');\r\ndata事件表示流的数据已经可以读取了，end事件表示这个流已经到末尾了，没有数据可以读取了，error事件表示出错了。\r\n要注意，data事件可能会有多次，每次传递的chunk是流的一部分数据。\r\n写\r\ncreateWriteStream\r\n要以流的形式写入文件，只需要不断调用write()方法，最后以end()结束：\r\npipe()\r\n把两个文件流串起来\r\nvar rs = fs.createReadStream(&#x27;sample.txt&#x27;);var ws = fs.createWriteStream(&#x27;copied.txt&#x27;);rs.pipe(ws);//cope the file//rs.pipe(ws, &#123; end: false &#125;);//not close ws stream, can still write\r\nhttp模块\r\nrequest对象：HTTP请求\r\nresponse对象：HTTP响应\r\n由于response对象本身是一个Writable Stream\r\nnpm\r\nCLI(只允许键盘输入) &amp; GUI(图形化界面)\r\n起始\r\ncd xxx\r\nnpm init 生成package.json档案\r\n设置代理\r\nnpm config set proxy http://127.0.0.1:翻牆端口\r\n代理服务器 IP 地址和端口号查找\r\n\r\n在开始搜索“Internet 选项”。\r\n选择“连接”标签页。\r\n点击“局域网设置”按钮。\r\n在弹出的窗口中，您可以看到代理服务器 IP 地址和端口号。\r\n\r\n锁定文件\r\npnpm-lock.yaml 和 package-lock.json\r\n都是项目中的锁定文件，它们的作用是锁定项目所依赖的包的版本。\r\npnpm-lock.yaml 是由 pnpm（一个 JavaScript\r\n包管理工具）生成的锁定文件，它记录了所有项目依赖的包的版本。\r\npackage-lock.json 是 NPM（Node Package Manager，一个 JavaScript\r\n包管理工具）生成的锁定文件，它也记录了所有项目依赖的包的版本。\r\ninstall\r\nnpm install lodash --save\r\n设置与项目相依，会存在package.json中\r\n卸载 uninstall\r\nnpm ls查看已安装\r\nnpm update lodash\r\n版本控制\r\n版本号有三位数字组成（譬如：1.2.3），1\r\n表示主版本、1.2表示次要版本、1.2.3\r\n表示补丁版本。\r\n^ 表示用于确定主版本号、 ~ 用于确定主版本号\r\n+ 次要版本号；\r\n\r\n^1 ：等同于 1.x.x ,\r\n以1开头的所有版本；\r\n~2.2 ：等同于 2.2.x ，以 2.2\r\n开头的所有版本。\r\n~2.2.1 ：以 2.2 开头，且最后一位 补丁号≥1\r\n的所有版本，即 2.2.1 与 2.2.9\r\n之间版本，包括头尾。\r\n\r\n","tags":["前端","Nodejs"]},{"title":"SSE 流式传输——组会分享","url":"/2025/01/20/%E5%89%8D%E7%AB%AF/SSE%20%E6%B5%81%E5%BC%8F%E4%BC%A0%E8%BE%93/","content":"\r\nSSE 全称为 Server-sent\r\nevents , 是一种基于 HTTP\r\n协议的通信技术，允许服务器主动向客户端（通常是Web浏览器）发送更新。这种服务端实时向客户端发送数据的传输方式，其实就是流式传输。\r\n\r\nSSE 与 WebSocket 区别： - SSE 使用 HTTP\r\n协议，现有的服务器软件都支持。WebSocket 是一个独立协议。 - SSE\r\n属于轻量级，使用简单；WebSocket 协议相对复杂。 - SSE\r\n默认支持断线重连，WebSocket 需要自己实现。 - SSE\r\n一般只用来传送文本，二进制数据需要编码后传送，WebSocket\r\n默认支持传送二进制数据。 - SSE 支持自定义发送的消息类型。\r\n三种状态（EventSource.readyState） -\r\nEventSource.CONNECTING -&gt; message 事件 - EventSource.OPEN -&gt; open\r\n- EventSource.CLOSED -&gt; close\r\n","tags":["前端","后端"]},{"title":"高三暑假集训总结","url":"/2024/02/23/%E5%89%8D%E7%AB%AF/Vue3/","content":"Vue3学习笔记\r\n开始\r\nhttps://cn.vuejs.org/guide/quick-start.html\r\npnpm create vite FrontEndTs --template vue-ts\r\n应用与组件\r\n一个vue应用里有很多组件，组成组件树，\r\nimport &#123; createApp &#125; from &#x27;vue&#x27;// 从一个单文件组件(.vue)中导入根组件(App)import App from &#x27;./App.vue&#x27;const app = createApp(App)app.mount(&#x27;#app&#x27;) // 应用根组件(app)的内容将会被渲染在容器元素(#app)里面。//不包括此容器(#app)\r\n数据绑定\r\n文本插值\r\nNaN\r\n(内部支持js语法，但必须是一个表达式，if不行，三元表达式可以，可以是一个函数)\r\n指令\r\n指令是带有 v- 前缀的特殊 attribute。\r\nv-html\r\n这里看到的 v-html attribute\r\n被称为一个指令。简单来说就是：在当前组件实例上，将此元素的\r\ninnerHTML 与 rawHtml\r\n属性保持同步。其中rawHtml是script中的变量\r\n&lt;p&gt;Using text interpolation: &#123;&#123; rawHtml &#125;&#125;&lt;/p&gt;&lt;p&gt;Using v-html directive: &lt;span v-html=&quot;rawHtml&quot;&gt;&lt;/span&gt;&lt;/p&gt;\r\nv-bind\r\nv-bind 指令指示 Vue 将元素的 id attribute\r\n与组件的 dynamicId 属性保持一致。如果绑定的值是\r\nnull 或者 undefined，那么该 attribute\r\n将会从渲染的元素上移除。\r\n&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt;\r\n简写（更常见） 去掉v-bind\r\n&lt;div :id=&quot;dynamicId&quot;&gt;&lt;/div&gt;\r\n另一种方法（绑定多个值）：绑定一个对象，对象的键值是属性名\r\nv-if v-else-if v-else\r\n&lt;div v-if=&quot;condition1&quot;&gt;  &lt;!-- 在条件1为真时渲染的内容 --&gt;&lt;/div&gt;&lt;div v-else-if=&quot;condition2&quot;&gt;  &lt;!-- 在条件1为假且条件2为真时渲染的内容 --&gt;&lt;/div&gt;&lt;div v-else&gt;  &lt;!-- 在前面的条件都不满足时渲染的内容 --&gt;&lt;/div&gt;\r\nv-on 监听事件\r\n&lt;a v-on:click=&quot;doSomething&quot;&gt; ... &lt;/a&gt;&lt;!-- 简写 --&gt; &lt;a @click=&quot;doSomething&quot;&gt; ... &lt;/a&gt;\r\n: 后的属性也是可以\r\nv-model 双向绑定\r\n&lt;input v-model=\"text\"&gt; &lt;p&gt;&#123;&#123; text &#125;&#125;&lt;/p&gt;\r\n（把text的值和输入框的value双向绑定）\r\n跟踪某个dom节点的值时（如input的value）经常使用\r\nv-for\r\n&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;// 给每个 todo 对象一个唯一的 idlet id = 0const newTodo = ref(&#x27;&#x27;)const todos = ref([  &#123; id: id++, text: &#x27;Learn HTML&#x27; &#125;,  &#123; id: id++, text: &#x27;Learn JavaScript&#x27; &#125;,  &#123; id: id++, text: &#x27;Learn Vue&#x27; &#125;])function addTodo() &#123;  todos.value.push(&#123; id: id++, text: newTodo.value &#125;)  newTodo.value = &#x27;&#x27;&#125;function removeTodo(todo) &#123;  todos.value = todos.value.filter((t) =&gt; t !== todo)&#125;&lt;/script&gt;&lt;template&gt;  &lt;form @submit.prevent=&quot;addTodo&quot;&gt;    &lt;input v-model=&quot;newTodo&quot;&gt;    &lt;button&gt;Add Todo&lt;/button&gt;      &lt;/form&gt;  &lt;ul&gt;    &lt;li v-for=&quot;todo in todos&quot; :key=&quot;todo.id&quot;&gt;      &#123;&#123; todo.text &#125;&#125;      &lt;button @click=&quot;removeTodo(todo)&quot;&gt;X&lt;/button&gt;    &lt;/li&gt;  &lt;/ul&gt;&lt;/template&gt;\r\n响应式\r\n在Vue.js中，响应式是指当数据发生变化时，相关的视图会自动更新以保持与数据的同步。\r\n只有添加了响应式才能改变\r\nrep()\r\nint a = 0; =&gt; int a = rep(0);\r\na++; =&gt; a.value++; !!!记得加value\r\nreactive 数组或对象，不用加value\r\n记得import { ref } from 'vue'\r\ncomputed()\r\n跟踪其他东西，其他东西变得时候它变\r\nconst filteredTodos = computed(() =&gt; &#123;  return hideCompleted.value    ? todos.value.filter((t) =&gt; !t.done)    : todos.value&#125;)\r\nwatch()\r\n当观察的变量变了的时候执行回调函数\r\nwatch(count, (newCount) =&gt; &#123;\tconsole.log(`new count is: $&#123;newCount&#125;`) &#125;)\r\n只要hideCompleted.value或者todos.value变得时候就会变\r\n模板引用\r\n&lt;p ref=\"pElementRef\"&gt;hello&lt;/p&gt;\r\nconst pElementRef = ref(null);\r\npElementRef.value就是那个dom节点\r\n生命周期钩子\r\n\r\nonMounted （组件都挂载（mount）之后调用回调函数）\r\n\r\nonMounted(() =&gt; &#123;  // component is now mounted. &#125;)\r\n\r\nonUpdated\r\n\r\n组件嵌套\r\nimport ChildComp from './ChildComp.vue'\r\n&lt;ChildComp /&gt;\r\n数据下放\r\nprops\r\nA child component can accept input data from the parent via\r\nprops.\r\nin 父组件：&lt;ChildComp :msg=\"greeting\" /&gt;\r\n（msg是子组件里的名字，相当于子组件的一个属性。greeting是父组件的一个变量）\r\nin 子组件：\r\nconst props = defineProps(&#123; msg: String &#125;)\r\n注意在template可以直接用msg（也可以用props.msg（建议）），但在script中只能是props.msg\r\n可以动态改变 #### v-model 双向绑定\r\nhttps://vuejs.org/guide/components/v-model.html\r\nslot\r\n&lt;ChildComp&gt;  This is some slot content!&lt;/ChildComp&gt;// or &lt;ChildComp /&gt; means no slot\r\n&lt;slot&gt;Fallback content&lt;/slot&gt;// or &lt;slot /&gt; (means no fallback)\r\n数据上传\r\n&lt;script setup&gt;// declare emitted events //自定义上传函数名const emit = defineEmits([&#x27;response&#x27;])// emit with argument, 第二个参数到最后一个参数是下面那个回调函数的参数emit(&#x27;response&#x27;, &#x27;hello from child&#x27;)&lt;/script&gt;\r\n&lt;ChildComp @response=&quot;(msg) =&gt; childMsg = msg&quot; /&gt;\r\nPinia\r\n它有点像一个永远存在的组件，每个组件都可以读取和写入它。它有三个概念，state、getter 和 action，我们可以假设这些概念相当于组件中的 data、 computed 和 methods。\r\nstore 应该用于在许多地方使用的数据 ## 杂记\r\n文件信息\r\nimport.meta.glob 是 Vite 提供的一个特性，它可以在\r\nJavaScript 或 Vue\r\n文件中使用。这个函数会匹配文件系统中的所有特定模式的文件，并将它们作为\r\nJavaScript 模块导入。\r\n例如，如果你想要导入目录中的所有 .js\r\n文件，你可以这样做：\r\nconst modules = import.meta.glob('./*.js');\r\n这将返回一个对象，其中的每个键都是匹配的文件路径，每个值都是导入这个模块的函数，返回值是这个模块（组件）。\r\n这个特性在你需要动态导入目录中的所有模块时非常有用，例如，自动注册\r\nVue 组件或 Vuex 模块。\r\n（这里debug了好久，因为copilot一开始给的函数名就有错（globEager已弃用），还是不要轻信AI，去网上查一查即时信息）(同步函数\r\nimport.meta.glob('xxx', {eagger:true}))\r\nasync function initialModule() &#123;    const modulesImport = import.meta.glob(&#x27;./components/*.vue&#x27;);    const modules = &#123;&#125;;    for (const path in modulesImport) &#123;      const name = path.match(/\\.\\/components\\/(.*)\\.vue$/)[1];      console.log(&#x27;Import a module: &#x27;, name);      modules[name] = await modulesImport[path]();      // console.log(&#x27;module&#x27;, module);    &#125;    return modules;  &#125;\r\nObject.keys(), Array.map()\r\n前者返回所有键组成的数组\r\n后者可以应用于数组，并返回一个新的数组，其中包含对原始数组中的每个元素应用某个函数的结果。\r\n动态绑定class\r\nclass=\"['tab-button', &#123; active: currentTab === tab &#125;]\"\r\n是一个动态绑定的 class 属性，用于设置元素的 CSS 类名。\r\n在这个绑定中，['tab-button', &#123; active: currentTab === tab &#125;]\r\n是一个数组，数组的第一个元素是字符串\r\n'tab-button'，表示一个静态的 CSS 类名\r\n'tab-button'。数组的第二个元素是一个对象\r\n&#123; active: currentTab === tab &#125;，表示一个动态的 CSS\r\n类名。\r\n对象中的 active: currentTab === tab 表示当\r\ncurrentTab 和 tab 相等时，该类名\r\nactive 将被应用，否则不会应用。\r\n例如，如果 currentTab 和 tab 相等，那么\r\nactive\r\n类名将被应用于元素，使其具有相应的样式。如果它们不相等，则不会应用\r\nactive 类名。\r\n这样可以根据条件来动态地切换元素的样式，例如在实现选项卡时，可以通过切换\r\nactive 类名来标记当前活动的选项卡。\r\nfor (a, b) in arr\r\n是的，你理解得很对！在 v-for=\"(_, tab) in tabs\"\r\n中，_ 是一个占位符，表示当前遍历的元素的值，而\r\ntab 则表示当前元素的键或索引。\r\n&lt;component :is=\"view\" /&gt;\r\n动态渲染组件\r\n要渲染的实际组件由 is prop 决定。\r\n\r\n当 is 是字符串，它既可以是 HTML\r\n标签名也可以是组件的注册名。\r\n或者，is 也可以直接绑定到组件的定义。\r\n\r\n（如果不会注册的话还是直接绑定义(import)）\r\ntab标签功能展示\r\n如何打包\r\n搞了半天，发现简单问题chatgpt还是可以，网上都太高端了\r\n直接 pnpm run\r\nbuild，然后就在disk文件夹里。注意要把所有直接路径改为间接路径，好奇怪的东西（比如\r\n/assets/a.png -&gt; assets/a.png）。然后不能直接用浏览器打开html文件，有啥限制。\r\n引入txt文件\r\nimport proverb from '../assets/proverb.txt?raw';\r\n?raw 代表以字符串的形式引入\r\n引入tailwind\r\nhttps://tailwindcss.com/docs/guides/vite#vue /** @type &#123;import(&#x27;tailwindcss&#x27;).Config&#125; */export default &#123;  content: [    &quot;./index.html&quot;,    &quot;./src/**/*.&#123;html,js,ts,jsx,tsx,vue&#125;&quot; // 注意导入vue  ],  theme: &#123;    extend: &#123;&#125;,  &#125;,  plugins: [],&#125;\r\n","tags":["前端","Vue3"]},{"title":"登录&https 加密","url":"/2025/05/22/%E5%89%8D%E7%AB%AF/%E7%99%BB%E5%BD%95&https%20%E5%8A%A0%E5%AF%86/","content":"(常见登录鉴权方案)[https://zhuanlan.zhihu.com/p/271768645] ##\r\nhttps原理 证书验证和数据传输阶段 HTTPS\r\n在内容传输的加密上使用的是对称加密（快），非对称加密只作用在证书验证阶段。\r\n\r\nssl证书在cloudflare上买？ Next.js 实践总结 -\r\n登录授权验证最佳方案\r\nJWT（JSON Web\r\nToken）\r\n由三部分组成：头部（Header）、载荷（Payload）和签名（Signature）。\r\nHeader，Payload是JSON对象，要使用 Base64URL 算法转成字符串。Signature\r\n部分是对前两部分的签名，防止数据篡改。三部分字符串要用.\r\n隔开。\r\n生成 Signature\r\n需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用\r\nHeader 里面指定的签名算法（默认是 HMAC SHA256）。\r\n可以使用openssl来生成一对私钥和公钥。（我的电脑上要在\r\nC:{username} 里使用）\r\n用Node.js中的 jsonwebtoken 库：\r\n\r\nheader自动生成\r\ntoken = jwt.sign(payload, secret) 生成JWT\r\nconst decoded = jwt.verify(token, secret);\r\n验证和解码JWT，返回一个payload\r\n\r\n","tags":["前端","后端"]},{"title":"联创分享——Hexo原理浅析","url":"/2025/01/20/%E5%89%8D%E7%AB%AF/%E8%81%94%E5%88%9B%E5%88%86%E4%BA%AB%E2%80%94%E2%80%94Hexo%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/","content":"什么是Hexo\r\n快速、简洁且高效的博客框架 - Node.js\r\n所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。 - Hexo 支持\r\nGitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress\r\n的大多数插件。 - 只需一条指令即可部署到 GitHub Pages, Heroku\r\n或其他平台。 - 强大的 API\r\n带来无限的可能，与数种模板引擎（EJS，Pug，Nunjucks）和工具（Babel，PostCSS，Less/Sass）轻易集成\r\n总体文件夹结构\r\n.\r\n├── _config.yml\r\n├── db.json\r\n├── node_modules\r\n├── package.json\r\n├── public\r\n├── scaffolds\r\n├── source 所有文章文件放在这里\r\n└── themes 主题文件夹\r\n**_config.yml  站点的配置文件。\r\ndb.json   缓存文件\r\npublic  最终所见网页的所有内容\r\nscaffolds  \r\n模板文件夹。当新建一个文章时，会默认包含对应模板的内容。\r\nsource \r\n资源文件夹是存放用户资源的地方。所有的源文件都会被保存在_post文件夹中。除 posts\r\n文件夹之外，开头命名为 (下划线)的文件 /\r\n文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public\r\n文件夹，而其他文件会被拷贝过去。\r\nthemes**  存放主题文件，hexo会根据主题来生成静态页面。 ##\r\nhexo的模板引擎\r\n模板引擎的作用，就是将界面与数据分离。最简单的原理是将模板内容中指定的地方替换成数据，实现业务代码与逻辑代码分离。\r\nhexo默认的是使用ejs，同类型的东西还有很多，比如jade，swig。 ### EJS\r\nEJS是一种模板引擎，是用于生成包含动态数据的Web页面的工具，可以通过客户端JavaScript在客户端上生成HTML，但更常见的是由后端使用它来根据某个URL请求生成Web页面。\r\n &lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt; // 输出变量title的值 &lt;% if (isAdmin) &#123; %&gt; // 条件判断  &lt;p&gt;Welcome, admin!&lt;/p&gt; &lt;% &#125; else &#123; %&gt;  &lt;p&gt;Welcome, guest!&lt;/p&gt; &lt;% &#125; %&gt;&lt;ul&gt; &lt;% for (let i = 0; i &lt; items.length; i++) &#123; %&gt; // 循环  &lt;li&gt;&lt;%= items[i] %&gt;&lt;/li&gt; &lt;% &#125; %&gt;&lt;/ul&gt;\r\nJade\r\njade采用缩进语法格式。 - var users = [&#123;name: &#x27;foo&#x27;, role: &#x27;admin&#x27;&#125;, &#123;name: &#x27;bar&#x27;, role: &#x27;manager&#x27;&#125;, &#123;name: &#x27;baz&#x27;, role: &#x27;technician&#x27;&#125;]h2 Users// Neat! There&#x27;s another construct called `each`// Also there is `unless` which is equivalent to if (!expr)// Let&#x27;s use that and swap a bit of codeeach user, index in users    unless user.role === &#x27;admin&#x27;        p #&#123;user.name&#125; is not an &quot;admin&quot;    else        p #&#123;user.name&#125; is an &quot;admin&quot;// Let&#x27;s take a look at `case` statements nowh3 casecase users[2].name    when &#x27;admin&#x27;        p User is an admin    when &#x27;manager&#x27;        p User is a manager    when &#x27;technician&#x27;        p User is a technician    default        p User is a customer!\r\n基本命令\r\n$ hexo init &lt;folder&gt;$ hexo new [layout] &lt;title&gt;$ hexo generate #生成静态文件$ hexo server$ hexo deploy$ hexo clean\r\nhexo-cli 启动 hexo 命令进程和参数解析机制。每次我们输入\r\nhexo init 命令后，都会通过 node 调用 hexo-cli 中的 entry\r\n函数 (比如，可以把 hexo init 视为\r\nnode hexo-cli/entry.js init)， ## 部署流程\r\n\r\n每次执行hexo\r\ng命令时，hexo都会遍历主题文件中的source目录，这里的source主要包括css，fonts，js等文件，建立索引。\r\n根据索引会把主题文件生成到public文件中，此时public文件是一个由html，js，css等内容制作的博客，也就是网页的根目录。\r\n通过部署，hexo d 将 public 文件夹的内容以 git 方式 push 到 github\r\n的指定项目的指定分支，由 github\r\n进行显示。当然，也可以部署到自己的域名上。将 public 目录中的文件和目录推送至指定目录，并完全覆盖该分支下的已有内容。\r\n\r\n局部缓存优化\r\n如果主题太过于复杂，或是需要生成的文件量太过于庞大，可能会大幅降低性能，可以考虑局部缓存（Fragment\r\nCaching）\r\n功能。它储存局部内容，下次便能直接使用缓存内容，可以减少文件夹查询并使生成速度更快。\r\n它可用于页首、页脚、侧边栏等文件不常变动的位置，举例来说：\r\n&lt;%- fragment_cache(&#x27;header&#x27;, function()&#123;    return &#x27;&lt;header&gt;&lt;/header&gt;&#x27;;  &#125;); -%&gt; ## hexo-server hexo-server 是 Hexo\r\n的一个插件，它的作用是启动一个本地服务器，可以实时预览博客的修改效果。它主要是通过监听文件变化和重新渲染静态页面来实现实时预览博客的修改效果。\r\n其监听文件变化的实现方式如下：\r\n在 Hexo-server 启动时，它会创建一个 chokidar 的实例，监听\r\nHexo\r\n博客目录下的文件变化。当文件发生变化时，chokidar 会触发相应的事件，例如\r\nadd、change 和 unlink\r\n等。Hexo-server 在接收到这些事件后，会重新渲染对应的页面，并将结果发送给客户端。\r\n下面是 Hexo-server 使用 chokidar 监听文件的代码片段：\r\nconst chokidar = require(&#x27;chokidar&#x27;);    // Watch files  const watcher = chokidar.watch(sourceDir, &#123;    ignored: config.ignore,    persistent: true,  &#125;);    // Listen for file events  watcher    .on(&#x27;add&#x27;, file =&gt; &#123; /* handle add event */ &#125;)    .on(&#x27;change&#x27;, file =&gt; &#123; /* handle change event */ &#125;)    .on(&#x27;unlink&#x27;, file =&gt; &#123; /* handle unlink event */ &#125;);\r\n上述代码中，chokidar.watch() 方法用于创建一个 chokidar 的实例，该实例会监听 sourceDir 目录下的文件变化。配置项 ignored 用于指定忽略的文件，persistent 为 true 表示持续监听文件变化。\r\n接下来，使用 on() 方法监听 add、change 和 unlink 事件，并在相应的回调函数中处理文件变化事件。例如，在\r\nadd\r\n事件中，可以调用 Hexo 的 generate() 方法重新生成对应的页面。\r\n总的来说，Hexo-server 通过 chokidar 实现了监听文件变化并重新渲染页面的功能，提供了实时预览和自动刷新等便利特性。\r\n\r\n以下是凑时间的。 # Educational Codeforces Round\r\n163 (Rated for Div. 2)D. Tandem Repeats? [[优化处理]] ## 题意\r\n有一行由小写字母和？组成的字符串，？可以代表任何小写字母。求重复子串的最大长度，重复子串指满足\r\n\\(s[l,l+len-1]=s[l+len,l+len*2-1]\\)\r\n的连续子串。 \\(n&lt;=5e3\\) ## 题解\r\n就是要找到处理的相同量，这里是判断 \\(s[i]==s[i+len]\\)\r\n，当len固定时左端点l和l+1只有端点需要处理。在每次记一个cnt，记录满足相等的个数。因为len固定时判断的永远时s[i]和s[i+len]，所以\r\n\\(？\\) 可以直接贪心处理。\r\n","tags":["前端"]},{"title":"面试速通","url":"/2025/05/24/%E5%89%8D%E7%AB%AF/%E9%9D%A2%E8%AF%95%E9%80%9F%E9%80%9A/","content":"面试问题集合\r\nhttps://fe-interview.pangcy.cn/docs/engineering/vite/vite-06/ ## Todo -\r\n函数装饰器 ## function和箭头函数区别\r\n箭头函数定义时根据上下文确定this，适用于回调函数\r\nfunction适用于对象的方法\r\n防抖节流\r\n防抖在连续的事件，只需触发一次回调的场景有：搜索框搜索输入。只需用户最后一次输入完，再发送请求，事件之后延迟n\r\nms，看看还有没有事件 节流：在间隔一段时间执行一次回调的场景\r\n函数压缩\r\n问题： 为什么compose2不行 let compose = (...fns) =&gt; &#123;  let res = (...args) =&gt; args;  for (let fn of fns) &#123;    res = (function(fn, res) &#123;      return (...args) =&gt; &#123;        return fn(res(...args));      &#125;;    &#125;)(fn, res);  &#125;  return res;&#125;let compose2 = (...fns) =&gt; &#123;  let res = (...args) =&gt; args;  for (let fn of fns) &#123;    res = (...args) =&gt; &#123;        return fn(res(...args));    &#125;;  &#125;  return res;&#125;/*let compose2 = (...fns) =&gt; &#123;  let res = (...args) =&gt; args;  for (let fn of fns) &#123;    let fnn = fn, ress = res;    res = (...args) =&gt; &#123;        return fnn(ress(...args));    &#125;;  &#125;  return res;&#125;*/let a = (str) =&gt; str + &#x27;a&#x27;;let b = (str) =&gt; str + &#x27;b&#x27;;let c = (str) =&gt; str + &#x27;c&#x27;;let d = (str) =&gt; str + &#x27;d&#x27;;let e = compose2(a, b, c, d);console.log(e);console.log(e(&quot;begin&quot;));\r\njs number范围\r\n在 JavaScript 中，数字（Number）类型是基于 IEEE 754\r\n标准的双精度 64 位浮点数。这意味着 JavaScript\r\n中的数字可以表示非常大的范围，但有一个最大安全整数值。\r\n跨域解决办法\r\nCORS\r\n浏览器会阻止这种请求, 当浏览器检测到跨域请求时，会先发送一个\r\nOPTIONS 请求（预检请求）到目标服务器,\r\n服务器需要在响应头中返回 Access-Control-Allow-Origin 等\r\nCORS 相关头信息，以告知浏览器是否允许该请求。 ### jsonp\r\njsonp的原理就是通过&lt;script&gt;\r\n标签绕过浏览器的同源策略。服务器返回的数据被包装在一个回调函数中（例如\r\ncallback({\"data\": \"value\"})），客户端通过定义好的回调函数处理数据。\r\n容易受到 XSS（跨站脚本攻击）\r\nnginx\r\n\r\n增加cors相关\r\n进行反向代理（把 http://front_server/api 转到\r\nhttp://backend_server）\r\n\r\n正向代理：代理客户端，向服务器发送请求，隐藏客户端身份（如\r\nVPN）。\r\n反向代理：代理后端服务器，接收客户端请求并转发，隐藏后端服务器。\r\n\r\n\r\n部署\r\n先来说下前端项目的部署，一般来说有以下几个步骤：项目打包，上传到服务器，域名解析，SSL\r\n证书，申请Nginx ，配置CDN 加速。\r\nvercel自动化部署：如果是自己做一些小项目，再也不用每次修改代码之后还要打包上传到服务器了，只需要把代码提交到仓库，Vercel\r\n会自动触发部署，部署完成之后再通知你，这体验真的是无比丝滑。\r\nhttp缓存\r\n在 HTTP\r\nCaching 标准中，有两种不同类型的缓存：私有缓存（存在客户端）和共享缓存（共享缓存位于客户端和服务器之间）。\r\n\r\n响应age Cache-Control: max-age=604800\r\n过时的缓存不会立即被丢弃。HTTP\r\n有一种机制，可以通过询问源服务器这个缓存是否真的过期。这称为验证，有时也称为重新验证。\r\nIf-Modified-Since: 最近修改日期（服务器上次响应的 Last-Modified头部）\r\n文档没被修改过，条件就为假，服务端会返回一个 304 NotModified\r\n响应报文\r\nETag: 版本标识符\r\n重写，修改不重要，or 在毫秒级间隙发生变化（if modified\r\nsince不够用）\r\n网络攻击 XSS and CSRF\r\nXSS: 注入脚本，让受害者浏览器执行，来窃取cookie - 非持久型\r\nXSS（反射型 XSS）诱骗点击url - 持久型 XSS 漏洞，一般存在于 Form\r\n表单提交等交互功能，如文章留言，提交文本信息等，黑客利用的 XSS\r\n漏洞，将内容经正常功能提交进入数据库持久保存\r\nCSRF：诱导受害者发送伪造的请求到目标网站，利用受害者的身份（cookie）执行未经授权的操作。（目标网站的服务器也被篡改）\r\n解决办法： - xxs 可以设置csp，让代码不能执行 - xxs 可以转义字符 -\r\nCSRF 攻击依赖于伪造用户身份发送请求，但攻击者无法获取受害者的 CSRF\r\nToken（因为它存储在会话中或受同源策略保护）。 -\r\ncookie标记samesite，跨域请求不发送cookie - 敏感信息使用 httponly cookie\r\n（xss） - Cookie\r\n是存储在用户浏览器端的小段数据，用于跟踪用户会话等信息。而 HttpOnly 是\r\nCookie 的一个属性。 - 当设置为 HttpOnly 时，该 Cookie 只能通过 HTTP 或\r\nHTTPS 协议进行访问，不能被客户端脚本（如\r\nJavaScript）访问。这有助于防止一些跨站脚本攻击（XSS）。因为如果 Cookie\r\n被恶意脚本访问到，攻击者可能会窃取用户的会话信息等敏感数据。 -\r\n不要设置Access-Control-Allow-Origin=*\r\n事件委托\r\ndom元素的事件自动冒泡\r\n动态生成的元素（如列表）；减少内存占用和提高性能；统一处理相似元素的事件\r\n浅拷贝深拷贝分别怎么实现\r\n浅拷贝用展开运算符（...） 深拷贝用structuredClone()\r\nJSON.stringify实现深拷贝有什么问题：会忽略函数，date，error等对象会变成字符串，对象无法循环引用\r\nCommonJS 和 ES6 模块系统区别\r\nes6 异步加载，静态分析，也支持动态导入，导出值实时绑定（响应式）\r\nts class写法\r\nclass Person { name: string; age: number;\r\nconstructor(name: string, age: number) { this.name = name; this.age =\r\nage; }\r\nsayHello(): void {\r\nconsole.log(Hello, my name is $&#123;this.name&#125; and I am $&#123;this.age&#125; years old.);\r\n} }\r\n// 创建实例 const person = new Person('Alice', 25);\r\nperson.sayHello(); // 输出: Hello, my name is Alice and I am 25 years\r\nold.\r\nworker\r\nnew Worker('worker.js') 主程序/worker worker/self.postmessage\r\nworker/self.onmessage/onerror AddEventListener 和promise一起\r\nommessage-&gt;resolve onerror-&gt;reject\r\n前面说过，主线程与 Worker\r\n之间的通信内容，可以是文本，也可以是对象。需要注意的是，这种通信是拷贝关系，即是传值而不是传址，Worker\r\n对通信内容的修改，不会影响到主线程。事实上，浏览器内部的运行机制是，先将通信内容串行化，然后把串行化后的字符串发给\r\nWorker，后者再将它还原。“串行化”是指把一个对象或者数据结构转换成一个字节序列的过程，这样做的目的是为了方便存储或者传输。\r\nslice\r\npython [a:b] = js .slice(a, b)\r\n内存泄漏\r\nhttps://elvinn.wiki/nodejs/memory.html 1. 全局变量 2. 闭包引用 3.\r\n事件绑定（dom移除时没有移除eventlistener，这是node？？ 4. 缓存爆炸\r\nheapdump\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n特性\r\ncomputed\r\nwatch\r\n\r\n\r\n\r\n\r\n缓存机制\r\n有缓存，只有依赖项变化时才会重新计算\r\n无缓存，每次依赖项变化都会执行回调\r\n\r\n\r\n更新机制\r\n同步更新\r\n异步更新\r\n\r\n\r\n用途\r\n用于基于现有数据派生新数据\r\n用于监听数据变化并执行复杂逻辑\r\n\r\n\r\n依赖响应式\r\n自动追踪依赖项\r\n需要手动指定依赖项\r\n\r\n\r\n\r\nvar 声明提前\r\n这里声明了变量，js解释器“前瞻性”查找所有变量定义，把它们“提升”到函数顶部\r\n首屏优化\r\n懒加载\r\n有时候我们想把某个路由下的所有组件都打包在同个异步块 (chunk)\r\n中。在Vite中，你可以在rollupOptions下定义分块：\r\n// 将 import UserDetails from &#x27;./views/UserDetails.vue&#x27; // 替换成 const UserDetails = () =&gt; import(&#x27;./views/UserDetails.vue&#x27;)// vite.config.jsexport default defineConfig(&#123;  build: &#123;    rollupOptions: &#123;      // https://rollupjs.org/guide/en/#outputmanualchunks      output: &#123;        manualChunks: &#123;          &#x27;group-user&#x27;: [            &#x27;./src/UserDetails&#x27;,            &#x27;./src/UserDashboard&#x27;,            &#x27;./src/UserProfileEdit&#x27;,          ],        &#125;,      &#125;,    &#125;,  &#125;,&#125;)\r\ncss和js阻塞渲染的问题\r\nhttps://blog.csdn.net/qq_44318215/article/details/125392575\r\n","tags":["前端"]},{"title":"DB","url":"/2025/01/20/%E5%90%8E%E7%AB%AF/DB/","content":"启动mysql\r\nmysqld --standalone ## 主键\r\n用 自增id 或 GUID\r\n全局唯一GUID类型：也称UUID，使用一种全局唯一的字符串作为主键，类似8f55d96b-8acc-4636-8cb8-76bf8abc2f57。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的，大部分编程语言都内置了GUID算法，可以自己预算出主键。\r\nalter table last_view_ats add primary key (value);\r\n多对一: 外键\r\n在students表中，通过class_id的字段，可以把数据与另一张表关联起来，这种列称为外键。\r\n多对多: 中间表\r\n相当于存储所有的边\r\n索引\r\n通过对数据库表创建索引，可以提高查询速度；\r\n命令\r\n进入db\r\nUSE db;\r\n查看一个表的所有信息\r\nselect * from table;\r\nCREATE TABLE\r\nDROP TABLE IF EXISTS `user_accounts`;CREATE TABLE `user_accounts` (  `id`             int(100) unsigned NOT NULL AUTO_INCREMENT primary key,  `password`       varchar(32)       NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;用户密码&#x27;,  `reset_password` tinyint(32)       NOT NULL DEFAULT 0 COMMENT &#x27;用户类型：0－不需要重置密码；1-需要重置密码&#x27;,  `mobile`         varchar(20)       NOT NULL DEFAULT &#x27;&#x27; COMMENT &#x27;手机&#x27;,  `create_at`      timestamp(6)      NOT NULL DEFAULT CURRENT_TIMESTAMP(6),  `update_at`      timestamp(6)      NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6),  -- 创建唯一索引，不允许重复  UNIQUE INDEX idx_user_mobile(`mobile`))\r\n条件\r\nSELECT * FROM &lt;表名&gt; WHERE &lt;条件表达式&gt;\r\nAND OR NOT\r\n不等于 &lt;&gt;\r\n使用LIKE判断相似 : `key LIKE %bc%' (\r\n'%表示任意字符，例如'ab%'将匹配'ab'，'abc'，'abcd' )\r\nSELECT 列1, 列2, 列3 FROM ...\r\n排序\r\nSELECT id, name, gender, score FROM students ORDER BY score;\r\nSELECT id, name, gender, score FROM students ORDER BY score DESC;\r\nSELECT id, name, gender, score FROM students ORDER BY score DESC,\r\ngender;\r\n先按score列倒序，如果有相同分数的，再按gender列排序\r\n计数\r\n把 * 变成 count(*)\r\nSUM AVG MAX MIN\r\n分组\r\nCROUP BY\r\n修改列信息\r\nALTER TABLE name ADD PRIMARY KEY (columnName);\r\nALTER TABLE name DROP COLUMN aaa;\r\n删除\r\nDELETE FROM tablename WHERE ...\r\nGorm 连接\r\ndsn := &quot;root:@tcp(127.0.0.1:3306)/dbname?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)if err != nil &#123;\tlog.Fatal(&quot;Failed to connect to database&quot;)&#125;\r\nMySQL 认证方式问题： 就是mysql可能只能用 unix socket\r\n而非 tcp 登录\r\n\r\nMySQL 默认可能使用 auth_socket 或 unix_socket 插件认证，root\r\n用户可能被配置为仅通过 Unix 套接字（非 TCP）登录，而非密码认证。 使用 -h\r\n127.0.0.1 尝试通过 TCP 连接，但 MySQL 认为用户是\r\n'root'@'localhost'，且密码或权限未正确配置。 检查 root\r\n用户的认证方式：SELECT user, host, plugin FROM mysql.user WHERE user = 'root';\r\n\r\n把 @tcp(127.0.0.1:3306)换成\r\n@unix(/var/run/mysqld/mysqld.sock)\r\n","tags":["后端","数据库"]},{"title":"分布式——MapReduce，GFS","url":"/2025/01/20/%E5%90%8E%E7%AB%AF/%E5%88%86%E5%B8%83%E5%BC%8F%E2%80%94%E2%80%94MapReduce%EF%BC%8CGFS/","content":"MapReduce\r\n概念\r\n专门为并行处理大规模数据量而设计的简单模型。 自定义 Map 和 Reduce\r\n函数，进行分布式运算和基于 key 的检索 \r\n\r\nmap(key: string, value: string): (key: string, value:string)\r\nreduce(key: string, values: []string): any ### 执行流程\r\n\r\nmaster 分配 map 任务到 worker。（master\r\n负责分配任务和传输数据地址）\r\nworker 挨个执行 map 函数，将中间数据分为 nReduce\r\n组存储。分的方式是按照 hash(key) mod R 的方式。nReduce 即为 reduce\r\n任务的数量。执行完后再在 master 处领取新的 map 任务。\r\n所有 map 任务完成后，master 开始分配 reduce 任务。\r\nworker 收集中间数据，按 key 进行排序，对每个 key 找到所有对应的\r\nvalue，然后挨个执行 reduce 函数。存储输出数据。\r\n\r\n用处\r\n词频统计 倒排索引。每个文档里有什么词语 -&gt; 每个词语在哪些文档里\r\n分布式排序。\r\nGFS\r\n前提\r\n\r\n需要能够运行在经常故障的物理机环境上。使得能采用相对便宜的服务器硬件。\r\n大文件居多。几个GB这样的级别\r\n大多数写是append写，即在文件末尾追加。（应该没有顺序要求）\r\n\r\n概念\r\nGFS由一个Master节点、ChunkServer和提供给用户的client组成。\r\n所有的数据，被切分成固定大小的”chunk”，写入ChunkServer所在的物理机的磁盘上。\r\nmaster节点管理好所有的元信息，包括表示文件系统目录结构的namespace、文件所属的chunk所在位置等\r\n用户需要读写文件的时候，通过GFS的client，首先从master查到文件所在的chunk相关信息，而后直接与对应的chunkserver通讯。\r\n\r\nmaster通过检查点+重放（replay）操作日志来恢复其文件系统的状态。\r\nmaster在启动时从chunkserver获取chunk信息，存在内存中。随后master控制着所有chunk的分配并通过周期性的心跳消息监控chunkserver状态。\r\n\r\n一致性\r\n弱一致性：从不同chunk副本（一个文件大概有3份，保证不会被损坏）中获得的数据可能会有一点差距。chunkserver\r\n在返回数据之前检查 校验和\r\n，如果校验和不匹配，让client请求其他副本，并会新建一个副本并删除损坏的。\r\n非确定：并发写（不是 append）导致结果不确定。 \r\nPrimary 和租约\r\n\r\nmaster 找到 Primary 或 选择 Primary 并给定租约\r\nclient\r\n把变更传给所有副本的chunkserver，server缓存变更（变更：write，append……）\r\n所有副本server都确认收到了数据后，primary为变更选取顺序，所有副本应用变更。\r\n\r\n租约 -&gt; 防止部分网络问题导致的脑裂\r\n","tags":["后端"]},{"title":"Bilibili清理计划","url":"/2025/01/20/%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE/Bilibili%E6%B8%85%E7%90%86%E8%AE%A1%E5%88%92/","content":"Bilibili清理计划\r\n数据\r\n\r\nhttps://socialsisteryi.github.io/bilibili-API-collect/\r\n爬取部分关注up主或合集\r\n爬取图片\r\n人工增删改查关注up主或合集\r\n\r\n编辑页面\r\n存储\r\n\r\n合集列表\r\n已看的bvid\r\n\r\n\r\n\r\n页面\r\n\r\n主页面（推荐页）\r\n导航页\r\n编辑页面\r\n\r\n按时间（没看过的，不能太晚也不能太早），弹幕数、评论数（不能太少了）进行限制\r\n随机推送\r\n网页嵌入视频\r\nhttps://chiperman.github.io/zai-wang-ye-zhong-qian-ru-bi-li-bi-li-shi-pin/\r\n设计\r\nhttps://js.design/community?category=detail&amp;type=resource&amp;id=6566fdcf0b61f2d1f3d184f4\r\n","tags":["前端","学习项目"]},{"title":"大二上总结","url":"/2025/02/21/%E6%80%BB%E7%BB%93/%E5%A4%A7%E4%BA%8C%E4%B8%8A%E6%80%BB%E7%BB%93/","content":"新鲜感过去，剩下的是一些疲惫和茫然，这就是这学期的关键词吧。\r\n这学期写了6.824但是没写完，打了种子杯取得了不错的名次，看了好几本书感觉还挺有意思，水了无人机比赛虽然什么都没干但是还是拿到了奖，还出了两趟远门虽然没有玩到……\r\n竟然看了八本书，也算是很惊讶的了，也说明确实没什么事情干，看完后最多的想法还是想多看看这个世界。\r\n虽然节奏变慢了但是也自己学会了探索很多地方，也算是学会了生活吧。感觉没有那么多新鲜感支持着我兴奋而有精力，比如每天骑自行车从横跨华科。但是还是很好得完成了一整个学期的学业，甚至加权还挺高。还是希望这学期能少一些纠结和焦虑，多一些行动吧。还有少刷视频，多做一些低刺激的事情。\r\n这学期开始做科研了，还可能要去实习，希望能多增加点与人沟通的勇气和能力，也创造出一点厉害的有意思的东西。还有能自学专业课，提高一点效率吧。\r\n","tags":["总结"]},{"title":"新，兴奋与焦虑 —— 大一上总结","url":"/2024/01/21/%E6%80%BB%E7%BB%93/%E6%96%B0%EF%BC%8C%E5%85%B4%E5%A5%8B%E4%B8%8E%E7%84%A6%E8%99%91%E2%80%94%E2%80%94%E5%A4%A7%E4%B8%80%E4%B8%8A%E6%9C%9F%E6%80%BB%E7%BB%93/","content":"来到大学的第一个学期，感觉挺好的。有一种自己掌握生活的感觉，虽然有的时候也因此而焦虑。但毕竟能干自己爱干的事情了。\r\n\r\n这学期的感觉总结下来就是兴奋和焦虑。兴奋是因为接触到了很多很多新鲜事情，有生活上的，专业学习上的，学生组织上的……这份新鲜感也让我乐于尝试很多事情。但就像拉封丹说的“耐心与持久胜于激烈的狂热”，我希望我能不仅仅乐于“尝试”很多事情，还需要坚持下来，去乐于深入学习这些事情。焦虑一方面则是因为大学的一些事让我浪费了很多时间在做无意义的事情上。但这也是无可厚非的，毕竟一个复杂庞大的社会的运行需要这些东西，我们已经享受了很多自由了。（所以希望之后的自己放平心态）另一方面，则是关于个人成长和未来规划。主要包括对未来方向的迷茫，对努力方向和意义的迷茫以及对无法把握的事情的无力感，当然还有被卷的焦虑。这些焦虑肯定不能完全解决，但还是希望有时间能多读点文章和书。总的来说感觉这学期确实挺充实的，不仅是事情上，也是精神上。\r\n下面来看看我都干了什么。\r\n数学学习上，我感觉这学期还挺轻松的。可能是因为有竞赛基础，所以上课大致还能听懂。但也不是那种没有输入的轻松，一直在费劲去理解一些东西，思考一些不会做的题。挺有收获的。但是看得出来数学确实难，我的兴趣也不在那里，所以我出来了。（但有些人确实挺费力的，希望我的前同学们能有一个正常的四年吧）数学的学习也让我学会去“沉淀”，去沉浸下来啃一些难骨头，希望在未来坚持。\r\n计算机学习上，我感觉确实学到了很多，但也看见了计算机体系之庞大。这学期在联创学习新人任务，在学长那里学到了很多关于前端的。（新人任务真是个好东西，人确实需要ddl和拷打）然后又看了无人机的内容，也大致知道怎么弄了。（我竟然在英语考试前一天看英语论文来复习英语，真的佩服自己的创意）然后自己也学了一些其他的东西，搞到了很多国外的优质网站，确实优质。（但网站在精不在多，还是不要再到处搜罗新的网站和工具为好，拿更多时间在学习上）\r\n生活上，我也学习到了很多东西，有了巨多的思考，第二段就是其中一部分。除此之外，我知道了大学（也是未来）是随机性巨多的东西（比如我的高代（大哭）），所以我们更要抛弃线性思维，提高自己的总体竞争力，也要找到自己的信仰，不被外界所操控。其他的暂时忘了。还有输入和输出的思想。\r\n看起来都是输入呢。但其实也有输出。比如这篇文章（doge），还有自己做到小网站，还有接下来的回母校的演讲（希望不要太紧张呢）。\r\n对于未来，我希望以后能多加入一些人际交往的东西。（毕竟这方面真的很差呢）然后就是多探索探索每个领域，找到自己的方向。加油！坚持下去！\r\n没时间写了，爬虫的书还一点都没翻过呢。\r\n","tags":["生活","总结"]},{"title":"杂记","url":"/2025/03/19/%E6%80%BB%E7%BB%93/%E6%9D%82%E8%AE%B0/","content":"发现有的东西如果不记下来的话还不如回去睡觉，遂记。\r\n不知道为什么去听了游戏公司的宣讲会有感\r\n感觉还是一个阶段做好一个阶段的事情吧。反正到那里都是写代码，感觉也没什么区别。我现在的想法就是学一些自己感兴趣的东西，上感兴趣的网课，做感兴趣的事情，慢慢接入社会，和感兴趣的人聊天。想做的事情太多了，我没有时间去焦虑。我发现研究生还有工作这些阶段不仅仅是完成一些可量化的成果，更重要的是自我综合能力的提升。比如背英语论文，全英文组会，客户端学长有三分之一的时间都在写服务端，所以我觉得无论去到哪个环境，是否有成长，是否高强度还是很大一部分取决于自己的。或者说方向并不能限制你的成功。但需要补充的是，氛围还是有一些作用的。所以不要再纠结了，先踏进去再说，你总会发现自己感兴趣的事的。\r\n对于当前的选择，我的想法是走着看，等到没得选了再说。\r\n但是感觉公司真的感觉比学校更有活力一些，想去试一试（指实习）。游戏真的好有意思捏，图形学方面（细节的渲染），还有动作类复杂的数据传输，支持大并发数据的服务器……\r\n","tags":["总结","想法"]},{"title":"ROS快速学习","url":"/2024/02/23/%E6%97%A0%E4%BA%BA%E6%9C%BA/ROS%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0/","content":"Node节点：完成一个功能的一个模块\r\nPackage包：多个相关节点组成。节点不能独立于包存在\r\n头文件 #include &lt;ros/ros.h&gt;\r\n初始化 ros::init(argc, argv, \"px4_pos_controller\");\r\nNodeHandle对象 ros::NodeHandle nh(\"~\");\r\n相当于一个管家，与ros通讯的关键\r\n循环及控制循环频率\r\nwhile(ros::ok())&#123;&#125; 才能响应外部信息（ctrl+c）\r\nros::Rate loop_rate(10); // 括号内为每秒执行的次数\r\nwhile(ros::ok())&#123;\t...    loop_rate.sleep();&#125;\r\nros节点通讯方式 Topic+Message\r\n定义\r\n\r\n创建一个话题Topic，在这个话题中进行持续通讯\r\n发布消息的是话题的发布者Publisher，接收消息的是话题的订阅者Subscriber\r\n通常按照一定频率持续不断发出，以保证消息的实时性\r\n就跟聊天群一样，一个话题可以同时有多个发布者和订阅者\r\n\r\n传感器消息的话题一般只有一个发布者\r\n指令话题可能有多个发布者\r\n\r\n\r\n消息类型\r\n可以嵌套，相当于class\r\n用std_msgs包获得一些标准消息类型\r\n创建发布者及发布消息\r\nros::Publisher pub = nh.advertise&lt;std_msgs::String&gt;(\"test\", 10);\r\n泛型函数，&lt;&gt;中定义参数（消息）的类型，第一个参数是话题名称，第二个参数是消息缓存长度（缓存里可以容纳的消息个数），之后用pub来往这个话题发布消息\r\nwhile (ros::ok()) &#123;    std_msgs::String msg;    msg.data = &quot;hello world&quot;;    pub.publish(msg);&#125;\r\nrostopic查看话题信息\r\nrostopic list 列出活跃话题名称\r\nrostopic echo /话题名称 列出话题下的消息\r\n创建接收者及接收消息\r\nros::Subscriber pub = nh.subscribe&lt;std_msgs::String&gt;(\"test\", 10, func);\r\nfunc为回调函数，是接收到消息后需要做的事情\r\nvoid func(std_msgs::Sting msg)&#123;&#125;\r\n在订阅之后保持在运行状态 :\r\nwhile (ros::ok()) &#123;\tros::spinOnce();// 查看是否有消息包需要接收&#125;\r\n通讯网络的图形化显示\r\nrqt_graph\r\n","tags":["无人机","嵌入式"]},{"title":"无人机理论知识（元启发式）","url":"/2024/02/23/%E6%97%A0%E4%BA%BA%E6%9C%BA/%E6%97%A0%E4%BA%BA%E6%9C%BA%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86%EF%BC%88%E5%85%83%E5%90%AF%E5%8F%91%E5%BC%8F%EF%BC%89/","content":"MVO（Multi-Verse Optimization）\r\n\r\n多宇宙 =&gt; 不同的参数组合和解决方案\r\n评估每个宇宙的适应度函数（更优or更劣）\r\nMVO通过交换宇宙之间的信息来改进解决方案。更优秀的宇宙将共享其参数值和解决方案，以便其他宇宙可以受益并在下一代中生成更好的解。\r\n多次迭代从而达到最优解\r\n适用于多重参数问题但是时间复杂度较高\r\n\r\nBresenham算法\r\n\r\n一种在光栅显示器或网格上绘制直线的高效方法，可以在基于像素的显示器上高效地绘制直线\r\n一步一步移动对于沿直线的每个后续像素，更新决策参数（初始设置为2\r\n* Δy - Δx）并进行水平或对角线移动。\r\n要避免过早收敛和次优结果\r\n\r\n","tags":["无人机"]},{"title":"无人机笔记","url":"/2024/02/23/%E6%97%A0%E4%BA%BA%E6%9C%BA/%E6%97%A0%E4%BA%BA%E6%9C%BA%E7%AC%94%E8%AE%B0/","content":"函数\r\n\r\n\r\nvoid rotation_yaw(float yaw_angle, float input[2], float output[2]);\r\n坐标系旋转函数- 机体系到enu系\r\ninput是机体系,output是惯性系，yaw_angle是当前偏航角\r\nvoid collision_avoidance(float target_x, float target_y)\r\n避障的同时到(target_x, target_y)\r\n\r\n雷达\r\n\r\nLaser.ranges[i] ：range_min到range_max的距离\r\ndistance_c，angle_c：最小距离和所对角\r\n\r\n位置\r\n\r\npos_drone.pose.position.x或y\r\nEuler_fcu：欧拉角（Euler\r\nangles）是一种用于描述物体在三维空间中旋转的方法。它由三个角\r\n度组成，通常表示为 α、β 和\r\nγ，也被称为滚转（roll）、俯仰（pitch）和偏航（yaw）。\r\n\r\n滚转角（Roll）表示物体绕其自身坐标系的 X 轴旋转的角度。\r\n俯仰角（Pitch）表示物体绕其自身坐标系的 Y 轴旋转的角度。\r\n\r\n偏航角（Yaw）表示物体绕其自身坐标系的 Z 轴旋转的角度。\r\n\r\n\r\n\r\n命令（出口）\r\ncommand_pub ### 悬停\r\nfor (int i = 0; i &lt; 5; i++)&#123;    Command_now.command = Hold;    Command_now.sub_mode = 0x00;    command_pub.publish(Command_now);    rate.sleep();&#125;\r\n移动\r\nCommand_now.command = Move_ENU; // 机体系下移动Command_now.comid = comid;comid++;Command_now.sub_mode = 2; // xy 速度控制模式 z 位置控制模式Command_now.vel_sp[0] = vel_sp_ENU[0]; // collision_avoidance()里设置的Command_now.vel_sp[1] = vel_sp_ENU[1]; // ENU frameCommand_now.pos_sp[2] = fly_height;Command_now.yaw_sp = 0;command_pub.publish(Command_now);\r\n视觉\r\n\r\n来使 darknet_boxes 存储各个图片的信息，用\r\ndetect_num 存储相机共检测到的图片数目\r\ndarknet_boxes.bounding_boxes[i]的类型是\r\ndarknet_ros_msgs 中的 BoundingBox\r\n消息类型中，通常包含以下字段：\r\nheader：消息头，包含了时间戳和坐标系信息。\r\nClass：检测到的目标的类别或标签。\r\nxmin：边界框的左上角 x 坐标。\r\nymin：边界框的左上角 y 坐标。\r\nxmax：边界框的右下角 x 坐标。\r\nymax：边界框的右下角 y 坐标。\r\nprobability：目标的检测置信度或概率。\r\n\r\ndarknet_ros_msgs::BoundingBox fire_box = darknet_boxes.bounding_boxes[i];if (fire_box.Class != &quot;person&quot;)    continue;float dx = Laser.ranges[0] * cos(Euler_fcu[2]);float dy = -dx * ((fire_box.xmin + fire_box.xmax) / 2 - cx) / fx;float fire_center_x = pos_drone.pose.position.x + dx;float fire_center_y = pos_drone.pose.position.y + dy;\r\n​\r\n路径规划算法\r\n参考 ### 构型空间\r\n机器人的所有状态（构型）的集合 比如 \\(\\{(无人机的x坐标,y坐标,所朝方向\\theta)\\}\\)\r\nPRM\r\n\r\n在图中随机采样一定数量（如50个）的无碰撞点。\r\n对每一个点，取其领域（相邻区域）内（例如直线距离在200以内）的所有点进行连线，对连线进行碰撞检测（如果连线与碰撞点有相交就删除连线），将结果存放在邻接矩阵中。\r\n### RRT\r\n在每次选择生长方向时，有一定的概率会向着目标点延伸，也有一定的概率会随机在地图内选择一个方向延伸一段距离\r\n假设我们采样了空间中随机一个点，接下来从现有的RRT树中选择离采样点最近的一个点，并向采样点延伸一段距离。假如在这段延伸中没有发生碰撞（碰撞检测），而且新点与现有的所有点的距离大于某个判断阈值（防止生长到RRT已经探索过的位置），则将这个新点也加入RRT树。\r\n假如本次延伸的新点与终点的距离小于这个阈值，我们就认为已经规划成功。\r\n\r\n这里利用统计学中回归分析生成新节点，将RRT算法探索未知空间的能力进一步增强以避免因启发估价因子导致的局部极小。其思想是探索以前到过的空间是无用的，而且容易陷入局部极小。引进回归分析(regression\r\nanalysis)是考察新节点与其他节点之间关系，利用回归函数约束，使得随机树不探索以前到过的空间，因此避免了局部极小。\r\n滚动RRT\r\n滚动窗口状态空间进行K次采样后，遍历随机树，根据启发估价思想寻找滚动窗口子目标 \\(X_{sub}\\)。 \\(X_{sub}\\) 是当前滚动窗口中的子树中估价函数最小的点。确定子目标后，机器人前进到子目标点，进行下一轮的滚动RRT规划。如此反复，直到到达目标点\r\nG。\r\n人工势场\r\n但是复杂的势场环境可能在目标点之外产生局部极小点导致机器人无法到达目标。遇到局部极小点后结合其他的方法使机器人离开局部极小点。沿墙行走法使机器人在遇到局部极小点后参照类似BUG算法的环绕行为绕过产生局部极小点的障碍物继续前进。这种方法可靠性高，不依赖环境的先验信息和障碍物形状。\r\n为了使机器人从局部极小点中逃离，在人工势场法的基础上引入应激行为，即增加绕行行为。当机器人遇到局部极小点时，忽略目标引力势的作用，沿着斥力势的等势面方向移动，直到机器人离开局部极小区域。\r\n\r\n根据传感器信息计算当前位置的引力和斥力；\r\n判断是否处于绕行行为，若是，执行3；若否，执行4；\r\n判断是否离开局部极小区域，若是，机器人沿着合力方向运动，结束绕行行为；若否，机器人沿着斥力场等势线运动，继续绕行行为；\r\n判断是否遇到局部极小点，若是，机器人沿着斥力场等势线运动，开始绕行行为；若否，机器人沿着合力方向运动；\r\n判断是否到达目标，若是，退出算法；若否，继续1；\r\n\r\n\\(\\left| f_{att}+\\sum_{j=1}^{n}{f_{rep,j}}\r\n\\right|&lt;\\varepsilon\\) \\(\\left| x-x_A\r\n\\right|&lt;\\alpha s_A\\)\r\n当条件1或者条件2出现时，就认为机器人遇到了局部极小点。条件1中 \\(\\varepsilon\\)\r\n是一个很小的正数，其含义是机器人受到的虚拟合力接近0。这是最直接局部极小点判断方法。条件2中 \\(\\alpha\\)\r\n为0,1之间某一正数， x_A 为机器人运动过程中某一状态， s_A 表示机器人从 x_A 到达当前位置 x 的总路程，条件2成立意味着机器人在运动很长路程后，位移很小。用来检测机器人在局部极小点附近发生的振动和圆周运动。\r\nBUG算法\r\nBUG算法是一种完全应激的机器人避障算法。其算法原理类似昆虫爬行的运动决策策略。在未遇到障碍物时，沿直线向目标运动；在遇到障碍物后，沿着障碍物边界绕行，并利用一定的判断准则离开障碍物继续直行。这种应激式的算法计算简便，不需要获知全局地图和障碍物形状，具备完备性。但是其生成的路径平滑性不够好，对机器人的各种微分约束适应性比较差。\r\n\r\n（沿着障碍物绕一圈）\r\n\r\nbug2 直到碰到直线\r\nTangentBUG算法\r\n\r\n雷达扫描 找到距离的间断点（角度）\r\n选择一个角度，用 从当前位置经过此角度上的交点到目标点的折线长度\r\n判断走哪个角度\r\n探索距离不再减小时，就停止向目标运动行为，切换到环绕边界行为\r\n如下图所示，当机器人探索到障碍物上的 M 点后，探索距离就不再减小，即 � 点是机器人探索距离在障碍物边界上的局部极小点。机器人开始沿着障碍物边界进行环绕，图中虚线路径就是机器人环绕障碍物时所走的路径。当机器人探测到与目标距离相比 � 点更近的点时，重新开始接近目标的运动。\r\n\r\n\r\n\r\n\r\n卡尔曼滤波\r\n\r\n高斯分布：卡尔曼滤波假设两个变量（位置和速度，在这个例子中）都是随机的，并且服从高斯分布。每个变量都有一个均值 μ，表示随机分布的中心（最可能的状态），以及方差\r\n\\(\\sigma^2\\)，表示不确定性。\r\n协方差矩阵\r\n\r\n![[Pasted image 20240302153643.png]]\r\n矩阵中的每个元素 \\(\\Sigma_{i,j}\\) 表示第 i 个和第 j\r\n个状态变量之间的相关度\r\n\r\n![[Pasted image 20240228133157.png|200]]\r\n![[Pasted image 20240228134002.png|200]]\r\n控制变量和控制矩阵 ![[Pasted image 20240228134327.png|200]]\r\n外部干扰 ![[Pasted image 20240228134545.png|200]]\r\n传感器检测 ![[Pasted image 20240228162415.png|400]] ![[Pasted image\r\n20240228162527.png|300]] 其中 \\(H_k\\)\r\n把预测数据转化为相对应的传感器数据 ![[Pasted image\r\n20240228163108.png]]\r\n总结与应用\r\n用于建图时定位\r\n\r\n杂记\r\n\r\nNED系（North-East-Down）ENU：East-North-Up\r\n\r\n","tags":["无人机"]},{"title":"路径规划计划","url":"/2024/03/02/%E6%97%A0%E4%BA%BA%E6%9C%BA/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E8%AE%A1%E5%88%92/","content":"planA 比赛前一天手动规划路径（快速提取绘画坐标程序）（多重路径？）\r\n手绘路径作为目标点 使用改进人工势场 or TangentBUG算法避障\r\nplanB slam + 改进人工势场 or TangentBUG算法避障\r\nplanC 雷达数据手动重合+TangentBUG算法\r\n","tags":["无人机"]},{"title":"hot100","url":"/2025/11/21/%E6%89%BE%E5%B7%A5%E4%BD%9C%E5%A5%BD%E9%9A%BE/hot100/","content":"hot 100 刷题记录\r\n167 两数之和\r\n双指针，一个从1单增，一个从n单减，贪心，假设现在答案只在[i,\r\nj]之中那么可以排除 i 或者 j\r\n","tags":["算法竞赛","八股","找工作好难"]},{"title":"转转转后端","url":"/2025/11/27/%E6%89%BE%E5%B7%A5%E4%BD%9C%E5%A5%BD%E9%9A%BE/%E8%BD%AC%E8%BD%AC%E8%BD%AC%E5%90%8E%E7%AB%AF/","content":"转转转后端！\r\n强制缓存和协商缓存\r\nhttps://xiaolincoding.com/network/2_http/http_interview.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98\r\n强制缓存由浏览器主导，在一定时间内（Cache-Control）不找后端\r\n协商缓存用 Last-Modified/If-Modified-Since, ETag/If-None-Match\r\n来（后端）判断是否修改过，如果没修改过返回304\r\nGo 静态服务 http.FileServer 使用\r\nLast-Modified（文件系统元数据），hash运算开销太大\r\n手写 ETag，把要发的data做md5 hash\r\nfunc GetData(c *gin.Context) &#123;    // 强制缓存    c.Header(&quot;Cache-Control&quot;, &quot;public, max-age=3600&quot;)        // 协商缓存 (手动实现)    data := getData()    etag := generateETag(data)        if match := c.GetHeader(&quot;If-None-Match&quot;); match == etag &#123;        c.Status(http.StatusNotModified)        return    &#125;        c.Header(&quot;ETag&quot;, etag)    c.JSON(http.StatusOK, data)&#125;\r\nHTTPS\r\n在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议\r\n","tags":["后端","八股","找工作好难"]},{"title":"二分图","url":"/2024/02/23/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E4%BA%8C%E5%88%86%E5%9B%BE/","content":"一个图是二分图 &lt;=&gt; 染色法存在矛盾 &lt;=&gt;\r\n图中不存在奇数环\r\n（通过染色法可以想到棋盘，树，DAG）\r\n匹配：“一夫一妻”\r\n最大匹配：一个二分图中边数最多的一组匹配\r\n增广路径：（对于一个匹配来说）始于非匹配点且终于非匹配点（除了起始的点）的由匹配边与非匹配边交错而成路径。增广路中边的数量是奇数，所以这两个匹配点一定是不同边。\r\n\r\n最大匹配&lt;=&gt;此匹配不存在增广路径\r\n匈牙利算法：\r\n遍历每一个男的，看他喜欢的女生的男朋友能不能再找一个，好让他们两个在一起\r\n用到了递归，就是看那个男朋友能不能再找一个的时候用到的算法是一样的（find）\r\nbool find(int x)&#123;    for (int i = h[x]; i != -1; i = ne[i])    &#123;        int j = e[i];if (!vis[j])        &#123;vis[j] = true;            if (match[j] == 0 || find(match[j]))            &#123;                match[j] = x;                return true;            &#125;        &#125;    &#125;        return false;&#125;int main() &#123;for (int i = 1; i &lt;= M; ++i) // 遍历二分图的一边    &#123;        memset(vis, 0, sizeof(vis)); //重置vis数组if (find(i)) cnt++;    &#125;    return 0;&#125;\r\n*下面的遍历是指main函数中的，只有M次\r\n其实本质上是每次遍历找一条增广路径\r\n（遍历过的男的不一定是匹配点，但男的匹配点一定被遍历过，因为只有被遍历的时候男的会变成匹配点）\r\n记得每次遍历的时候标记一下vis（因为这个点向外扩展的方式的唯一的）\r\n\r\n\r\n最小点覆盖：选出最少的点，使得每一条边的端点至少有一边被选\r\n二分图中 最小点覆盖 = 最大匹配数\r\n！\r\n最大独立集：选出最多的点，使得选出的任意两点之间没有边 =&gt;\r\n去掉最少的点，把所有的边破坏掉 =&gt; 最小点覆盖\r\n最大团：选出最多的点，使得选出的任意两点之间都有边（即补图的最大独立集）\r\n最小路径点覆盖：用最少的互不相交的路径将所有点覆盖\r\n\r\n针对有向无环图\r\n不是边，是几条路径\r\n不一定能找到可行解\r\n= 点数 - 拆点后的最大匹配数\r\n方法：拆点（拆成出点和入点 =&gt; 二分图） 不相交\r\n=&gt;（拆点后的）匹配\r\n\r\n最小路径重复点覆盖：\r\n\r\n传递闭包后图G‘做最小点覆盖\r\n原图G的每一个路径重复点覆盖 都对应\r\nG'中的一个路径点覆盖，且路径数目相同；G'中的一个路径点覆盖 都对应\r\n原图G的每一个路径重复点覆盖，且路径数目相同\r\n\r\n例：acwing379. 捉迷藏\r\n\r\n题目：一个有向无环图，问最多选多少个点，使得两两之间没有路径连接\r\n题解：即传递闭包只有的最大独立集\r\n\r\n\r\n","tags":["算法竞赛"]},{"title":"女生赛补题总结","url":"/2024/02/23/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E5%A5%B3%E7%94%9F%E8%B5%9B%E8%A1%A5%E9%A2%98%E6%80%BB%E7%BB%93/","content":"2023HNUPC A\r\n大意\r\n给 一 个 长 度 为 n的 ， 只 包 含 A、 B、 C三 种 字 符 的 字 符 串\r\nS。 问 S 中 包 含 多 少 个 三 元 组 (i,j,k)满 足 i&lt;j&lt;k并 且 \\(S_iS_jS_k=ABC\\) 或 \\(CBA\\) ， 且 每 一 个 字 符 最 多 使 用 一\r\n次 。\\((1\\leq n \\leq 3*10^5)\\)\r\n题解\r\n把所有的A和C交换位置，使得所有A都在C之前，然后只需要计算三元组ABC的个数即可。（转化法）\r\n证明正确性：\r\n设交换后的为T，交换前为S。\r\n尝试反过来想，我现在在T中选了很多ABC，现在要把其中的一些AC（不一定相邻）交换位置。那如果有两个\"ABC\"收到影响。一个变成了CBC，一个变成了ABA，假设CBC的B在ABA的B前面（反之同理），讨论A，C对于两个B的相对位置（其实只有4种情况）。\r\n启发\r\n这种很自由的题目，要多假设并用”反之同理“。自由的题目可转化成不自由的题目，如”ABC“”CBA“\r\n=&gt; \"ABC\"。\r\n2023HNUPC B\r\n大意\r\n题目中说，可以选择一些有相同颜色的元素，把他们的颜色改成单调不减，使得若干次操作后，所有数\r\n组都单调不减。\r\n题解\r\n可以发现每次操作，等价于删除了一种颜色，若干次操作使得剩下的元素是单调不减的。\r\n问题就变成求一个魔改的最长上升子序列，在相同颜色的元素出现位置首次位置保存一下当前的答案，\r\n尾的位置更新一下当前的答案即可。用树状数组，线段树，或者上升子序列的二分算法都可实现。\r\n（对于一组相同元素a，最后一定是连着的，所以它们只能接第一个a前面的元素，只能最后一个a后面的元素接它们）\r\n启示\r\n简化思想\r\n联想模型\r\nD\r\n\\(0!=1\\)\r\n一个很复杂的式子可能最后很简单。\r\nE\r\n博弈论\r\n题意\r\n给定n堆石子，第i堆石子有\\(a_i\\)个，每次操作可以从最左边\r\n的石子堆中移除任意个石子(至少1个)，无法操作的人输。\r\n两个人玩游戏。每人连续操作1次，问谁能胜利。 一共有T个case。\r\n题解\r\n如果最左边石子堆数量为1，则操作唯一，交换先后手。\r\n如果最左边石子堆数量大于1，则当前操作的人必胜（若\\(a_{i+1}&gt;1\\) 则取 \\(a_i-1\\)，让对手取最后的1；若 \\(a_{i+1}=1\\) 则取 \\(a_i\\) 个，让对手取 \\(a_{i+1}\\) 的1）。\r\n如果当前没有石子，则当前操作的人必败。\r\n如果每人每次连续操作k次。定义f(i,j)表示如果第i堆只剩j个石子，并且其左侧的石子全部拿完的状态下，先手是否能获胜状态。1表示先手必胜，0表示后手必胜。能证明若f(i,j)=1,则任意t&lt;j,f(i,t)=1。\r\n启示\r\n让对手的操作唯一，让自己的状态能由自己控制\r\n证明状态单调来减少状态数。\r\n","tags":["算法竞赛"]},{"title":"日常总结","url":"/2025/01/20/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/","content":"CF932 div2比赛总结\r\n很烂，只做了两道题，感觉晚上好困。C思路是差不多的，主要是中间实现太复杂了，我忘了在遍历区间的右端点的时候，那个值是递减的。还是要注意区间与区间之间的关系。实现的时候还有些sb问题，需要注意。\r\n## CF932 div2 E.\r\nDistance Learning Courses in MAC ### 题意 n个数，每个数为 \\([x_i,y_i]\\)\r\n内任意一个数，q个询问，每次给一个 \\(l,\r\nr\\)，问从第l个数到第r个数（共r-l+1个数）的最大or和。 ### 题解 -\r\n从最大位开始贪心 - 如果该位（设为第 j\r\n位）有两个数能为1（y_i &lt;= (1&lt;&lt;j)），且至少一个数的\r\n\\(x_i\\) &lt;=\r\n(1&lt;&lt;j)，说明这个数可以进行“降维打击”，变成 (1&lt;&lt;j)-1\r\n直接结束游戏 -\r\n这样就把题目简化了很多，要么使用这个1后面继续考虑此数，要么不使用这个1直接进行降维打击。这个1只要不用就会结束游戏，所以一般情况必须得用。\r\n# Educational\r\nCodeforces Round 161 Div.2 D. Berserk Monsters [[优化处理]]\r\n题意\r\nn个二元组 \\((a_i,d_i)\\)\r\n排成一列，n轮，每一轮对于每一个 i 若 \\(d_i&lt;a_{pre_i}+a_{nxt_i}\\)\r\n则去掉这个二元组。（pre，nxt就是最近的没有去掉的二元组）。求每一轮去掉的组数。\r\n题解\r\n这道题比赛时想复杂了，想着对于每个联通块的左右端点处理，但其实没那么复杂。\r\n\r\nIt is important to note that if during the j�-th round the i�-th\r\nmonster did not die and none of its alive neighbors died, then there is\r\nno point in checking this monster in the (j+1)(�+1)-th round. Therefore,\r\nwe can solve the problem as follows: let's maintain a list of candidates\r\n(those who can die) for the current round; if the monster dies in the\r\ncurrent round, then add its neighbors to the list of candidates for the\r\nnext round.\r\n\r\n只用每次检查没有被保护的人（list），如果死了就在list中加入它附近的人。注意检查和去掉应该是两个循环。\r\nEducational\r\nCodeforces Round 161 Div.2 E - Increasing Subsequences [[构造]]\r\n题意\r\n构造一个子严格上升子序列的数量恰好为x的序列 ## 题解\r\n构造-&gt;找到特殊处理方式\r\n在一个序列最后如果加上一个比它们都小的值-&gt;t+=1\r\n在一个序列最后如果加上一个比它们都小的值-&gt;t=2\r\nt为子严格上升子序列的数量 将序列操作与数的二进制操作联系。 # \r\n把一段染成一个颜色之后可以把这一段看成一个数 # Educational Codeforces Round\r\n163 (Rated for Div. 2)D. Tandem Repeats? [[优化处理]] ## 题意\r\n有一行由小写字母和？组成的字符串，？可以代表任何小写字母。求重复子串的最大长度，重复子串指满足\r\n\\(s[l,l+len-1]=s[l+len,l+len*2-1]\\)\r\n的连续子串。 \\(n&lt;=5e3\\) ## 题解\r\n没想到那么简单qwq 就是要找到处理的相同量，这里是判断 \\(s[i]==s[i+len]\\)\r\n，当len固定时左端点l和l+1只有端点需要处理。在每次记一个cnt，记录满足相等的个数。因为len固定时判断的永远时s[i]和s[i+len]，所以\r\n\\(？\\) 可以直接贪心处理。 # Educational Codeforces Round\r\n163 (Rated for Div. 2)E. Clique Partition [[构造]] ## 题意\r\nn个点，第i个点序号为i，让你给每个点分配一个 a_i（1~n中互不相同的数）。当\r\n\\(|i−j|+|a_i−a_j|≤k\\)\r\n时第i个点和第j个点连一条边。求此图的极大强连通子图的个数的最大值。 ##\r\n题解\r\n易得每个强连通子图的点的个数&lt;=k，则构造一种方式使n=k时答案为1。如下：\r\n\\[m,m-1,m-2,...,1,n,n-1,...,m+1，其中m=k/2向上取整\\]\r\n找到边界，构造边界 # Educational Codeforces Round\r\n163 (Rated for Div. 2) F. Rare Coins [[概率]] [[优化处理]] ## 题意\r\n有n个袋子，编号为1到n。第i个袋子里装着 \\(b_i\\)\r\n个银币。每个银币有50%的概率价值为0，50%的概率价值为1。一个袋子的价值为其银币价值的和。现在问你Q个问题，每次给一个l和一个r和一个a，求\r\n\\[编号为l到r的袋子的价值和 - 其他袋子价值和\r\n&gt; a\\] 的概率 ## 题解\r\n简化问题：b1个银币贡献是加，b2个银币贡献是减，求 \\(res=t+b1-b2&gt;0\\) 的可能性。\r\n我们假设这b1个银币默认值是0，有1/2的概率变成1；b2个银币默认值是1，有1/2的概率变成0。则这b1+b2个银币都有1/2的概率使res增加1。我们再求res满足上述条件的概率（或者是方案数）就行。\r\n把“和”变成“变化值”，整体化 # *\r\n[[构造]]可以注意一下特殊情况，比如 11111……1111\r\n。还有题目上的限制可能比实际要用到的大，可能是来迷惑你的。\r\n9.30\r\n记得每次都要初始化，特别记住map， vector sqrt(long long)\r\n精度不够，还是两边都平方 并查集卡常 -&gt; 启发式合并 void merge(int x, int y) &#123; x = find(x), y = find(y); if (x == y) return; if (sz[x] &gt; sz[y]) swap(x, y); f[x] = y, sz[y] += sz[x]; &#125; \r\nD. Penchick and\r\nDesert Rabbit\r\n一列数，只能跳左边比它大的，和右边比它小的，求以每一个数为起点能跳到的最高处。\r\n突破口：a[i] 如何跳到 a[i+1]，利用 1~i最高 和\r\ni+1~n最矮。然后发现如果跳不到则两边隔离。\r\nwhy：发现从一个数跳到另一个数要考虑 左中右\r\n三边的数，所以把中间删掉。\r\n","tags":["算法竞赛"]},{"title":"高三暑假集训总结","url":"/2024/02/23/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/%E9%AB%98%E4%B8%89%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E6%80%BB%E7%BB%93/","content":"CodeForces -\r\n1426E Rock, Paper, Scissors\r\n题意\r\nA出a1次石头，出a2次剪刀，出a3次布，B同理。顺序自定。求the minimum\r\nnumber of round Alice can win和the maximum number of rounds Alice can\r\nwin。\r\n题解\r\n思维题\r\n先说max。每次决策非常独立。易得A的石头最多赢 \\(min(a1,b2)\\)\r\n次（其他同理），而且这样取互相不会影响（石头赢并不影响剪刀赢）。\r\n再说min。如果要赢得最少就要输的和平的尽量多。但是输的和平的不知道怎么分配\r\n牛客多校6\r\nE - Sequence\r\n题意\r\n给定一个长度为 n的序列 a\r\n多个询问，每次询问一段区间 l, r, k, 求是否能将这个区间分成\r\nk个部分使得每一部分的和都是偶数\r\n复杂度为O(n+q)\r\n题解\r\n\r\n“考虑从左到右扫，只要当前和为偶数就把它切开\r\n那么我们可以得到这个区间最多能分成多少个偶数部分\r\n这个过程可以通过记录奇偶性（奇数当成1，偶数当成0）的前缀和来维护\r\n时间复杂度:O(n + q)”\r\n\r\n一个简化：奇数当成1，偶数当成0\r\n再一个通项：00100010001000100\r\n为啥这样会没有后效性呢？试一试就知道了。\r\n因为在[l,r]之内都必须满足，所以可以直接从前往后扫。（从l开始策略很固定）\r\ntip:有的时候查找一段的信息可以用前缀和。\r\nB - Distance\r\n一个很高级的公式： \\[\r\n\\sum^{min(x,y)}_{i=0}(^x_i)(^y_i) = (^{x+y}_x)\r\n\\] 证明如下：\r\n\\(\\because (^y_i)=(^y_{y-i})\\)\r\n发现上面加起来是x+y，下面加起来是y（这里设x&gt;y）\r\n注意\\((^{x+y}_x)=(^{x+y}_y)\\)\r\n","tags":["算法竞赛"]},{"title":"Go","url":"/2025/01/20/%E8%AF%AD%E8%A8%80/Go/","content":"Todo\r\n1. 游标，文档流\r\n// 查找多个文档返回一个光标// 遍历游标允许我们一次解码一个文档for cur.Next(context.TODO()) &#123;\t// 创建一个值，将单个文档解码为该值\tvar elem Student\terr := cur.Decode(&amp;elem)\tif err != nil &#123;\t\tlog.Fatal(err)\t&#125;\tresults = append(results, &amp;elem)&#125;\r\n2. 池化技术\r\n3. 数据库\r\n4. google论文\r\nthe tail at scale\r\n基本语法\r\nitoa\r\nhttps://www.jb51.net/article/257413.htm 行计数器 ### 数组\r\n可以直接通过==比较运算符来比较两个数组 ### 切片\r\nt:=x[m:n]的t的地址还是原x的地址\r\n因为slice值包含指向第一个slice元素的指针，因此向函数传递slice将允许在函数内部修改底层数组的元素。换句话说，复制一个slice只是对底层的数组创建了一个新的slice别名（§2.3.2）\r\n容量和长度 fmt.Println(summer[:20]) // panic: out of range endlessSummer := summer[:5] // extend a slice (within capacity) and the value is original slice\r\n我们不能确认append时在原先的slice上的操作是否会影响到新的slice。因此，通常是将append返回的结果直接赋值给输入的slice变量：\r\nrunes = append(runes, r) // avoid changing original slice, so we change original variable\r\n因为我们一开始就知道names的最终大小，因此给slice分配一个合适的大小将会更有效。下面的代码创建了一个空的slice，但是slice的容量刚好可以放下map中全部的key：\r\nnames := make([]string, 0, len(ages))\r\nfor range 中赋值问题\r\n如果要改变其中的结构，要用t[i] type T struct &#123;  A int  B string&#125;func main() &#123;  t := []T&#123;&#123;1, &quot;a&quot;&#125;, &#123;2, &quot;b&quot;&#125;&#125;  fmt.Println(t)  for i, v := range t &#123;    fmt.Printf(&quot;%p %p\\n&quot;, &amp;v, &amp;t[i]) // 地址不同    v.A = 3  &#125;&#125; ### rune\r\n在Go中，rune 是一个内置类型，代表一个 Unicode\r\n码点，也就是一个 Unicode 字符。\r\nmap\r\nif age, ok := ages[\"bob\"]; !ok &#123; /* ... */ &#125; ok\r\n键是否真的存在于map中\r\nstruct\r\n点操作符也可以和指向结构体的指针一起工作\r\n如果结构体成员名字是以大写字母开头的，那么该成员就是导出的\r\n如果要在函数内部修改结构体成员的话，用指针传入是必须的；因为在Go语言中，所有的函数参数都是值拷贝传入的，函数参数将不再是函数调用时的原始变量。slice是因为它的值就是指针。\r\n需要注意的是Printf函数中%v参数包含的#副词，它表示用和Go语言类似的语法打印值。对于结构体类型来说，将包含每个成员的名字。\r\njson.Marshal(movies)\r\ndata, err := json.MarshalIndent(movies, \"\", \" \")\r\n结构体的成员Tag可以是任意的字符串面值，但是通常是一系列用空格分隔的key:\"value\"键值对序列；\r\nYear int\" \"json:\\\"released\\\"\"\r\nColor bool \"json:\\\"color,omitempty\\\"\"\r\njson.Unmarshal(data, &amp;titles)\r\n错误处理\r\n传播错误到父亲函数\r\nif err != nil &#123; return nil, fmt.Errorf(&quot;parsing %s as HTML: %v&quot;, url,err) &#125;\r\n由于错误信息经常是以链式组合在一起的，所以错误信息中应避免大写和换行符。\r\n在Go中，错误处理有一套独特的编码风格。检查某个子函数是否失败后，我们通常将处理失败的逻辑代码放在处理成功的代码之前。如果某个错误会导致函数返回，那么成功时的逻辑代码不应放在else语句块中，而应直接放在函数体中。Go中大部分函数的代码结构几乎相同，首先是一系列的初始检查，防止错误发生，之后是函数的实际逻辑。\r\ndefer\r\n所以，对匿名函数采用defer机制，可以使其观察函数的返回值。\r\nfunc double(x int) (result int) &#123; defer func() &#123; fmt.Printf(\"double(%d) = %d\\n\", x,result) &#125;() return x + x &#125;\r\n被延迟执行的匿名函数可以修改函数返回给调用者的所有返回值：\r\n包和文件\r\n默认的包名就是包导入路径名的最后一段，因此即使两个包的导入路径不同，它们依然可能有一个相同的包名。\r\nimport (    &quot;crypto/rand&quot;    mrand &quot;math/rand&quot; // alternative name mrand avoids conflict)\r\n指定当前工作目录 GOPATH $ export GOPATH=$HOME/gobook$ go get gopl.io/...\r\npkg子目录用于保存编译后的包的目标文件，bin子目录用于保存编译后的可执行程序，例如helloworld可执行程序。\r\n## 读整个文件 ioutil.ReadFile(filename)\r\nReadFile函数返回一个字节切片（byte\r\nslice），必须把它转换为string ## 接口\r\n接口的动态类型和动态值\r\n非空接口可能类型不空而值为nil，可能在一个函数内外变量为nil的定义不同\r\nvar p *intfmt.Println(p==nil)f(p) //func f(p interface&#123;&#125;) &#123;fmt.Println(p==nil)&#125;\r\n接口与方法\r\n问题：cannot convert v (variable of type data.Up) to type\r\ndata.Vgroup: data.Up does not implement data.Vgroup (method GetVideo has\r\npointer receiver) 方法不能是指针\r\nhttps://chenhe.me/post/pointer-and-interface-in-go#%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%9C%AC%E8%B4%A8\r\n- Book 与 *Book 是两个完全不同的类型。 -\r\n值接收器的方法隐式地同时被声明为指针类型的方法。反之不成立。\r\n- 接口的实现不一定是结构体，而可能是任意类型。 -\r\n可以认为接口的值相当于接口的一个实例。把一个接口的实现赋值给接口变量，接口的值不是实现的值，是类型和实现值的指针\r\n断言： - 一个类型断言检查它操作对象的动态类型是否和断言的类型匹配 -\r\n一个接口类型的类型断言改变了类型的表述方式，改变了可以获取的方法集合（通常更大），但是它保留了接口值内部的动态类型和值的部分。\r\n## json解析 结构的属性名必须大写 var data struct &#123;\tCode int `json:&quot;code&quot;`\t// not: code int&#125;err := json.Unmarshal([]byte(`&#123; &quot;code&quot;: 901 &#125;`), &amp;data)fmt.Printf(&quot;%#v\\n%v&quot;, data, err)\r\n测试\r\n单元测试\r\nhttps://juejin.cn/post/7172037988950474759 -\r\n以 _test.go 为后缀名， 单独通过 go test 来编译并执行 -\r\nfunc TestName(t *testing.T) -\r\n&#123;source_filename&#125;_test.go -\r\nt.Error, t.Errorf, t.Fatal(+f), t.Fail, t.Log(+f) -\r\n--cover 代码覆盖率 ### Mock\r\n对有调库，文件输入，网络传输的代码的单元测试 打桩：函数替换  ### 性能测试 \r\nstring和int转换\r\n\r\nstrconv.Atoi(strval)\r\nstrconv.Itoa(intval) ## 判断类型 func justifyType(x interface&#123;&#125;) &#123;    switch v := x.(type) &#123;    case string:        fmt.Printf(&quot;x is a string，value is %v\\n&quot;, v)    case int:        fmt.Printf(&quot;x is a int is %v\\n&quot;, v)    case bool:        fmt.Printf(&quot;x is a bool is %v\\n&quot;, v)    default:        fmt.Println(&quot;unsupport type！&quot;)    &#125;&#125; ## 编译\r\nmain包里的所有用到的文件都要编译运行\r\n\r\n匿名函数引用外部变量\r\nfor _, f := range filenames &#123;\tgo func(f string) &#123;\t\tthumbnail.ImageFile(f) // NOTE: ignoring errors \t&#125;(f)&#125;// 错误！for _, f := range filenames &#123;\tgo func() &#123;\t\tthumbnail.ImageFile(f) // NOTE: incorrect! // ... \t&#125;() &#125;// gorutine执行函数时 f 可能已经变了\r\nGo 版本管理\r\ngopath 此电脑/用户下载依赖的位置 go mod init\r\n初始化此模块，用于定位此项目，包括包与包之间的引用\r\ngo mod tidy 下载所需，删除不需 go proxy\r\n把github等上的包拉取下来，作为备份和缓存\r\nstruct{}类型当占位符\r\n性能优化\r\npprof\r\nimport ( \t_ &quot;net/http/pprof&quot; \t// 会自动注册 handler 到 http server，方便通过 http 接口获取程序运行采样报告)func main() &#123; \truntime.GOMAXPROCS(1) // 限制 CPU 使用数，避免过载\truntime.SetMutexProfileFraction(1) // 开启对锁调用的跟踪 \truntime.SetBlockProfileRate(1) // 开启对阻塞操作的跟踪 \tgo func() &#123; \t\t// 启动一个 http server，注意 pprof 相关的 handler 已经自动注册过了 \t\tif err := http.ListenAndServe(&quot;:6060&quot;, nil); err != nil &#123; \t\t\tlog.Fatal(err) \t\t&#125; \t\tos.Exit(0) \t&#125;() &#125;\r\n基本命令：\r\ngo tool pprof -http=:8080 \"http://localhost:6060/debug/pprof/XXX\"\r\nXXX改为： - profile ：cpu占用，火焰图等 - heap：内存 -\r\nallocs：申请内存，可能引起频繁 GC - goroutine：申请协程过多 -\r\nmutex：锁的争用的阻塞 - block：阻塞\r\n优化之后 -&gt; 改动前后响应数据diff\r\nhttps://farmerchillax.github.io/2023/07/04/Go%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/\r\n火焰图\r\nhttps://www.ruanyifeng.com/blog/2017/09/flame-graph.html y轴调用栈\r\n平顶 -&gt; 性能问题\r\nGC\r\nhttps://zhuanlan.zhihu.com/p/334999060\r\n三色标记法：同bfs，黑色是已经遍历，灰色是在队列中，白色是未遍历（可能不可达）\r\n弱三色不变式：不允许“从灰色对象出发，到达白色对象的、未经访问过的路径被赋值器破坏”，允许“赋值器修改对象图，导致某一黑色对象引用白色对象“\r\n插入屏障：在A对象引用B对象的时候，B对象被标记为灰色。\r\n删除屏障：被删除的对象，如果自身为灰色或者白色，那么被标记为灰色。\r\n混合写屏障：为了消除栈的重扫过程（栈上的很容易被删除），一旦栈被扫描变为黑色，则它会继续保持黑色，\r\n并要求将对象分配为黑色。 - GC 开始将栈上的对象全部扫描并标记为黑色； -\r\nGC 期间，任何在栈上创建的新对象，均为黑色； - 被删除的堆对象标记为灰色；\r\n- 被添加的堆对象标记为灰色； ## 逃逸分析\r\n逃逸分析：分析这个变量需不需要放到堆上，降低效率但是保证函数ret后还在\r\n情况有：指针逃逸，interface{}动态类型逃逸，栈空间不足，闭包\r\nGMP模型\r\nG：goroutine M：工作线程（OS\r\nthread），它直接对应于操作系统的线程。M负责实际执行Go代码。一个M可以执行多个Goroutine，但同一时间只能执行一个Goroutine\r\nP：执行Go代码所需的资源\r\nDataBase\r\n \r\n指针切片\r\nusers := []*User&#123;\t&#123;Name: &quot;Jinzhu&quot;, Age: 18, Birthday: time.Now()&#125;,\t&#123;Name: &quot;Jackson&quot;, Age: 19, Birthday: time.Now()&#125;,&#125;\r\n","tags":["后端","Go","语言学习"]},{"title":"JS","url":"/2024/02/23/%E8%AF%AD%E8%A8%80/JS/","content":"变量名要使用let和const，完全摒弃var\r\nlet只在作用域里，与c++\r\nvar定义后在哪里都可以用\r\nget document中的对象\r\nconst canvas = document.getElementById(\"canvas\");\r\nconst a = document.getElementsByClass(\"num\");//注意a是个数组\r\n建议搞个函数\r\n函数\r\nfunction a()&#123;return …;&#125;\r\n可以函数里定义函数\r\n定义数组\r\nlet s=[];\r\n## parseInt();\r\n转换为整数（什么类型都可）\r\nstring处理\r\nget s[i] 是可以的，set（like s[i]='a'）是不行的 用substring和+\r\ns.toUpperCase()全部转大写\r\n要用 === 而不是 ==\r\n箭头函数\r\n(param1, param2, …, paramN) =&gt; &#123; statements &#125;(param1, param2, …, paramN) =&gt; expression//相当于：(param1, param2, …, paramN) =&gt;&#123; return expression; &#125;\r\n不会创建自己的this\r\n剩余参数\r\nfunction f(a, b, ...theArgs) &#123;  for(int i=0;i&lt;theArgs.length;i++)&#123;  \tconsole.log(theArgs[i]);  &#125;&#125;f(0,0,1,2,3);//[1,2,3]f(1,2,3,4,5,3,2);//[3,4,5,3,2]\r\ngetBoundingClientRects()\r\n返回值是一个 DOMRect\r\n对象，是包含整个元素的最小矩形（包括 padding 和\r\nborder-width）。该对象使用\r\nleft、top、right、bottom、x、y、width\r\n和 height\r\n这几个以像素为单位的只读属性描述整个矩形的位置和大小。除了\r\nwidth 和 height\r\n以外的属性是相对于视图窗口的左上角来计算的。\r\n该方法返回的 DOMRect\r\n对象中的 width 和 height 属性是包含了\r\npadding 和 border-width\r\n的，而不仅仅是内容部分的宽度和高度。在标准盒子模型中，这两个属性值分别与元素的\r\nwidth/height + padding +\r\nborder-width 相等。而如果是 box-sizing: border-box，两个属性则直接与元素的\r\nwidth 或 height 相等。\r\n改属性时注意是字符串\r\nout.style.left = event.x-0.5*box.width+\"px\";\r\n** 指数运算符\r\n右结合\r\n2 ** 3 ** 4 即 \\(2^{(3^4)}\\)\r\nError对象和throw语句\r\nthrow new Error(\"这是一个错误\");\r\n手动中断程序执行，抛出一个错误\r\n对于 JavaScript\r\n引擎来说，遇到throw语句，程序就中止了。引擎会接收到throw抛出的信息，可能是一个错误实例，也可能是其他类型的值。\r\ntry...catch 结构\r\ntry代码块抛出错误（上例用的是throw语句），JavaScript\r\n引擎就立即把代码的执行，转到catch代码块，或者说错误被catch代码块捕获了。catch接受一个参数，表示try代码块抛出的值。\r\ncatch代码块捕获错误之后，程序不会中断，会按照正常流程继续执行下去。\r\ntry...catch结构允许在最后添加一个finally代码块，表示不管是否出现错误，都必需在最后运行的语句。(就算是return)\r\nopenFile();try &#123;  writeFile(Data);&#125; catch(e) &#123;  handleError(e);&#125; finally &#123;  closeFile();&#125;\r\n上面代码首先打开一个文件，然后在try代码块中写入文件，如果没有发生错误，则运行finally代码块关闭文件；一旦发生错误，则先使用catch代码块处理错误，再使用finally代码块关闭文件。\r\ntry &#123;  try &#123;    consle.log(&#x27;Hello world!&#x27;); // 报错  &#125; finally &#123;    console.log(&#x27;Finally&#x27;);  &#125;  console.log(&#x27;Will I run?&#x27;);&#125; catch(error) &#123;  console.error(error.message);&#125;// Finally// consle is not defined\r\n码风\r\n\r\n表示函数调用与定义时，函数名与左括号之间没有空格。\r\n其他情况时，前面位置的语法元素与左括号之间，都有一个空格。\r\n\r\nclass\r\n基本概念\r\n每个类中包含了一个特殊的方法\r\nconstructor()，它是类的构造函数，这种方法用于创建和初始化一个由\r\nclass 创建的对象。\r\nclass Runoob &#123;  constructor(name, url) &#123;    this.name = name;    this.url = url;  &#125;  work(age)&#123;//create its function        &#125;&#125;\r\n继承 extends\r\n当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类（父类），新建的类称为派生类（子类）。\r\nsuper()\r\n方法引用父类的构造方法。需要在自己的构造方法中使用。\r\nclass Animal &#123;...&#125;class Dog extends Animal &#123;    constructor(name, breed) &#123;        super(name);        ....    &#125;    bark()&#123;...&#125;&#125;\r\n静态方法\r\n静态方法是使用 static\r\n关键字修饰的方法，又叫类方法，属于类的，但不属于对象，在实例化对象之前可以通过\r\n类名.方法名 调用静态方法。\r\n静态方法不能在对象上调用，只能在类中调用。\r\nexport &amp; import\r\nexport\r\n命名导出和默认导出\r\n命名导出一般只能用相同的名字，但可以换名字 export { myFunction as\r\nfunction1, myVariable as variable };\r\n默认导出一个模块只能有一个，在导入时可以定义名字\r\ntype=\"module\" 的 script 元素\r\n// 导出列表export &#123; name1, name2, …, nameN &#125;;// 重命名导出export &#123; variable1 as name1, variable2 as name2, …, nameN &#125;;\r\nrequire和import及其用法\r\n赋值\r\nlet obj1 = {a:1, b:2};\r\nlet obj3 = obj1;\r\nobj3与obj1的内存位置相同，会同步修改\r\n\r\n在开始之前，我先普及一些基础知识。Javascript\r\n的对象只是指向内存中某个位置的指针。这些指针是可变的，也就是说，它们可以重新被赋值。所以仅仅复制这个指针，其结果是有两个指针指向内存中的同一个地址。\r\n\r\n浅拷贝（只能在所有属性都是值的情况下拷贝）\r\nvar obj1 = &#123; foo: &quot;foo&quot; &#125;;var obj2 = &#123; bar: &quot;bar&quot; &#125;;var copySpread = &#123; ...obj1, ...obj2 &#125;;// Object &#123; foo: &quot;foo&quot;, bar: &quot;bar&quot; &#125;var copyAssign = Object.assign(&#123;&#125;, obj1, obj2);// Object &#123; foo: &quot;foo&quot;, bar: &quot;bar&quot; &#125;\r\njs array 如果索引出界\r\n索引超出范围：如果尝试读取一个超出数组长度的索引，结果会是\r\nundefined。\r\n索引超出范围：如果尝试修改一个超出数组长度的索引，数组会自动扩展到相应的长度，并在中间填充\r\nundefined。\r\n","tags":["前端","语言学习","JS"]},{"title":"Python","url":"/2025/01/20/%E8%AF%AD%E8%A8%80/Python/","content":"杂记\r\n\r\nfor循环好办法\r\n\r\nfor tittle , address, price, img, name , sex in zip(tittles ,\r\naddresses, prices, imgs, names, sexs)\r\n\r\nlist(zip()) 把 zip 对象变成 list\r\n\r\n通过使用 if __name__ == '__main__':\r\n条件，我们可以区分出程序是直接执行还是作为模块导入的。\r\n这样，我们可以在直接执行时运行一些特定的代码，而在作为模块导入时，这些代码将不会被执行。\r\n列表的高端用法\r\n\r\nlist1 = [a*a for a in range(1,10)]\r\n\r\ntime.sleep(2)\r\n\r\n在Python中，time.sleep(2)是一个用于暂停程序执行的函数。它会使程序在执行到该语句时停顿2秒钟，然后再继续执行后面的代码。time是一个Python内置的模块\r\n\r\njson解析\r\n# 使用loads()方法将JSON字符串转换为Python对象person = json.loads(data)# dumps() 反过来\r\n在Python中，enumerate()函数用于在迭代过程中同时获取元素的索引和值。\r\n\r\n```for index, fruit in enumerate(fruits): print(index, fruit)\r\n\r\nexcept requests.RequestException:\r\n\r\nrequests.RequestException\r\n是Python中requests库定义的一个基本异常类。这个异常类是其他异常类的父类，可以捕获所有请求过程中的异常。\r\n\r\nexc_info参数是一个布尔值，默认值为False。如果将exc_info设置为True，logging模块将会在日志中输出异常的详细信息，包括异常类型、异常值和traceback\r\n\r\nlogging.error('error occurred while scraping %s', url, exc_info=True)\r\n\r\n在re模块中，search() 第一个匹配到的。match_object.span()\r\n这将返回一个元组，其中包含匹配项的起始位置和结束位置。match_object.group()\r\n这将返回匹配的字符串。\r\n\r\n还有findall()\r\n\r\n你可以使用sort()函数来对包含字典的列表按照特定的键进行排序。在Python中，sort()函数是用于对可变序列进行原地排序的方法。下面是一个示例代码，演示如何使用sort()函数对包含字典的列表按照特定键进行排序：\r\n# 创建一个包含字典的列表people = [    &#123;&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;age&#x27;: 25&#125;,    &#123;&#x27;name&#x27;: &#x27;Bob&#x27;, &#x27;age&#x27;: 30&#125;,    &#123;&#x27;name&#x27;: &#x27;Charlie&#x27;, &#x27;age&#x27;: 20&#125;]# 使用lambda函数作为排序的key参数，指定按照age键进行排序people.sort(key=lambda x: x[&#x27;age&#x27;])# 打印排序后的结果for person in people:    print(person)\r\n运行上述代码，输出结果如下：\r\n&#123;&#x27;name&#x27;: &#x27;Charlie&#x27;, &#x27;age&#x27;: 20&#125;&#123;&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;age&#x27;: 25&#125;&#123;&#x27;name&#x27;: &#x27;Bob&#x27;, &#x27;age&#x27;: 30&#125;\r\n在这个示例中，我们使用了lambda函数作为sort()函数的key参数，指定按照字典中的age键进行排序。lambda函数接受一个字典作为参数，并返回该字典的age值。sort()函数根据返回的age值进行排序，从而实现按照age键进行排序的效果。\r\n你也可以根据需要指定其他键进行排序，只需将lambda函数中的键名修改为你想要排序的键即可。\r\n希望这个示例能帮助你理解如何使用sort()函数对包含字典的列表按照特定键进行排序。如果你还有其他问题，请随时提问。\r\nname_str = ''.join([now_char['text'] for now_char in char_list])\r\n所以大多数Python程序员会遵循一种命名惯例就是让属性名以单下划线开头来表示属性是受保护的\r\n@property 和\r\n@属性名.setter\r\n装饰器 class Person:\t@property\tdef name(self):\t\treturn self._name\t\t@name.setter\tdef name(self, value):\t\tif isinstance(value, str):\t\t\tself._name = value\t\telse:\t\t\traise ValueError(&quot;Name must be a string&quot;)\t\tprint(person.name)  # 输出: Aliceperson.name = &quot;Bob&quot;  # 更新名字\r\n作用域和命名空间\r\n\r\nglobal 和 nonlocal num = 1 def fun1(): \tglobal num # 需要使用 global 关键字声明 \tprint(num) \r\n\r\n\r\ndef outer(): \tnum = 10 \tdef inner(): \t\tnonlocal num # nonlocal关键字声明 \t\tprint(num)\r\n\r\n静态方法和类方法\r\n\r\n静态方法 ：类的静态方法和我们自定义的函数基本没什么区别，没有\r\nself，且不能访问类属性，实际项目中很少用到，因为可以使用普通函数替代。@staticmethod\r\n装饰器声明。\r\n类方法：必须包含一个参数，通常约定为 cls ，cls 代表 类本身（可以用\r\ncls() 实例化 class），这个参数也不需要我们传值。\r\n\r\n处理数组：insert()\r\n方法可以在列表的指定位置插入一个元素。如果你想在列表的最前面添加一个元素，可以使用\r\ninsert(0, element)，其中 0 表示列表的第一个位置。\r\n另一种方法是通过拼接（concatenation）来创建一个新的列表，将新元素和原列表合并。b\r\n= [0] + b\r\n输入 a,b = map(int,input().split());  print(a+b)\r\nprint 在Python中，print\r\n函数默认在输出之后添加一个换行符。如果你不希望print函数在输出后换行，可以使用end参数来指定不换行。end参数的默认值是，表示换行。如果你想要在同一行输出多个内容，可以将end参数设置为一个空字符串''。\r\n\r\n","tags":["Python","语言学习"]},{"title":"Rust","url":"/2025/04/11/%E8%AF%AD%E8%A8%80/Rust/","content":"Rust\r\n","tags":["语言学习","Rust"]},{"title":"How Google Works","url":"/2025/01/20/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/How%20Google%20Works/","content":"\r\n求突破，而非渐变\r\n创业精英 -&gt; 独立项目的首席执行官\r\n如果某行业产品的主要要素的成本曲线下降，那么该行业必将会出现剧变。\r\n-&gt; 提供出类拔萃的产品 &gt; 掌握信息，垄断渠道，强力营销\r\n创业精英不拘泥于特定的任务，也不惧怕冒险，多领域能力 -&gt;\r\n自由发挥\r\n乐于说“好”\r\n只看平台（流量），不看产品（当前的收入）\r\n不要被竞争对手牵着鼻子走，”如果你的工作只是击败那些和你套路基本相当的公司，那又何谈乐趣呢“\r\n以科技洞见为基础\r\n对招聘的重视\r\n为了让员工大展身手，公司情愿自我调整\r\n人才流失会造成连锁反应\r\n把内推作为员工考核的一项\r\n电梯演讲\r\n如果都想得一样，那就是有人没有思考。\r\n改变他人需要让他感觉到观点得到倾听和重视，给予情感支持\r\n马背原则：不要为1%的风险停留太久（创新企业只有50%符合规范），把马勒住（而不是下马）打量周围情况\r\nOKR基本目标+重点指标\r\n共享一切，保证员工对公司的总体了解\r\n当面谈话是最重要的沟通方式，增加共同话题来引起谈话\r\n一件事需要重复大约20遍才能让人认真听进去，不同的表述方法，新鲜的例子\r\n第一追随者原则，做一件事，有第一个追随者后，其他追随者就会蜂拥而上，增加追随者出现的概率\r\n你想得不够大\r\n修改创意而不是放弃创意，许多伟大的发明的最终用途与最初设想都天差地别\r\n\r\n","tags":["阅读笔记"]},{"title":"test","url":"/2025/01/20/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/test/","content":"image test: \r\n  \r\nlatex test: \\(\\frac{1}{2}\\)\r\n"},{"title":"《做最好的自己》","url":"/2025/01/20/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E3%80%8A%E5%81%9A%E6%9C%80%E5%A5%BD%E7%9A%84%E8%87%AA%E5%B7%B1%E3%80%8B/","content":"自信\r\n永远相信自己有足够的潜能, 并因此尊重和鼓励自己.\r\n不要因为一些挫折就否定自己, 坚定相信只是暂时的问题,\r\n只要积极改正就是做好.\r\n用具体事例反复 训练 你的大脑, 经过潜意识的每一次思维,\r\n告诉自己你是值得信任的, 你应当为自己自豪, 你必须成为自己最好的啦啦队. (\r\n赛前回忆法 : 赛前回忆最得意的比赛, 和一个特定动作 )\r\n\r\n不要因为在乎别人的意见而失去自己的想法, \"不同人有不同想法\"\r\n这件事是很正常的, 不一定是谁更对更高级, 记得考虑自己的立场.\r\n有自己的想法和主见. 找到自己的原则, 底线. 当觉得自己对某件事可以\r\n\"不在乎\" 的时候, 那也许正是开始逐渐丧失自我, 丧失自信的时候.\r\n有想法一定要表达出来. 自我表现是对自己最好的鼓励, 看到自己的影响力.\r\n要训练自己形成主见和自信的能力.\r\n学习有自信的人的说话的语气 :\r\n\r\n多用 \"我认为\" \"我希望\",\r\n少用拖泥带水的词（如也许、可能、会不会、如果\r\n讲话清晰, 用语调音量停顿等强调信息\r\n主动和对方目光接触\r\n表述时不让他人随意打断\r\n不担心听众不尊重自己\r\n\r\n\r\n了解一个人一般只需要 10 秒钟, 凭直觉.\r\n自信的人总能不断地从自己身上找到前进的动力, 总能发挥出自己的潜能.\r\n勇气\r\n对于一个毕业生来说，机会远比安稳更重要，事业远比金钱更重要，未来远比今天更重要。过早地固定在一个职业上也许才是人生的最大不幸。继续学习,\r\n为了理想和兴趣, 为了充分面对这个迅速变化的世界, 不要害怕犯错.\r\n宽容\r\n值得为了别人的过失, 而付出自己不快乐的代价吗\r\n\"我不同意你, 但我支持你\"\r\n自律和自觉\r\n自觉不只是认识自己的潜能、素质，还包括认识自己的感情、态度。自觉的人知道自己何时会有喜、怒、哀、乐的表现，也明白喜、怒、哀、乐的宣泄会造成怎样的后果。\r\n人的感情是最富有感染力的，你完全可以用有建设性的、宽容的态度与他人沟通并影响他人。\r\n每个人对别人的判断都会受到自己主观因素的影响，不一定完全公正.\r\n计划\r\n一套要有明确的远期、中期和近期目标,\r\n还有拥有一个稳定的、鼓舞人心的价值观或信念.\r\n可度量, 结果导向, 时间限制\r\n不要轻易改变自己的目标，不要因为困惑和犹豫与一个又一个成功的机会失之交臂！\r\n\r\n保护自己的时间, 不要被破事分割\r\n利用高效时间, 要把握一天中20％的精华时间\r\n给自己一个合理的最后期限\r\n\r\n理想\r\n只有那些从事真心喜爱的人，才会得到真正的财富（Money comes to those\r\nwho do it for love)\r\n\"影响力\"\r\n兴趣\r\n在工作中找到兴趣:\r\n\r\n今天有没有哪一点比昨天做得更好？\r\n你的技能有没有新的提高？有没有学到新东西？\r\n你的工作或专业对别人有没有帮助？\r\n你周围的人有没有夸奖你？\r\n\r\n阿兰·巴迪欧在《何为真正生活》中说，\"第一个是当下生活的激情——追求娱乐、快感、一晌贪欢。第二个似乎恰恰相反：追求成功的激情——让自己变得富有，获得权力。这两个内在敌人让他们远离了真正的生活,\r\n让他们认识不到他们自己创造真正的价值. \"\r\n选择\r\n\"我在大时代的潮流里漂来漂去，每一步都是大时代的结果，个人选择很少。新一代年轻人对大时代的起伏与波折感知越来越弱。但在这样的“小时代＇中，其实有丰富多彩的选择.\r\n内卷、躺平、追求自己喜欢的事都是选项，也很精彩。我曾作为特邀嘉宾在斯里兰卡莫拉图瓦大学毕业典礼致辞，演讲的题目是“Development\r\nis the right to\r\nchoose”。我羡慕年轻人拥有“选择＇的权利，这是时代的进步。”\r\n对于已经做出的选择,\r\n与其把时间花在无谓的焦虑上，倒不如把这些东西“轻轻”放下，然后一身轻松地去做自己应该做的事。不能陷入纠结.\r\n\r\n把影响你抉择的因素罗列成一张“利弊对照表”.\r\n咨询他人的时候也带上这张表.\r\n学会用概率论的方法看问题,\r\n做概率分析时，可以列出“最好的可能”和“最坏的打算”的概率，以帮助自己综合考量。\r\n\r\n沟通\r\n不同意的艺术 :\r\n\r\nstart with\r\n\"你有这种感觉，我一点也不奇怪。如果我是你，毫无疑问，我的想法也会跟你的一样.\r\n\"\r\n讨论的目的是推动双方的认识和议题的进展，而不是互争输赢的辩论。\r\n保持自信 :\r\n当一个人遇到不同意见最多的时候，也恰恰是他收获最多的时候。\r\n\r\n建设性意见\r\n如何更加外向\r\n\r\n接受并庆幸你拥有内向的性格\r\n尽量找机会，给自己一些“较外向但又不带来太大压力”的改变。\"可衡量的目标\"\r\n(开会发一次言, 一个月主动交一个朋友)\r\n主动和别人分享有趣的事, 让自己有价值\r\n主动找人讲话时，不要那么在乎“面子”。如果一个人不理睬你，你不会有任何的损失.\r\n\r\n学习\r\n就算你已经大学毕业，你仍然应该分配相当多的时间来学习，尤其是当你工作在发展得特别快的领域时。\r\n毅力\r\n暂时的挫折会给人极大的困扰和打击。但是，几乎每个行业、每件事情都有大大小小的困难和挫折。如果因此转移兴趣，那么你永远也找不到自己的兴趣。相反，如果能够克服困难，取得进步。那么你就会使兴趣升华，让兴趣不仅包含好奇,\r\n还包含巨大的满足感.\r\n","tags":["学习笔记","阅读笔记"]},{"title":"数学之美学习笔记","url":"/2024/02/02/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"《数学之美》读后感\r\n本书在各个方面深入浅出地科普了数学在IT上的应用。虽然我认为其中的数学知识不算太多，因为作者原本的目的也是想让某些IT公司了解到在IT行业做事情的正确方法——重视简单而有效的方法而非凑合。所以我看完本书后数学美不美没看出来，反正计算机是挺美的。基本上是关于人工智能的。\r\n\r\n本书因为原本是以博客为载体，所以所分成的34章之间没有太大的关联，适合碎片化阅读。其又将难点作为延展阅读分出来，对只想浅层了解的读者很好。\r\n下面展开回顾一下其中的知识和我认为有用的点。\r\n自然语言处理\r\n语言与通信\r\n作者讲到，语言的本质是为了人类之间的通信，所以所有自然语言处理的问题都可以等效为通信的解码问题。科学家由此发明了基于统计的算法，此方法遥遥领先于基于规则的算法。这种算法找到了语言的本质，把自然语言处理，机器翻译，语音识别等问题都概括成通信模型（编码和解码的过程），从而找到又简单又通用的方法。这也让我认识到计算机与人类的本质不同，所以凭直觉地让计算机模仿人类很多是低效的。（基于语法规则和理解文义的算法的失败）\r\n统计语言模型\r\n通过计算每句可能的句子的概率（）来生成最有可能的句子。它基于马尔可夫假设推出这样一个公式：\r\n\r\n这称为二元模型。当然也有更高阶的模型，但有更大的时间和空间复杂度（ \r\n）。统计语言模型只需要在巨大的语料库里统计  。\r\n由于统计数据中小概率和零概率事件的可靠性低，所以需要做平滑过渡处理。对于未看见的事件，我们需要从总量（100%）中分配很小的比例给它们，根据”越是不可信的统计折扣越多“的方法（古德-图灵公式）。高阶模型则会用卡茨退避法。\r\n训练之前还需要进行噪音过滤。\r\n分词\r\n与上述的模型相似。但需要注意的是，应用不同时汉语分词的颗粒度大小时常不同。比如机器翻译的颗粒度应该更大，而搜索引擎的颗粒度应该更小，需要根据所需进行改良。\r\n隐马尔可夫模型\r\n它的定义大致是这样（具体定义见维基）：令 ， 为离散时间随机过程，\r\n是马尔可夫过程（就是一条马尔科夫链， 只与  有关， 只与  有关， 不可观测， 可观测（确定）。因此输出符号的序列（\r\n ）能够透露出状态序列（  ）的一些信息。公式为 \r\n其在通信模型中的理解就是{O_n}是要解码的序列，{S_n}是解码后得到的序列，我们需要挑出P(s_1,s_2,...|o_1,o_2,...)最大的{S_n}来作为答案。\r\n隐马尔可夫模型的参数可以通过鲍姆-韦尔奇算法得到。它只需要大量{O_n}，是一种无监督的训练方法。大致算法（我理解的）如下：它可以得到生成{O_n}的所有路径和概率，然后通过改变参数使得观测序列出现的概率最大化。具体算法详见维基百科\r\n此模型非常通用，除自然语言处理之外还有很多问题可以用到这个算法。\r\n信息论相关\r\n信息熵\r\n信息熵可以度量一个信息的作用，可以理解为在不知道一条信息的情况下提供多少bool信息（是or否）能完全知道它。其计算公式为\r\n s为未知量的任意可能状态。\r\n作者还提到了条件熵的概念，其公式为  还有互信息（度量两个随机事件的相关性） \r\n搜索引擎\r\n基本原理\r\n\r\n自动下载尽可能多的网页（爬虫）\r\n建立索引（基于数据库和布尔运算）\r\n对相关网页排序\r\n\r\nPangRank算法\r\n它的基本原理非常简单，就是“如果一个网页被很多网页所链接，那么它的排名就高”。\r\n其排名的依据应该是每个指向它的网页的排名之和，公式大致为 指向的网页 用矩阵表示就是  其中 ，\r\n为以网页为点，超链接为边的邻接矩阵。然后就可以使用迭代的方法。\r\n因为网页数量巨大，还可以使用稀疏矩阵的方法简化计算量。\r\n除此之外，还要进行平滑处理，改进公式如下 \r\n搜索关键词权重的度量 TF-IDF\r\n在一个网页的关键词中，有的关键词比如‘的’，’应用‘因为非常常见，所以没有那么重要；而有一些关键词比如’TF-IDF‘就非常重要，所以发明了TF-IDF的概念。TF指单文本词频，就是一个词语在这篇文章中的重要性。IDF是逆文本频率指数，它的公式是\r\n总网页数所出现的网页数 则一个搜索语句和一篇网页的相关性可以用以下公式来度量 搜索中的关键词 这其实与信息论的公式很相似。\r\n网页权威性计算\r\n与PageRank大致相同，但是用文章内容中的“提及”而不是超链接的指向，而且权威性要分主题。\r\n问题：如何通过描述找到网站，如何区分权威网站和套壳网站？\r\n有限状态机\r\n用于地址识别时很有效，因为地址的文法简单，有明显的从属关系。还可以在自动机器人控制，编译器和解释器，网络协议等方面应用。\r\n分类\r\n特征向量\r\n找到和文章主题相关的所有词语（总TF-IDF高）作为单词库。定义一篇文章的特征向量为它在单词库里的词语的TF-IDF值（注意是相对于这篇文章来说）所组成的向量。则两个向量的相关性可以用它们的夹角的余弦值表示。\r\n那么分类的方法可以用自底向上不断合并，但比较复杂且耗时比较长，而下面一种办法能一步到位。\r\n奇异值分解（SVD）\r\nSVD把所有文章的特征向量放在一起，为 \r\n其中M是文章数，N是词数。\r\n奇异值分解可以把A分解为 ，\r\n其中K1是主题数，K2是语义类数，X是每个文章和每个主题的相关性，Y是词和语义类的相关性，\r\n信息指纹和相似哈希\r\n信息指纹用伪随机数产生算法将一段信息压缩成一段数字。可以证明，只要算法足够好，就能保证两个不同信息的指纹相同的概率极小。将一个集合的所有元素的信息指纹相加就能用于集合相同的判定（加法的交换律）。而进行多次随机挑选比较\r\n就是判定两个集合是否基本相同。\r\n而相似哈希就是将每个元素的信息指纹按权重（可能是TF-IDF）逐位相加，可以用于度量相关性（差越小相关性越大）（但是应该只能度量\r\n比较相似 和 不相似 吧）。伪代码大致如下：\r\nans[j] += (((hash[i]&gt;&gt;j)&amp;1)?1:-1)*w[i];\r\n后面没时间了，简单写写\r\nRSA算法\r\n其中为选定的很大的素数取满足为的逆元，即以为公钥，为私钥加密：解密：\r\nP，Q很大，所以虽然N是公开的，但是不能知道M。最后两行用到了费马小定理。\r\n最大熵原理\r\n在所有可能的概率模型中，熵最大的模型概率最好（不确定性）。（猜测骰子概率）\r\n也可以用于综合多种数据（比如拼音输入法的通用模型和个性化模型）。\r\n公式为（可能？） \r\n参数 \r\n可以用通用迭代算法GIS训练。\r\n布隆过滤器\r\n用于判断一个元素是否存在于一个集合里\r\n把一个8字节的url变成8个信息指纹（），存到一个大小为16*N的哈希表（桶）里\r\n为啥是16*N呢？因为作者说的哈希表的存储效率只有50%。\r\n保证不会漏，但是可能会多（概率很小）。\r\n贝叶斯网络\r\n跟马尔可夫链挺像的，基于”一个状态只由指向它的状态所直接决定。\r\n但不完全一样，边权那里更复杂。\r\n\r\n实例\r\n\r\n杂记\r\n简单有效的东西\r\n作者认为，有的时候简单的算法会比精确而复杂的方法更有效，因为这容易读懂，易维护。而大而全的方法不仅容易因长时间不能完成而不了了之，而且可能会陷入像大圆套小圆那样冗杂的方法中。辛格甚至要求对于改进方法都要有清楚的理由，对于参数和公式都要有合理的物理解释，不然难以改动，容易变成“凑合”的算法。\r\n个性化语言模型\r\n一个用户的输入内容有限，可以把输入内容和用语习惯类似的用户合并在一起。（我认为这里信息量增加的原因可能是人类的群居性或者叫做标签化（类似于“人以类聚”）。\r\n没看懂的地方\r\n不代表其他都看懂了，只是这些完全没看懂\r\n\r\n基于变换规则的机器学习方法\r\n条件随机场\r\n\r\n没时间总结的地方\r\n\r\n码分多址\r\n\r\n无线电通信相关\r\n基于扩频传输\r\n多频带，多信息同时传输，用对应地址码解调出相应信号\r\n\r\n期望最大化算法\r\n\r\n可以应用于文本的自收敛分类\r\n\r\n先随机选K个点作为初始中心\r\n将每个点归到最近的中心\r\n重新计算每一类的中心\r\n一直重复23步，直到同一类中各个点到中心的平均距离d最小，不同类中心之间的平均距离D最大\r\n\r\n\r\n逻辑回归模型\r\n\r\n用于把一个数值映射到一个0-1概率上？\r\n\r\n人工神经网络\r\n\r\n输入层，输出层，隐藏层\r\n通过边权计算点权 G=f(g(w1,w2,...))\r\n其中g是线性变换，f是一对一的函数（通常是e^x)\r\n通过设计成本函数可以进行无监督训练\r\n\r\n椭圆曲线加密原理\r\n\r\n","tags":["学习笔记","总结"]},{"title":"阅读杂记","url":"/2025/01/20/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E9%98%85%E8%AF%BB%E6%9D%82%E8%AE%B0/","content":"How to Ask Question The Smart\r\nWay\r\n\r\n值得反复咀嚼玩味的好问题可以提高理解力，而且通常会暴露我们以前从没意识到或者思考过的问题。对黑客而言，“好问题！”是诚挚的大力称赞。\r\n表明你已经做了努力,\r\nmore：一并表达在做了上述努力的过程中所学到的东西。他们能从你的提问看出你做了多少阅读与思考，如果你是有备而来，将更有可能得到解答。\r\n你将会是自己去挣到一个答案，靠提出有内涵的、有趣的、有思维激励作用的问题\r\n—— 一个有潜力能贡献社区经验的问题，\r\n表现出只要有人能指个正确方向，你就有完成它的能力和决心。\r\n如果是 bug\r\n尽可能地提供一个可以重现这个问题的可控环境的方法。\r\n提问时，即使你私下非常确信已经发现一个真正的\r\nBug，最好写得像是你做错了什么。直接声称找到一个 bug\r\n是在质疑他们的能力，会冒犯。\r\n在开头就描述你的目标，然后才陈述重现你所卡住的特定步骤。\r\n我想更好地理解\r\nX，可否指点一下哪有好一点说明？如果你的代码不能运作，通常请别人看看哪里有问题，比要求别人替你改正要明智得多。\r\n问题解决后，向所有帮助过你的人发个说明，让他们知道问题是怎样解决的，并再一次向他们表示感谢。\r\n对初犯者私下回复。 对那些坦诚犯错之人没有必要当众羞辱，一个真正的新手也许连怎么搜索或在哪找常见问题都不知道。\r\n\r\n","tags":["生活"]}]