<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>lyx12138的博客</title><meta name="robots" content="noindex"><link rel="icon" type="image/x-icon" href="https://cdn.luogu.com.cn/upload/image_hosting/8cc2fgam.png"><link rel="preload" as="font" crossorigin="anonymous" href="/font/Bender.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/font/BenderLight.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/font/JetBrainsMono-Regular.woff2"><link rel="stylesheet" href="/css/arknights.css"><style>@font-face {
  font-family: Bender;
  src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
  font-family: BenderLight;
  src: local('BenderLight'), url("/font/BenderLight.ttf");
}
@font-face {
  font-family: 'JetBrains Mono';
  src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}
</style><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 - $1 行","copy":"复制"}}</script><link type="text/css" rel="stylesheet" href="/lib/encrypt/hbe.style.css"><script src="//unpkg.com/mermaid@10.5.0/dist/mermaid.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
 menuSettings: {
   zoom: "None"
 },
 showMathMenu: false,
 jax: ["input/TeX","output/CommonHTML"],
 extensions: ["tex2jax.js"],
 TeX: {
   extensions: ["AMSmath.js","AMSsymbols.js"],
   equationNumbers: {
     autoNumber: "AMS"
   }
 },
 tex2jax: {
   inlineMath: [["\\(", "\\)"]],
   displayMath: [["\\[", "\\]"]]
 }
});</script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.woff2") format('woff2');
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
 --dark-background: url('https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg');
 --light-background: url('/img/bk.jpg');
 --theme-encrypt-confirm: '确认'
}</style><script defer src="/js/arknights.js"></script><script defer src="/js/search.js"></script><script defer type="module">import mermaid from '//unpkg.com/mermaid@10.5.0/dist/mermaid.esm.mjs';
window.mermaid = mermaid;
code.paintMermaid();
</script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
  menuSettings: {
    zoom: "None"
  },
  showMathMenu: false,
  jax: ["input/TeX","output/CommonHTML"],
  extensions: ["tex2jax.js"],
  TeX: {
    extensions: ["AMSmath.js","AMSsymbols.js"],
    equationNumbers: {
      autoNumber: "AMS"
    }
  },
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]]
  }
});
</script><script async src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script async src="/lib/encrypt/hbe.js"></script><script async src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js','data-pjax','.busuanzi'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup" tabindex="0"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/Proverb/"><span class="navItemTitle">Proverb</span></a></li><li class="navItem"><a class="navBlock" href="/demo/Arrangement/"><span class="navItemTitle">Arrangement</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1></h1></div><hr><div id="post-content"><h1 id="第一章-计算机系统概述"><a href="#第一章-计算机系统概述" class="headerlink" title="第一章-计算机系统概述"></a>第一章 计算机系统概述</h1>
<h2 id="计算机系统的性能评价"><a href="#计算机系统的性能评价" class="headerlink" title="计算机系统的性能评价"></a>计算机系统的性能评价</h2>
<h3 id="非时间指标"><a href="#非时间指标" class="headerlink" title="非时间指标"></a>非时间指标</h3>
<ul>
<li>机器字长
<ul>
<li>机器一次性能够处理的二进制位数（一般于内部寄存器的位数相等）</li>
</ul></li>
<li>总线宽度
<ul>
<li>数据总线一次能并行传送的最大信息位数</li>
</ul></li>
<li>主存容量与存储带宽
<ul>
<li>容量：一台计算机主存包含的存储单元总数</li>
<li>带宽：单位时间内与贮存你交换的二进制信息量，Byte/s</li>
</ul></li>
</ul>
<h3 id="时间指标"><a href="#时间指标" class="headerlink" title="时间指标"></a>时间指标</h3>
<ul>
<li>主频
<ul>
<li>CPU工作的时钟频率，与CPU运算能力之间<strong>不是</strong>唯一的、直接关系</li>
</ul></li>
<li>时钟周期<span class="math inline">\(T=\frac{1}{f}\)</span>
<ul>
<li>计算机中最基本的、最小的时间单位。一个时钟周期CPU仅完成一个最基本动作</li>
</ul></li>
<li>外频
<ul>
<li>系统总线的工作频率，CPU与主板之间同步运行的速度</li>
</ul></li>
<li>倍频
<ul>
<li><span class="math inline">\(主频=外频 \times 倍频\)</span></li>
</ul></li>
<li>CPI
<ul>
<li>执行一条指令（平均）需要的始终周期数 <span
class="math display">\[CPI = 一段程序中所有指令的始终周期之和/指令条数 =
程序中各类指令的CPI \times 程序中各类指令的比例 \]</span></li>
</ul></li>
<li>MIPS
<ul>
<li><span class="math display">\[ MIPS =  \frac{指令条数}{执行时间
\times 10^6} = \frac{指令条数}{所有指令CPU始终周期数之和/f \times 10^6}
= \frac{f}{CPI \times 10^6} = IPC * f \]</span></li>
<li>程序执行时间
<ul>
<li><span class="math display">\[ T_e = \frac{指令条数}{MIPS \times
10^6} \]</span></li>
</ul></li>
</ul></li>
</ul>
<h1 id="第二章-数据信息的表示"><a href="#第二章-数据信息的表示" class="headerlink" title="第二章-数据信息的表示"></a>第二章 数据信息的表示</h1>
<h2 id="数值数据的表示"><a href="#数值数据的表示" class="headerlink" title="数值数据的表示"></a>数值数据的表示</h2>
<h3 id="数的机器码表示"><a href="#数的机器码表示" class="headerlink" title="数的机器码表示"></a>数的机器码表示</h3>
<ul>
<li>真值： 带正负号的</li>
<li>机器码
<ul>
<li>原码：
<ul>
<li>区间<span class="math inline">\((-2^n, 2^n)\)</span></li>
</ul></li>
<li>反码
<ul>
<li>符号与原码相同，正数与原码相同，负数除符号位其它二进制位取反</li>
</ul></li>
<li>补码
<ul>
<li>正数和原码相同，符号位为0</li>
<li>负数逐位取反，末位加1，符号位为1</li>
<li>特性：
<ul>
<li>唯一0</li>
<li>区间：小数<span class="math inline">\([-1,1)\)</span>，整数<span
class="math inline">\([-2^n, 2^n)\)</span></li>
<li>非对称区间，左侧多一个数</li>
</ul></li>
<li>双符号位补码
<ul>
<li>符号位01表示正溢出，10表示负溢出，最高位表示正确的符号位</li>
</ul></li>
</ul></li>
<li>移码
<ul>
<li><span class="math display">\[ [x]_{mov} = 2^n + x \quad -2^n &lt;= x
&lt;= 2^n \]</span></li>
<li>与补码的符号位相异，数值位相同</li>
</ul></li>
</ul></li>
</ul>
<h3 id="定点数表示"><a href="#定点数表示" class="headerlink" title="定点数表示"></a>定点数表示</h3>
<h4 id="c语言中的整数"><a href="#c语言中的整数" class="headerlink" title="c语言中的整数"></a>C语言中的整数</h4>
<ul>
<li>有符号和无符号共存时无符号优先</li>
<li>整数变量初始化
<ul>
<li>先按照约定处理常量转换成机器码</li>
<li>根据变量长度进行强制转换，超出位数截断</li>
</ul></li>
</ul>
<h3 id="浮点数表示"><a href="#浮点数表示" class="headerlink" title="浮点数表示"></a>浮点数表示</h3>
<ul>
<li>机器字长一定时，阶码越长，表示范围越大，精度越高（规格化）</li>
<li>阶码相同，尾数越长，精度越高</li>
<li>扩大了表示范围，未增加状态数</li>
<li>绝对值越大，浮点数分布越系数，运算不满足结合律</li>
</ul>
<h2 id="数据信息的校验"><a href="#数据信息的校验" class="headerlink" title="数据信息的校验"></a>数据信息的校验</h2>
<h3 id="码距与校验"><a href="#码距与校验" class="headerlink" title="码距与校验"></a>码距与校验</h3>
<ul>
<li>码距： 任意两个合法编码间不同的二进制位数</li>
<li>码距越大，抗干扰能力越、纠错能力越强，数据荣誉越大，编码效率越低</li>
<li>最小码距&gt;=e+1
<ul>
<li>可检测e个错误</li>
</ul></li>
<li>最小码距&gt;=2t+1
<ul>
<li>可纠正t个错误</li>
</ul></li>
<li>最小码距&gt;=e+t+1
<ul>
<li>可纠正t个错误，同时需要检测e个错误</li>
</ul></li>
</ul>
<h3 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h3>
<ul>
<li>奇校验
<ul>
<li>冗余位： 1位，检验位P</li>
<li>编码规则：校验码（数据+校验位）中的1的个数位奇数 <span
class="math display">\[ 偶校验：P = D_1 \oplus D_2 \oplus D_3 \oplus D_4
\oplus D_5 \oplus D_6 \oplus D_7 \oplus D_8 \]</span> <span
class="math display">\[ 奇校验：P = \neg (D_1 \oplus D_2 \oplus D_3
\oplus D_4 \oplus D_5 \oplus D_6 \oplus D_7 \oplus D_8) \]</span> <span
class="math display">\[ 检错码：G = P \oplus D_1 \oplus D_2 \oplus D_3
\oplus D_4 \oplus D_5 \oplus D_6 \oplus D_7 \oplus D_8 \]</span>
G=1：数据一定出错，否则较大概率正常</li>
</ul></li>
</ul>
<h4 id="奇偶校验性能"><a href="#奇偶校验性能" class="headerlink" title="奇偶校验性能"></a>奇偶校验性能</h4>
<p>识别奇数错，不能纠错，不保证正确，实现简单，编码效率高</p>
<h3 id="海明校验"><a href="#海明校验" class="headerlink" title="海明校验"></a>海明校验</h3>
<ul>
<li>多i个就教研组</li>
<li>既能检错，也能纠错</li>
<li>最小码距为3</li>
<li>最低位从1开始</li>
</ul>
<h4 id="可检一位错海明码"><a href="#可检一位错海明码" class="headerlink" title="可检一位错海明码"></a>可检一位错海明码</h4>
<ul>
<li>编码规则：分组交叉就检验法
<ul>
<li>戴编码数据分成r个就校验组</li>
<li>r位校验位（冗余），生成r位检错码</li>
<li>各数据位至少参加2各校验组</li>
<li>一个数据位出错，可导致多个检错码为1</li>
</ul></li>
<li>检错纠错：检错码值表示出错位置（假设一位错）
<ul>
<li>检错码全0，数据大概率正常，最低位是1开始</li>
<li>可检错，也可纠错，将出错位取反即可</li>
</ul></li>
</ul>
<p>(n,k)海明码共n位，其中数据位k位，校验位r位， <span
class="math display">\[ n=k+r &lt;= 2^r -1 \]</span> ####
(n,k)码校验分组设计方法 + 校验码<span
class="math inline">\(P_i\)</span>放置在<span
class="math inline">\(H_{2^i-1}\)</span>索引处 + 数据位放在剩下的位置。
+ <span class="math inline">\(H_i\)</span>的二进制表示的低<span
class="math inline">\(j\)</span>位为1，则<span
class="math inline">\(G_j\)</span>组需要包含<span
class="math inline">\(H_i\)</span> + <span
class="math inline">\(P_i\)</span>负责校验二进制表示的低<span
class="math inline">\(j\)</span>位为1的<span
class="math inline">\(H_j\)</span>的数据 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">eg:<br>  (8,4)码<br>  P3 = H5 ^ H6 ^ H7 ^ H12<br></code></pre></td></tr></table></figure></p>
<h4 id="海明码特点"><a href="#海明码特点" class="headerlink" title="海明码特点"></a>海明码特点</h4>
<ul>
<li>编码效率高</li>
<li>可纠正一位错</li>
<li><strong>在假设没有三位错的情况下，如何区别一位还是两位错</strong>
<ul>
<li>引入总校验位</li>
<li>报错字=1，总校验位=1，一位错。</li>
<li>报错字=1，总校验位=0，两位错。</li>
</ul></li>
</ul>
<h3 id="循环冗余校验"><a href="#循环冗余校验" class="headerlink" title="循环冗余校验"></a>循环冗余校验</h3>
<ul>
<li>编码规则：编码可被生成多项式整除
<ul>
<li>模2除法，余数为0（高概率正确），否则出错</li>
</ul></li>
<li>设CRC码为n位，其中数据位k位，校验位r位
<ul>
<li><span class="math display">\[ n = k + r &lt;= 2^r -1 \]</span></li>
</ul></li>
</ul>
<h4 id="模2运算规则"><a href="#模2运算规则" class="headerlink" title="模2运算规则"></a>模2运算规则</h4>
<p>除法：余数首位为1，商上1，否则为0</p>
<h4 id="crc编码规则"><a href="#crc编码规则" class="headerlink" title="crc编码规则"></a>CRC编码规则</h4>
<ul>
<li>将待编码的k位有效信息位组表达为多项式<span
class="math inline">\(M(x)\)</span>
<ul>
<li><span class="math display">\[ M(x) = b_{k-1}x^{k-1} +
b_{k-2}x^{k-2}+...+b_1x+b_0 \quad x=2 \]</span></li>
</ul></li>
<li>将数据左移r位，空出r位校验（冗余位），变成 <span
class="math inline">\(M(x) \cdot x^r\)</span></li>
<li>将 <span class="math inline">\(M(x) \cdot x^r\)</span>
除以生成多项式<span class="math inline">\(G(x)\)</span>,商为<span
class="math inline">\(Q(x)\)</span>，余数<span
class="math inline">\(R(x)\)</span>
<ul>
<li><span class="math display">\[ M(x) \cdot x^r = Q(x) \cdot G(x) +R(x)
\]</span></li>
</ul></li>
<li>将余数填充在校验位
<ul>
<li><span class="math display">\[ M(x) \cdot x^r + R(x) = Q(x) \cdot
G(x) + R(x) + R(x) = Q(x) \cdot G(x) \]</span></li>
</ul></li>
</ul>
<p>编码规则：CRC编码可被<span
class="math inline">\(G(x)\)</span>表示的编码整除</p>
<p><strong>出错</strong>：<br />
当只有一位错的时候，余数的“1”在第几位，就说明是第几位处所。如余数<code>010000</code>，表示第5位出错。</p>
<h4 id="生成多项式"><a href="#生成多项式" class="headerlink" title="生成多项式"></a>生成多项式</h4>
<ul>
<li>生成多项式特征
<ul>
<li>任意1位发生错误余数均不为0</li>
<li>不同位发生错误余数不同</li>
<li>余数左移一位继续作模2除，应使余数循环，循环周期<span
class="math inline">\(N=k+r\)</span></li>
</ul></li>
<li>如何产生生成多项式
<ul>
<li>(n,k)码，将<span
class="math inline">\(X^n+1\)</span>分解为若干质因子</li>
<li>根据码距要求选择其中的因式或多个因式的成绩为生成多项式</li>
</ul></li>
</ul>
<blockquote>
<p>eg： <span class="math display">\[ x^7+1=(x+1)(x^3+x+1)(x^3+x^2+1)
\]</span> <span class="math inline">\(G(x)\)</span>可以为多种取值<br />
<span class="math inline">\(G(x)=x+1=11\)</span> (7,6)码，判一位错<br />
<span class="math inline">\(G(x)=x^3+x+1=1011\)</span> 或 <span
class="math inline">\(G(x)=x^3+x^2+1\)</span>
(7,4)码，两位错，一位错余数均不为0，但余数有重叠<br />
<span class="math inline">\(G(x)=(x+1)(x^3+x+1)=11101\)</span><br />
如果使用<span class="math inline">\(G(x)=1011\)</span>来编码<br />
<span class="math display">\[ 1100_2 &lt;&lt;3 \div = 1110_2 \quad ...
\quad 010_2 \]</span>
原始数据<code>1100</code>,编码后的数据<code>1100</code>
<code>010</code></p>
</blockquote>
<h4 id="模2除法满足结合律"><a href="#模2除法满足结合律" class="headerlink" title="模2除法满足结合律"></a>模2除法满足结合律</h4>
<ul>
<li>两数的余数异或等于两数异或后的余数
<ul>
<li><span class="math display">\[(M(x) \% G(x)) \oplus (N(x)\%G(x)) =
(M(x) \oplus N(x)) \% G(x) \]</span></li>
</ul></li>
<li>利用模2除法的结合律可以实现并行CRC电路</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">串行CRC</th>
<th style="text-align: left;">并行CRC</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">时序</td>
<td style="text-align: left;">组合</td>
</tr>
<tr class="even">
<td style="text-align: left;">多周期</td>
<td style="text-align: left;">单周期</td>
</tr>
<tr class="odd">
<td style="text-align: left;">慢</td>
<td style="text-align: left;">块</td>
</tr>
<tr class="even">
<td style="text-align: left;">硬件少</td>
<td style="text-align: left;">硬件多</td>
</tr>
</tbody>
</table>
<h4 id="crc-nk码检错性能"><a href="#crc-nk码检错性能" class="headerlink" title="crc-nk码检错性能"></a>CRC (n,k)码检错性能</h4>
<p><span class="math inline">\(r=n-k\)</span></p>
<ul>
<li>所有小于等于r长度的突发错误
<ul>
<li>突发错长度：第一和最后错位之间的距离</li>
</ul></li>
<li><span class="math inline">\((1-2^{-r+1})\)</span>比例的<span
class="math inline">\(r+1\)</span>长度的突发错</li>
<li><span class="math inline">\((1-2^{-r})\)</span>比例的大于<span
class="math inline">\(r+1\)</span>长度的突发错</li>
<li>所有小于最小码距的任意位数的错误</li>
<li>如果生成多项式中1的数目位偶数，可检测所有奇数错</li>
</ul>
<h1 id="第三章-运算方法与运算器"><a href="#第三章-运算方法与运算器" class="headerlink" title="第三章-运算方法与运算器"></a>第三章 运算方法与运算器</h1>
<h2 id="定点加减法运算"><a href="#定点加减法运算" class="headerlink" title="定点加减法运算"></a>定点加减法运算</h2>
<h3 id="溢出及检测"><a href="#溢出及检测" class="headerlink" title="溢出及检测"></a>溢出及检测</h3>
<ul>
<li>单符号数溢出检测1
<ul>
<li>正正得负 负负得正</li>
<li>设量符号位为<span class="math inline">\(f_0\)</span><span
class="math inline">\(f_1\)</span>，和数符号位<span
class="math inline">\(f_s\)</span></li>
<li>溢出检测信号<code>Overflow</code> = <span class="math inline">\(\hat
f_0 \hat f_1 f_s + f_0f_1 \hat f_s\)</span></li>
</ul></li>
<li>单符号溢出检测方法2
<ul>
<li>符号位进位位<span
class="math inline">\(C_f\)</span>，最高位进位位<span
class="math inline">\(C_n\)</span></li>
<li><span class="math inline">\(Overflow=C_f \oplus C_n\)</span></li>
</ul></li>
<li>双符号溢出检测方法
<ul>
<li><span class="math inline">\(01\)</span>正溢出，<span
class="math inline">\(10\)</span>负溢出</li>
</ul></li>
</ul>
<h3 id="加减法的逻辑实现"><a href="#加减法的逻辑实现" class="headerlink" title="加减法的逻辑实现"></a>加减法的逻辑实现</h3>
<h4 id="一位全加器逻辑实现"><a href="#一位全加器逻辑实现" class="headerlink" title="一位全加器逻辑实现"></a>一位全加器逻辑实现</h4>
<p><span class="math display">\[ S_i = X_i \oplus Y_i \oplus C_i
\]</span> <span class="math display">\[ C_{i+1} = X_i Y_i + (X_i \oplus
Y_i) C_i \]</span> 得到<span
class="math inline">\(C_{i+1}\)</span>五级门电路延迟，得到<span
class="math inline">\(S_i\)</span>六级门电路延迟</p>
<h4 id="减法的球阀"><a href="#减法的球阀" class="headerlink" title="减法的球阀"></a>减法的球阀</h4>
<p>引入运算控制位<code>Sub</code>
<code>Sub</code>=1时候做减法，送入加法器的是<span
class="math inline">\([-Y_{补}]\)</span> <span class="math display">\[
Input = Y_i \oplus Sub\]</span></p>
<h4 id="串行加法器时延"><a href="#串行加法器时延" class="headerlink" title="串行加法器时延"></a>串行加法器时延</h4>
<p>获得<span class="math inline">\(C_n\)</span>的时间<span
class="math inline">\((2n+3)T\)</span>，获得<span
class="math inline">\(S_{n-1}T\)</span>的时间<span
class="math inline">\((2n+4)T\)</span>，获得<code>overflow</code>需要<span
class="math inline">\((2n+6)T\)</span></p>
<h4 id="并行加法器"><a href="#并行加法器" class="headerlink" title="并行加法器"></a>并行加法器</h4>
<p><span class="math display">\[ G_i = X_i Y_i \qquad P_i = X_i \oplus
Y_i \]</span> <span class="math display">\[ C_{i+1} = G_i + P_i C_i
\]</span> <span class="math display">\[ C_n = G_{n-1}+P_{n-1}G_{n-2} +
P_{n-1}P_{n-2}G_{n-3}+...+P_{n-1}P_{n-2}...P_1P_0C_0 \]</span> +
进位输出仅与最低位进位输入<span class="math inline">\(C_0\)</span>有关 +
位数预测长，进位链电路复杂度越高 + 通常按照<em>4位一组</em>进行分组运算
+ <span class="math display">\[ C_4 = G_3 +
P_3G_2+P_3P_2G_1+P_3P_2P_1G_0+P_3P_2P_1P_0C_0 \]</span> +
生成、传递函数电路就是普通的与门、异或门阵列，可以并行输出所有<span
class="math inline">\(G_i\)</span><span
class="math inline">\(P_i\)</span>的值，3级门电路延迟 +
并行进位电路2级门电路延迟 +
进位信号得到后，求和值需要一级异或门延迟3T即可完成 +
4个一组时，最高位进位<span class="math inline">\(C_4\)</span>延迟<span
class="math inline">\(5T\)</span>，结果<span
class="math inline">\(S_i\)</span>延迟<span
class="math inline">\(8T\)</span> +
16位加法器，组内先行进位，组间串行进位，获得结果延迟<span
class="math inline">\(14T\)</span>,获得最高位进位延迟<span
class="math inline">\(11T\)</span> #### 成组进位生成&amp;传递函数 <span
class="math display">\[ P^{*} = P_3P_2P_1P_0 \]</span> <span
class="math display">\[ G_{*} = G_3 + P_3G_2 + P_3P_2G_1 + P_3P_2P_1G_0
\]</span> <span class="math display">\[ C_4 = G^{*} + P^{*}C_0
\]</span></p>
<p>16位先行进位<br />
生成<span class="math inline">\(P^{*},G^{*}\)</span>只需<span
class="math inline">\(5T\)</span><br />
生成<span class="math inline">\(C_{12}\)</span>只需<span
class="math inline">\(2T\)</span><br />
计算进位<span class="math inline">\(2T\)</span>,求和<span
class="math inline">\(3T\)</span><br />
总共12级门电路延迟</p>
<p>64位先行进位 --&gt; 16级门电路延迟 ## 定点乘法运算 #### 原码乘法运算
<span class="math display">\[ [X \times Y]_{原} = X \times
[Y_12^{-1}+Y_22^{-2}+...+Y_n2^{-n}] \]</span> 从<span
class="math inline">\(Y\)</span>的最低位开始；<span
class="math inline">\(\sum\)</span>从0开始采用双符号位；<span
class="math inline">\(X\)</span>也采用双符号位；根据<span
class="math inline">\(Y_i\)</span>的值判断是加<span
class="math inline">\(X\)</span>还是加0。加完以后<span
class="math inline">\(\sum\)</span>,<span
class="math inline">\(X\)</span>,<span
class="math inline">\(Y\)</span>都逻辑右移。<span
class="math inline">\(\sum\)</span>可能瞬间溢出，但是移位后正常。最终结果是<span
class="math inline">\(\sum\)</span>加上移出的部分。 #### 补码一位乘法
<span class="math display">\[ [X \times Y]_{补} = [X]_{补} \times
0.Y_1Y_2...Y_n - Y_0[X]_{补} \]</span> <span class="math display">\[ =
[X]_{补} \times
[Y_1-Y_0+(Y_2-Y_1)2^{-1}+(Y_3-Y_2)2^{-2}+...(0-Y_n)2^{-n}] \]</span>
大概类似原码乘法，也<span class="math inline">\(\sum\)</span>和<span
class="math inline">\(X\)</span>也使用双符号位，但是在判断<span
class="math inline">\(\sum\)</span>是加什么出，如果<span
class="math inline">\(Y_nY_{n+1}\)</span>为10，则<span
class="math inline">\(\sum +-[-X]_{补}\)</span>;若<span
class="math inline">\(Y_nY_{n+1}\)</span>为01，<span
class="math inline">\(\sum +=
[X]_{补}\)</span>;其它情况则+0.右移仍然照做。</p>
<p class='item-img' data-src='整理/补码乘法.png'><img src="整理/补码乘法.png" alt="补码乘法" /> 上面的右移是算数右移！
#### 阵列乘法器 横向进位乘法器<br />
延迟会比斜向进位乘法器更高，但是设计简单。<br />
两个五位数乘法，横向乘法进位器时延39T，但是斜向进位乘法进位器时延37T</p>
<p>斜向进位乘法器 + 总共<span
class="math inline">\(n*(n-1)\)</span>个全加器 + <span
class="math inline">\((n-1) FA +
(2(n-1)+4)T+T\)</span>，其中<code>FA</code>是全加器 + <span
class="math inline">\((8n-3)T\)</span>的时延</p>
<h4 id="整数的乘运算"><a href="#整数的乘运算" class="headerlink" title="整数的乘运算"></a>整数的乘运算</h4>
<ul>
<li>硬件不判断溢出，保留2n位成绩，供软件使用</li>
<li>程序不判断溢出，编译器也不生成用于溢出处理的代码，会发生整数溢出问题</li>
</ul>
<h2 id="定点除法运算"><a href="#定点除法运算" class="headerlink" title="定点除法运算"></a>定点除法运算</h2>
<h4 id="恢复余数的除法"><a href="#恢复余数的除法" class="headerlink" title="恢复余数的除法"></a>恢复余数的除法</h4>
<p>被除数和除数都使用双符号位，先尝试减除数。如果余数小于0，则再加回余数，商为0。否则商为1.余数左移，然后再减除数。</p>
<p>最后获得的余数是放大了的，商有几位，余数就需要乘<span
class="math inline">\(2^{-n}\)</span>。 #### 不恢复余数的除法 +
第一次一定做减法 + 商<span class="math inline">\(Q_n =
~R_0\)</span>（余数符号位） + <span
class="math inline">\(R=(R+(-1)^{Q_n}Y)*2\)</span> +
最后仍然要余数缩小</p>
<p>原码阵列除法器</p>
<p><code>FA</code>加上加减控制变成“可控制加、减法单元”<code>CAS</code>，时延9T<br />
原码阵列除法器需要n*n个<code>CAS</code>,时延<span
class="math inline">\(n*n*9T\)</span> ## 浮点运算
浮点计算步骤：对阶、尾数运算、规格化、舍入、溢出判断 + 对阶 + 小阶对大阶
尾数右移 + 运算结果规格化 + 目的：保证浮点数的编码唯一性 +
形式：尾数非0时，要求绝对值&gt;=0.5，尾数MSB=1.否则修改阶码并移动尾数，使其满足要求
+ 右规：右移实现规格化，阶码+ + 左规：左移实现规格化，阶码-</p>
<h4 id="精度问题"><a href="#精度问题" class="headerlink" title="精度问题"></a>精度问题</h4>
<p>IEEE754在结果右边增加2个附加位 + 保护位Guard：在最低有效位右边的位 +
舍入位Round：在保护位右边的位</p>
<h3 id="浮点数乘法运算"><a href="#浮点数乘法运算" class="headerlink" title="浮点数乘法运算"></a>浮点数乘法运算</h3>
<ol type="1">
<li>阶码相加</li>
</ol>
<ul>
<li>阶码相加可能产生溢出，要进行溢出判断</li>
</ul>
<ol start="2" type="1">
<li>尾数相乘</li>
</ol>
<ul>
<li>尾数相乘可得到积的尾数，可按定点乘法运算方法运算</li>
</ul>
<ol start="3" type="1">
<li>结果规格化</li>
</ol>
<h3 id="浮点数除法运算"><a href="#浮点数除法运算" class="headerlink" title="浮点数除法运算"></a>浮点数除法运算</h3>
<ol type="1">
<li>尾数调整</li>
</ol>
<ul>
<li>如果被除数尾数大于除数尾数（绝对值），则将被除数尾数右移一位，阶码+1</li>
</ul>
<ol start="2" type="1">
<li>阶码求差</li>
</ol>
<ul>
<li>商的阶码等于被除数的阶码减去除数的阶码</li>
</ul>
<ol start="3" type="1">
<li>尾数相除</li>
</ol>
<h2 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h2>
<h3 id="运算器功能"><a href="#运算器功能" class="headerlink" title="运算器功能"></a>运算器功能</h3>
<ul>
<li>算数运算和逻辑运算
<ul>
<li>运算电路</li>
</ul></li>
<li>暂存运算数据以及中间结果
<ul>
<li>暂存器，通用寄存器</li>
</ul></li>
<li>选取数据参与运算
<ul>
<li>多路选择、数据通路</li>
</ul></li>
<li>反应运算处理的状态
<ul>
<li>程序状态字</li>
</ul></li>
</ul>
<h3 id="运算器与总线结构"><a href="#运算器与总线结构" class="headerlink" title="运算器与总线结构"></a>运算器与总线结构</h3>
<p>单总线结构的时候，完成一次<code>ADD R0, R1</code>,需要3个时钟周期。<br />
分别是传入第一个操作数，传入第二个操作数，写回结果。</p>
<p>双总线+1个锁存器，2个时钟周期。<br />
第一个周期取第一个操作数放到锁存器中。第二个周期传入第二个操作数以后获得结果就可以立刻写回了。因为第二个操作数走的总线是单独的。但是第一个操作数和写回结果走的总写是一条。</p>
<p>也可以第一个操作数和第二个操作数在第一个周期就同时传入ALU，但是结果先写到锁存器中。等第二个周期再写回通用寄存器中。</p>
<h1 id="第四章-存储系统"><a href="#第四章-存储系统" class="headerlink" title="第四章-存储系统"></a>第四章 存储系统</h1>
<h2 id="存储器概述不重要"><a href="#存储器概述不重要" class="headerlink" title="存储器概述不重要"></a>存储器概述（不重要）</h2>
<ul>
<li>按存取方式分
<ul>
<li>随机存储器
<ul>
<li>存取时间与物理位置无关</li>
<li>磁芯、半导体存储器</li>
</ul></li>
<li>顺序存储器
<ul>
<li>存取内容只能按地址顺序访问</li>
<li>磁带</li>
</ul></li>
<li>直接存储器
<ul>
<li>不必顺序访问，但是存取时间与物理位置有一定关系</li>
<li>磁盘（机械硬盘）、激光存储器</li>
<li>因为它自己可以寻址</li>
</ul></li>
</ul></li>
</ul>
<h2 id="半导体存储器"><a href="#半导体存储器" class="headerlink" title="半导体存储器"></a>半导体存储器</h2>
<h4 id="存储器的刷新"><a href="#存储器的刷新" class="headerlink" title="存储器的刷新"></a>存储器的刷新</h4>
<ul>
<li>集中刷新
<ul>
<li>刷新周期：2ms</li>
<li>在数据丢失之前集中刷新所有行</li>
<li>存在死区，用在实时要求不高的场合</li>
</ul></li>
<li>分散刷新
<ul>
<li>最大刷新周期：2ms</li>
<li>存储周期：读写+刷新，各刷新周期分散安排在存取周期中</li>
<li>刷新次数 2ms/100ns=20000次，比较浪费，用在低速系统中</li>
</ul></li>
<li>异步刷新
<ul>
<li>刷新周期：2ms，各刷新周期分散安排在2ms内</li>
<li>每隔2ms/128=15.5微妙刷新一行，将128次刷新分散</li>
<li>最常用</li>
</ul></li>
</ul>
<h3 id="半导体存储器的对比"><a href="#半导体存储器的对比" class="headerlink" title="半导体存储器的对比"></a>半导体存储器的对比</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">SRAM</th>
<th style="text-align: left;">DRAM</th>
<th style="text-align: left;">ROM</th>
<th style="text-align: left;">PROM</th>
<th style="text-align: left;">EPROM</th>
<th style="text-align: left;">EEPROM</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">MOS管</td>
<td style="text-align: left;">电容</td>
<td style="text-align: left;">开关</td>
<td style="text-align: left;">熔丝</td>
<td style="text-align: left;">浮置栅</td>
<td style="text-align: left;">浮置栅</td>
</tr>
<tr class="even">
<td style="text-align: left;">快</td>
<td style="text-align: left;">慢</td>
<td style="text-align: left;">只读</td>
<td style="text-align: left;">写一次</td>
<td style="text-align: left;">高压写入</td>
<td style="text-align: left;">高压写入</td>
</tr>
<tr class="odd">
<td style="text-align: left;">6MOS</td>
<td style="text-align: left;">1MOS+1C</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">紫外线擦</td>
<td style="text-align: left;">控制栅极</td>
</tr>
<tr class="even">
<td style="text-align: left;">功耗高</td>
<td style="text-align: left;">价格便宜</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">离线擦除</td>
<td style="text-align: left;">在线电擦</td>
</tr>
<tr class="odd">
<td style="text-align: left;"></td>
<td style="text-align: left;">动态刷新</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;">擦后写</td>
<td style="text-align: left;">擦后写</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;">行列分开</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
<h2 id="主存的组织以及"><a href="#主存的组织以及" class="headerlink" title="主存的组织以及"></a>主存的组织以及</h2>
<h3 id="存储器扩展"><a href="#存储器扩展" class="headerlink" title="存储器扩展"></a>存储器扩展</h3>
<ul>
<li>字长扩展（数据总线扩展）
<ul>
<li>各芯片并行工作</li>
</ul></li>
<li>字数扩展（地址总线扩展）
<ul>
<li>同一时刻仅一芯片工作 #### 字长扩展(DBUG)
存储系统位宽N位，若使用k位芯片，k&lt;N,需要(N/k)个芯片 ####
字数扩展(ABUS)
存储系统容量位M，若使用容量为I的芯片，I&lt;M，需要（M/I）个芯片 ####
综合扩展 存储系统<span class="math inline">\(M*N\)</span>位，若使用<span
class="math inline">\(I*k\)</span>位芯片，<span
class="math inline">\(I&lt;M,k&lt;N\)</span>,需要<span
class="math inline">\((M/I)*(N/k)\)</span>个芯片</li>
</ul></li>
</ul>
<p><em>（大概是懂了这个类型的连线题怎么玩了）</em> ## 并行主存系统
CPU与存储器之间的速度无法匹配 + 解决方法 + 增加Cache(行缓冲) +
采用高速器件提高速度 + 采用双端口存储器 +
增加字长，单个存储周期存取多个字 + 将主存划分为多个模块，多模块并行</p>
<ul>
<li>多模块顺序存储器（存储扩展）
<ul>
<li>一个地址寄存器</li>
<li>高位片选，多模块串行</li>
<li>扩容方便</li>
<li>性能无提升</li>
<li>方便故障隔离</li>
</ul></li>
<li>多模块交叉存储器
<ul>
<li>模块并行工作</li>
<li>CPU比存储器要快</li>
<li>能同时取出多条指令或者数据</li>
<li>扩容、提速</li>
</ul></li>
</ul>
<h2 id="高速缓冲存储器"><a href="#高速缓冲存储器" class="headerlink" title="高速缓冲存储器"></a>高速缓冲存储器</h2>
<h3 id="cache写操作流程"><a href="#cache写操作流程" class="headerlink" title="cache写操作流程"></a>cache写操作流程</h3>
<ul>
<li>写穿策略
<ul>
<li>无脏数据，无丢失数据风险，写速度慢</li>
</ul></li>
<li>写回策略
<ul>
<li>存在脏数据，有丢失数据风险，突发写速度快，持续写性能 ###
cache的基本概念</li>
</ul></li>
<li>命中：CPU访问数据在cache中（上层快存）</li>
<li>缺失：CPU访问数据不再cache中</li>
<li>块：cache与主存交换最小单位</li>
<li>行/槽 Line/Slot：标记、标志位、数据块容器
<ul>
<li>有效位、查找标记、脏标志位、置换标志、数据块副本</li>
</ul></li>
<li>命中率、缺失率</li>
<li>命中访问时间
<ul>
<li>数据查找时间、cache访问时间、总线传输时间</li>
</ul></li>
<li>缺失损失
<ul>
<li>主存块调入cache，数据传输到处理器的时间</li>
<li>远大于命中时间，所以一些相对较小的时间可以忽略</li>
</ul></li>
<li>数据替换：cache满了以后进行替换</li>
<li>脏数据逐出：当一个cache已经被修改过，必须得写回到下一级存储器，才可以丢弃。</li>
</ul>
<h3 id="cache读写流程"><a href="#cache读写流程" class="headerlink" title="cache读写流程"></a>cache读写流程</h3>
<ul>
<li>CPU cache系统读过程
<ul>
<li>CPU给出主存地址（块地址，块内地址）</li>
<li>主存块地址为关键字进行查找</li>
<li>如相符表示副本在cache中，命中，访问cahce</li>
<li>否则数据缺失，访问主存
<ul>
<li>将数据所在块副本调入cache（块交换--局部性）</li>
<li>载入副本过程可能引起替换（时间长）</li>
<li>更新查找表，记录当前数据块地址</li>
<li>cache缺失时CPU只能挂起等待</li>
</ul></li>
</ul></li>
<li>CPU cache系统写过程
<ul>
<li>CPU给出主存地址</li>
<li>主存块地址为关键字进行查找
<ul>
<li>相符则表示命中，数据副本在cache中</li>
<li>缺失根据写分配策略决定是否将该主存地址对应数据块调入</li>
</ul></li>
<li>写入数据到cache</li>
<li>根据写策略决定是否写入主存</li>
</ul></li>
</ul>
<h3 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h3>
<h4 id="数据查找"><a href="#数据查找" class="headerlink" title="数据查找"></a>数据查找</h4>
<h5 id="相联存储器"><a href="#相联存储器" class="headerlink" title="相联存储器"></a>相联存储器</h5>
<ul>
<li>按内容进行访问(key, value)
<ul>
<li>以关键字作全局全局并发比较，硬件成本高（比较器多）</li>
<li>片外cache用于存放查找表</li>
<li>片外cache村南方查找表+数据副本</li>
<li>虚拟存储器中存放段表、页表</li>
</ul></li>
<li>存储容量=查找表/相联存储器容量=表项数*表项大小
<ul>
<li>(valid, key, value)</li>
<li>(有效位，主存块地址，cache块地址) （片外cache，存放查找表）</li>
<li>(有效位，主存块地址，cache块数据)
（片内cache，存放查找表+数据副本）</li>
<li>(有效位， VPN, PPN)（虚拟存储器页表）</li>
</ul></li>
</ul>
<p>CPU cache基本组织方式 + CPU cache由SRAM构成 +
cache与主存均分为固定大小的数据块，以块为单位交换数据 +
相联存储器存放查找表/cache +
表项：（有效位，调入cache的主存块地址，cache块地址/块数据） +
容量=cache块数*表项大小 +
CPU给出的块地址与查找表中某单元相同且有效位为1表示命中</p>
<p>相连存储器容量 + 查找表和缓存副本一体（CPU片内缓存） + 存放cache行 +
有效位，主存块地址，数据块副本，标志位（dirty bit），置换标记 +
存储容量=cache行大小<em>行数 +
查找表和缓存副本分离（片内查找表，片外缓存） + 存放查找信息 +
有效位，主存块地址，cache块地址，标志位（dikrty bit），置换标记 +
存储容量=查找表表项大小</em>行数 #### 地址映射 ##### 全相连映射
主存块可放置在任意cache行</p>
<p>cache8行，块大小4W，主存<span
class="math inline">\(2^9\)</span>W，cache总容量=(valid+查找标记+脏位+置换标记位+数据块副本容量)*总行数</p>
<p>应用场合 + 块映射灵活，一对多映射 + cache满后才会出现块冲突 +
块冲突概率低，cache利用率高 + 淘汰算法复杂 + 命中率高</p>
<h5 id="直接相连映射"><a href="#直接相连映射" class="headerlink" title="直接相连映射"></a>直接相连映射</h5>
<p>cache块号i，供n块，主存块号j，i=j mod n</p>
<p>cache8行，块大小4W，主存<span
class="math inline">\(2^9\)</span>W，cache总容量=(valid+查找标记位+标志位+数据块副本容量)*总行数</p>
<p>在全相连映射中，主存地址被解释为：区地址（tag）+行地址（索引，区内块偏移）+块内偏移</p>
<p>直接相连应用场合 + 映射速度块，一对一映射，无需查表 +
利用索引字段直接对比响应标记位即可 +
查找表可以和副本一起存放，无需相联存储器 + 容易冲突，cache利用率低 +
替换算法简单 + 命中率低，适合大容量cache</p>
<h5 id="组相连存储器硬件开销"><a href="#组相连存储器硬件开销" class="headerlink" title="组相连存储器硬件开销"></a>组相连存储器硬件开销</h5>
<ul>
<li>SRAM
<ul>
<li>存放数据副本</li>
</ul></li>
<li>多个先练存储器共享一个多路比较器
<ul>
<li>相对于全相连，多路比较器复杂度低</li>
<li>查找表表项内容（valid位，dirty位，查找标记，置换标记位）</li>
<li>相联存储器总容量
<ul>
<li>cache行数*（1+1+查找标记位宽度+置换标记位）</li>
</ul></li>
</ul></li>
<li>片外缓存如果查找表在CPU内部
<ul>
<li>查找表中必须增加cache行地址</li>
</ul></li>
</ul>
<p>cache8行，块大小4W，主存<span
class="math inline">\(2^9\)</span>W，cache总容量=(valid+查找标记+脏位+置换标记位+数据块副本容量)*总行数</p>
<p>组相连映射中，主存地址被解释为：标记+组索引+块内偏移</p>
<p>组相连应用场合 + 小容量cache可采用全相连映射或组相连映射 +
大容量cache可采用直接映射方式 + 查找速度块，命中率相对低 +
但cache容量大可提高命中率 + 块设备缓存</p>
<h4 id="替换策略"><a href="#替换策略" class="headerlink" title="替换策略"></a>替换策略</h4>
<ul>
<li>先进先出FIFO
<ul>
<li>可能会产生颠簸，不停的出和入</li>
</ul></li>
<li>最不经常使用算法LFU
<ul>
<li>为缓存中的每一个数据记录是否被使用过，当需要替换的时候把使用次数最少的扔出去</li>
</ul></li>
<li>近期最久未使用算法LRU
<ul>
<li>记录缓存中每个数据进入缓存的时间，如果hit了就归零重新记录，需要替换的时候把时间最久的扔出去</li>
</ul></li>
</ul>
<h4 id="写入策略"><a href="#写入策略" class="headerlink" title="写入策略"></a>写入策略</h4>
<ul>
<li>写回法</li>
<li>写穿法</li>
<li>写分配</li>
<li>写不分配</li>
</ul>
<h3 id="cache对存储系统性能的影响"><a href="#cache对存储系统性能的影响" class="headerlink" title="cache对存储系统性能的影响"></a>cache对存储系统性能的影响</h3>
<ul>
<li>读优化
<ul>
<li>时间局部性
<ul>
<li>将刚访问的数据调度到cache中，利用淘汰算法将不经常使用的数据淘汰</li>
</ul></li>
<li>空间局部性
<ul>
<li>大块预读，相邻的数据被调度到cache中</li>
</ul></li>
</ul></li>
<li>写优化
<ul>
<li>写回策略提升突发写性能</li>
</ul></li>
<li>负面影响
<ul>
<li>写回策略引起不一致性</li>
<li>缓冲区满以后，写性能降低</li>
</ul></li>
</ul>
<h3 id="cache命中率"><a href="#cache命中率" class="headerlink" title="cache命中率"></a>cache命中率</h3>
<ul>
<li>命中率
<ul>
<li><span
class="math inline">\(N_c\)</span>表示cache完成存取访问的总次数</li>
<li><span
class="math inline">\(N_m\)</span>表示主存完成存取访问的总次数</li>
<li><span class="math inline">\(h=|frac{N_c}{N_c+N_m}\)</span></li>
</ul></li>
<li><span class="math inline">\(t_a\)</span>表示平均访问时间
<ul>
<li><span
class="math inline">\(t_c\)</span>表示命中cache时的访问时间</li>
<li><span
class="math inline">\(t_m\)</span>表示命中主存时的访问时间</li>
<li><span class="math inline">\(t_a=ht_c+(1-h)t_m\)</span></li>
</ul></li>
<li>访问效率=<span class="math inline">\(\frac{t_c}{t_a}\)</span></li>
<li>影响命中率的几个因素
<ul>
<li>程序行为（局部性）</li>
<li>cache容量</li>
<li>组织方式</li>
<li>块大小 ## 虚拟存储器 &gt;
为什么cache访问的时候使用的是物理地址而不是虚拟地址？ &gt;
每个进程都使用相同的虚拟地址空间，不同进程相同虚拟地址对应的物理数据是不一样的，无法使用虚拟地址去cache中查找，导致不同进程切换时候可能会切换cache</li>
</ul></li>
</ul>
<h3 id="虚拟地址到物理地址"><a href="#虚拟地址到物理地址" class="headerlink" title="虚拟地址到物理地址"></a>虚拟地址到物理地址</h3>
<p>当CPU要访问一个地址的时候，把虚拟地址给到MMU，MMU计算出PTEA以后给cache
memeory（页表），获得对应的PTE，如果页命中，则MMU再把PA送给页表，页表取出对应物理地址处的数据送给CPU。如果页不命中，MMU抛出异常，等却也异常处理成功以后，程序会唤醒一场指令所在进程，重新再调用一次。</p>
<h3 id="使用tlb提高速度"><a href="#使用tlb提高速度" class="headerlink" title="使用tlb提高速度"></a>使用TLB提高速度</h3>
<p>MMU直接把VPN到TLB中查找，如果查找成功直接可以获得对应VA的PPN，然后根据PPN得到PA，发给页表让页表把对应数据给CPU</p>
<h1 id="第五章-指令系统"><a href="#第五章-指令系统" class="headerlink" title="第五章-指令系统"></a>第五章 指令系统</h1>
<h2 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h2>
<ul>
<li>操作码OP与地址码AC
<ul>
<li>操作码字段长度决定指令系统规模
<ul>
<li>每条指令对应一个操作码</li>
<li>定长操作码<span
class="math inline">\(Length_{OP}=[log_2n]\)</span></li>
<li>变长操作码 操作码向不用的地址码字段扩展</li>
</ul></li>
<li>操作数字段可能有多个
<ul>
<li>寻址方式字段 可能隐含在操作码字段</li>
<li>地址码字段 &gt; 扩展操作码的条数的计算： &gt;
指令长度32位，操作数12位，剩下可以给操作码，双操作数、单操作数和无操作数
&gt; 若双操作数有k条指令 &gt; 单操作数<span
class="math inline">\((2^8-k)\times2^{12}\)</span>，<span
class="math inline">\(2^{12}\)</span>是多余的12位组合 ## 寻址方式 ###
指令寻址 #### 顺序寻址 程序对应的机器指令序列在主存顺序存放。
执行时从第一条指令开始，逐条取出并执行。</li>
</ul></li>
</ul></li>
<li>实现方式
<ul>
<li>程序计数器对指令序号进行计数</li>
<li>PC存放吓一跳哈子i了那个地址,初始值为程序首地址</li>
<li>执行一跳指令,PC=PC+当前指令字节长度 #### 跳跃寻址
当程序中出现分支或循环时,就会改变程序的执行顺序</li>
</ul></li>
<li>吓一跳指令地址不是PC++得到,而是由指令本身给出</li>
<li>跳跃的处理方式是重新修改PC的内容,然后进入取指令阶段</li>
</ul>
<h3 id="操作数寻址"><a href="#操作数寻址" class="headerlink" title="操作数寻址"></a>操作数寻址</h3>
<ul>
<li>立即寻址
<ul>
<li>地址码字段是操作数本身(相当于不用寻址,直接就是操作数)</li>
</ul></li>
<li>直接寻址</li>
<li>间接寻址
<ul>
<li>需要两次访存,速度慢,已经淘汰</li>
</ul></li>
<li>寄存器寻址</li>
<li>寄存器间接寻址</li>
<li>相对寻址 PC+X</li>
<li>基址/变址寻址 ，
<code>MOV  DX, D[EBP] （E = (EBP)*16 +D）</code></li>
<li>复合寻址</li>
</ul>
<h4 id="硬件堆栈"><a href="#硬件堆栈" class="headerlink" title="硬件堆栈"></a>硬件堆栈</h4>
<p>栈顶不动,数据移动,也能保证栈的结构</p>
<h3
id="x86系列支持多种寻址方式的意义">x86系列支持多种寻址方式的意义</h3>
<ul>
<li>访问更大的存储空间</li>
<li>访问更大的数据</li>
<li>方便程序设计</li>
<li>提高指令执行速度（？）</li>
</ul>
<h2 id="指令格式设计"><a href="#指令格式设计" class="headerlink" title="指令格式设计"></a>指令格式设计</h2>
<ul>
<li>根据指令规模以及是否支持操作码扩展,确定操作码字段长度</li>
<li>根据对操作数的要求确定地址码字段的个数</li>
<li>根据寻址方式的要求,为各地址码字段确定寻址方式字段长度</li>
<li>定长还是变长</li>
</ul>
<h2 id="cisc与risc"><a href="#cisc与risc" class="headerlink" title="cisc与risc"></a>CISC与RISC</h2>
<h3 id="risc"><a href="#risc" class="headerlink" title="risc"></a>RISC</h3>
<ul>
<li>指令条数少,只保留使用频率最高的简单指令,指令定长
<ul>
<li>便于硬件实现,用软件实现复杂指令功能</li>
</ul></li>
<li>Load/Store架构
<ul>
<li>只有存/取数指令才能访问存储器,区域指令的操作数都在寄存器之间进行</li>
<li>便于硬件实现</li>
</ul></li>
<li>指令长度固定,指令格式简单、 寻址方式简单
<ul>
<li>便于硬件实现</li>
</ul></li>
<li>寄存器数量多
<ul>
<li>便于编译器实现</li>
</ul></li>
<li>一个机器周期完成一条机器指令</li>
<li>RISCCPU采用硬布线控制,CISC采用微程序 ## 指令系统举例 ###
MIPS32指令格式</li>
<li>R型指令
<ul>
<li>操作码(6)+源寄存器1(5)+源寄存器2(5)+目的寄存器(5)+偏移位移量(5)+扩展操作码(6)</li>
<li>无寻址方式字段,隐藏在操作码字段中</li>
</ul></li>
<li>I型指令
<ul>
<li>OP(6)+<span class="math inline">\(R_s\)</span>(5)+<span
class="math inline">\(R_t\)</span>(5)+Imm(16)</li>
</ul></li>
<li>J型指令
<ul>
<li>OP(6)+Imm(26)</li>
</ul></li>
</ul>
<h1 id="第六章-中央处理器"><a href="#第六章-中央处理器" class="headerlink" title="第六章-中央处理器"></a>第六章 中央处理器</h1>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2>
<ul>
<li>CPU的主要功能(取指令并执行指令的部件)
<ul>
<li>运算器
<ul>
<li>数据加工:算数/逻辑运算</li>
</ul></li>
<li>控制器
<ul>
<li>程序控制:程序中指令执行顺序控制</li>
<li>操作控制:将机器指令翻译成执行部件所需操作控制信号</li>
<li>时序控制:控制操作信号产生的时间、持续时间</li>
<li>异常控制:异常处理、外设交互</li>
</ul></li>
</ul></li>
<li>CPU中重要寄存器
<ul>
<li>PC--程序计数器</li>
<li>IR--指令寄存器(optional)</li>
<li>AR--地址寄存器(optional)</li>
<li>DR--数据缓冲寄存器(optional)</li>
<li>AC--累加寄存器(optional)</li>
<li>PSW--程序状态字(optional)</li>
</ul></li>
<li>操作控制器
<ul>
<li>输入:机器指令</li>
<li>输出:控制信号序列</li>
<li>功能:循环取指、执行、处理异常
<ul>
<li>将机器指令译码并生成执行部件所需的控制信号序列,控制信号按序传送至各个执行部件控点,引起逻辑门开闭,建立正确的数据通路,从而完成指令功能</li>
</ul></li>
<li>控制器分类
<ul>
<li>应布线控制器(时序逻辑型)(硬件实现)</li>
<li>微程序控制器(存储程序型)(软件实现)</li>
</ul></li>
</ul></li>
</ul>
<h2 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h2>
<h3 id="指令执行一般流程"><a href="#指令执行一般流程" class="headerlink" title="指令执行一般流程"></a>指令执行一般流程</h3>
<p>取指令(PC++)-&gt;指令译码-&gt;操作数地址计算-&gt;取操作数-&gt;数据操作指令执行-&gt;操作数地址计算-&gt;存操作数-&gt;(无中断)取指令<br />
有中断,就等待中断响应,然后再取指令</p>
<h3 id="指令周期基本概念"><a href="#指令周期基本概念" class="headerlink" title="指令周期基本概念"></a>指令周期基本概念</h3>
<ul>
<li>时钟周期=节拍脉冲=震荡周期 能够完成一次微操作</li>
<li>机器周期 = CPU周期 从贮存读出一跳指令的最短时间 可完成复杂操作</li>
<li>指令周期:从贮存取一跳指令并执行指令的时间
<ul>
<li>取指令周期、执行指令周期 (间址周期、中断周期)</li>
<li>执行周期包含n个机器周期,机器周期包含k个节拍</li>
</ul></li>
</ul>
<h2 id="数据通路及指令操作流程"><a href="#数据通路及指令操作流程" class="headerlink" title="数据通路及指令操作流程"></a>数据通路及指令操作流程</h2>
<ul>
<li>数据通路--执行部件间传送信息的路径(数据流)
<ul>
<li>通路的建立由控制信号控制,受时钟驱动(控制流)</li>
<li>不同指令、同一指令在执行的不同阶段的数据通路不同</li>
<li>共享通路(总线)、专用通路
<ul>
<li>指令执行流程、执行效率</li>
<li>微操作控制信号的时序安排</li>
</ul></li>
</ul></li>
</ul>
<h4 id="d触发器定时模型"><a href="#d触发器定时模型" class="headerlink" title="d触发器定时模型"></a>D触发器定时模型</h4>
<ul>
<li>时钟触发前输入需要稳定一段时间(建立时间) setup time</li>
<li>时钟触发后输入需要稳定一段时间(保持时间) hold time</li>
<li>时钟触发到输出稳定的时间(触发器延迟) Clk_to_Q</li>
</ul>
<blockquote>
<p>时钟周期&gt;Clk_to_Q+关键路径时延+Setup time
Clk_to_Q+最短路径时延&gt;Hold time</p>
</blockquote>
<h2 id="时序与控制"><a href="#时序与控制" class="headerlink" title="时序与控制"></a>时序与控制</h2>
<h3 id="中央处理器时序"><a href="#中央处理器时序" class="headerlink" title="中央处理器时序"></a>中央处理器时序</h3>
<h4 id="传统三级时序"><a href="#传统三级时序" class="headerlink" title="传统三级时序"></a>传统三级时序</h4>
<ul>
<li>状态周期、节拍点位、节拍脉冲</li>
<li>状态周期数、节拍点位数、节拍脉冲数可变</li>
</ul>
<h3 id="控制方式"><a href="#控制方式" class="headerlink" title="控制方式"></a>控制方式</h3>
<ul>
<li>同步控制
<ul>
<li>机器周期数、节拍数固定---3机器周期*4节拍</li>
<li>机器周期数固定、节拍数不固定---3机器周期,取指/计算/执行
4/2/3节拍</li>
<li>大多数指令机器周期固定</li>
</ul></li>
<li>异步控制
<ul>
<li>无时钟,应答机制 ### 时序发生器</li>
</ul></li>
</ul>
<h3 id="指令周期方框图"><a href="#指令周期方框图" class="headerlink" title="指令周期方框图"></a>指令周期方框图</h3>
<ul>
<li>取指周期
<ul>
<li>PC-&gt;Ar, PC-&gt;X</li>
<li>X+4-&gt;Z</li>
<li>Z-&gt;PC, M[AR]-&gt;DR</li>
<li>DR-&gt;IR</li>
</ul></li>
<li>计算周期
<ul>
<li>lw指令&amp;sw指令
<ul>
<li>R[rs]-&gt;X</li>
<li>X+Imm-&gt;Imm</li>
</ul></li>
<li>beq指令
<ul>
<li>R[rs]-&gt;X</li>
<li>X-R[rt]-&gt;PSW</li>
</ul></li>
<li>add&amp;addi不需要计算周期</li>
</ul></li>
<li>执行周期
<ul>
<li>lw指令
<ul>
<li>Z-&gt;AR</li>
<li>M[AR]-&gt;DR</li>
<li>DR-&gt;R[rt]</li>
</ul></li>
<li>sw指令
<ul>
<li>Z-&gt;AR</li>
<li>R[rt]-&gt;DR</li>
<li>DR-&gt;M[AR]</li>
</ul></li>
<li>beq指令
<ul>
<li>PC-&gt;X</li>
<li>IR(A)+X-&gt;Z</li>
<li>if(PSW&gt;equal) Z-&gt;PC</li>
</ul></li>
<li>add指令
<ul>
<li>R[rs]-&gt;X</li>
<li>X+R[rt]-&gt;Z</li>
<li>Z-&gt;R[rd]</li>
<li>addi指令
<ul>
<li>R[rs]-&gt;X</li>
<li>X+imm-&gt;Z</li>
<li>Z-&gt;R[rt] ## 单总线MIPS CPU典型指令 | 指令 | 指令功能（RTL描述）|
|:--|:--| |lw rt, imm(rs)|R[rt] &lt;- M[R[rs]+SignExt(imm)]| |sw rt,
imm(rs)|M[R[rs]+SignExt(imm)]&lt;-R[rt]| |bewq rs, rt,
imm|if(R[rs]==R[rt]) Pc&lt;-PC+4+SignExt(imm)&lt;&lt;2| |addi rt, rs,
imm|R[rt]&lt;-R[rs]+SignExt(imm)| |add rd, rs, rt|R[rd]&lt;-R[rs]+R[rt]|
### 取指令数据通路 |节拍|数据通路（数据流）|控制信号（控制流）|
|:--|:--|:--| |T1|PC-&gt;AR, PC-&gt;X|<span
class="math inline">\(PC_{out},AR_{in},X_{in}\)</span>|
|T2|X+4-&gt;Z|+4| |T3|Z-&gt;PC, M[AR]-&gt;DR|<span
class="math inline">\(Z_{out},PC_{in},DRE_{in},Read\)</span>|
|T4|DR-&gt;IR|<span class="math inline">\(DR_{out},IR_{in}\)</span>| ###
lw指令执行数据通路 |节拍|数据通路（数据流）|控制信号（控制流）|
|:--|:--|:--| |T5|R[rs]-&gt;X|<span
class="math inline">\(R_{out},X_{in}\)</span>|
|T6|X+sExt(imm)-&gt;Z|<span class="math inline">\(IR(I){out},
ADD\)</span>| |T7|Z-&gt;AR|<span
class="math inline">\(Z_{out},AR_{in}\)</span>| |T8|M[AR]-&gt;DR|<span
class="math inline">\(DRE_{in},Read\)</span>| |T9|DR-&gt;R[rt]|<span
class="math inline">\(DR_{out},R_{in}\)</span>| ### sw指令执行数据通路
|节拍|数据通路（数据流）|控制信号（控制流）| |:--|:--|:--|
|T5|R[rs]-&gt;X|<span class="math inline">\(R_{out},X_{in}\)</span>|
|T6|X+sExt(imm)-&gt;Z|<span class="math inline">\(IR(I){out},
ADD\)</span>| |T7|Z-&gt;AR|<span
class="math inline">\(Z_{out},AR_{in}\)</span>| |T8|R[rt]-&gt;DR|<span
class="math inline">\(R_{out},Rs/Rt,DR_{in}\)</span>|
|T9|DR-&gt;M[AR]|<span class="math inline">\(DRE_{out}, Write\)</span>|
### beq指令数据通路 |节拍|数据通路（数据流）|控制信号（控制流）|
|:--|:--|:--| |T5|R[rs]-&gt;X|<span
class="math inline">\(R_{out},X_{in}\)</span>| |T6|X-R[rt]-&gt;PSW|<span
class="math inline">\(R_{out},Rs/Rt,SUB,PSW_{in}\)</span>|
|T7|PC-&gt;X|<span class="math inline">\(PC_{out},X_{in}\)</span>|
|T8|X+sExt(imm&lt;&lt;2)-&gt;Z|<span class="math inline">\(IR(A)_{out},
ADD\)</span>| |T9|if(PSW.equal)Z-&gt;PC|<span
class="math inline">\(Z_{out},PC_{in}=PSW.equal\)</span>| ###
I型运算类指令执行数据通路 |节拍|数据通路（数据流）|控制信号（控制流）|
|:--|:--|:--| |T5|R[rs]-&gt;X|<span
class="math inline">\(R_{out},X_{in}\)</span>|
|T6|X+sExt(imm)-&gt;Z|<span class="math inline">\(IR(I)_{out},
ADD\)</span>| |T7|Z-&gt;R[rt]|<span
class="math inline">\(Z_{out},R_{in}\)</span>| ###
R型运算类指令执行数据通路 |节拍|数据通路（数据流）|控制信号（控制流）|
|:--|:--|:--| |T5|R[rs]-&gt;X|<span
class="math inline">\(R_{out},X_{in}\)</span>| |T6|X+R[rt]-&gt;Z|<span
class="math inline">\(Rs/Rt,R_{out}, ADD\)</span>| |T7|Z-&gt;R[rt]|<span
class="math inline">\(Z_{out},R_{in},RegDst\)</span>|</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h2 id="硬布线控制器"><a href="#硬布线控制器" class="headerlink" title="硬布线控制器"></a>硬布线控制器</h2>
<h2 id="微程序控制器"><a href="#微程序控制器" class="headerlink" title="微程序控制器"></a>微程序控制器</h2>
<ul>
<li>微程序是利用软件思想设计硬件的技术</li>
<li>将控制信号序列向程序一样存储起来
<ul>
<li>控制信号序列分解为若干节拍</li>
<li>一个节拍的兵法信号编成一跳微指令</li>
<li>多个节拍对应多条微指令,形成一段微程序</li>
</ul></li>
<li>依据执行微程序即可生成控制信号序列
<ul>
<li>指令取指执行-&gt;微程序执行-&gt;微指令执行-&gt;生成控制信号</li>
<li>软时序:一次执行微指令,时间信号有先后顺序</li>
</ul></li>
<li>存储技术和程序设计相结合,会比复杂时序逻辑设计</li>
</ul>
<h3 id="单总线cpu微指令构造"><a href="#单总线cpu微指令构造" class="headerlink" title="单总线cpu微指令构造"></a>单总线CPU微指令构造</h3>
<ul>
<li>操作控制字段:存储操作控制信号
<ul>
<li>每一位对应一个控制信号,也称微命令,可同事给出多个操作信号</li>
</ul></li>
<li>顺序控制字段:用于控制微程序的执行顺序
<ul>
<li>判别逻辑为零,下一条微指令地址从下址字段获取,否则按约定规则生成</li>
</ul></li>
</ul>
<h3 id="微命令编码"><a href="#微命令编码" class="headerlink" title="微命令编码"></a>微命令编码</h3>
<ul>
<li>简单直观，便于输出控制，微指令长度太长，控存容量大
<ul>
<li>直接表示-&gt;编码表示（压缩互斥性微命令）</li>
<li>下址字段-&gt;计数器法 （<span
class="math inline">\(\mu\)</span>AR++,增加<span
class="math inline">\(P_{end}\)</span>判别位）</li>
<li>水平型-&gt;垂直型微指令（牺牲并行性）</li>
</ul></li>
</ul>
<h2 id="异常与中断处理"><a href="#异常与中断处理" class="headerlink" title="异常与中断处理"></a>异常与中断处理</h2>
<ul>
<li>内部异常（当前指令无法执行）
<ul>
<li>故障fault
<ul>
<li>由指令执行引起的异常，如未定义指令、越权指令、段故障、缺页故障、存储保护违例、数据未对齐、除数为0、浮点溢出、整数溢出等。</li>
<li>可恢复的故障，指令需恢复执行；不可恢复故障，程序被终止</li>
</ul></li>
<li>陷阱trap
<ul>
<li>是一种事先被安排的“异常”时间，通过在程序中显式的调用陷阱指令触发异常，用于在用户态下调用操作系统内核程序，如系统调用、条件陷阱指令。</li>
</ul></li>
<li>终止
<ul>
<li>随机出现的使CPU无法继续执行的硬件故障，和具体指令无关。如机器校验错、总线错误、异常处理中再次异常的双错等，此时当前程序无法继续执行，只能终止执行，由异常服务处理程序来重启系统。</li>
</ul></li>
</ul></li>
<li>外部中断（当前指令执行完毕）
<ul>
<li>关中断
<ul>
<li>临时禁止中断请求，使为了保障中断响应周期以及中断服务程序中保护现场操作的完整性</li>
</ul></li>
<li>保存断点
<ul>
<li>保存将来返回被中断程序的位置，对于已经执行完毕的指令其断点是下一条指令的位置（可能不是顺序指令），对于缺页故障、段错等执行指令引起的故障异常，由于指令并没有执行，所以断点应该是异常指令的PC值</li>
</ul></li>
<li>中断识别
<ul>
<li>根据当前的中断请求识别出中断来源，也就是发生了什么中断，并将对应中断的中断服务程序入口地址送程序计数器PC</li>
</ul></li>
</ul></li>
</ul>
<h1 id="第九章-输入输出系统"><a href="#第九章-输入输出系统" class="headerlink" title="第九章-输入输出系统"></a>第九章 输入输出系统</h1>
<h2 id="输入输出设备与特性"><a href="#输入输出设备与特性" class="headerlink" title="输入输出设备与特性"></a>输入输出设备与特性</h2>
<ul>
<li>异步性</li>
<li>实时性</li>
<li>独立性</li>
</ul>
<p>磁盘、网卡既能输入也能输出，就叫“输入输出设备”<br />
键盘只能输入，就叫输入设备<br />
只能输出就叫输出设备</p>
<h3 id="输入输出系统的组成与功能"><a href="#输入输出系统的组成与功能" class="headerlink" title="输入输出系统的组成与功能"></a>输入/输出系统的组成与功能</h3>
<ul>
<li>外部设备、接口部件、总线以及响应的管理软件统称为计算机的输入输出系统，简称IO系统
<ul>
<li>I/O硬件
<ul>
<li>外设、控制器、I/O接口、总线</li>
</ul></li>
<li>I/O软件
<ul>
<li>OSA无关库，设备无关库，驱动</li>
</ul></li>
</ul></li>
<li>主要功能
<ul>
<li>完成计算机内部二进制信息与外部i多种信息形式间的交流</li>
<li>保证CPU能够正确选择I/O设备并实现对其控制，与数据传输</li>
<li>利用数据缓冲、合适的数据传送方式，实现主机外设间速度匹配</li>
</ul></li>
</ul>
<h2 id="io接口"><a href="#io接口" class="headerlink" title="io接口"></a>I/O接口</h2>
<ul>
<li>I/O接口：连接总线与I/O设备的物理和逻辑界面
<ul>
<li>既包括物理连接电路，也包括软件逻辑接口</li>
<li>所有设备均通过I/O接口（总线接口）与总线相连</li>
<li>CPU使用设备地址经总线与I/O接口通信访问I/O设备</li>
<li>标准接口有利于提升I/O系统的独立性，降低连接复杂度</li>
</ul></li>
<li>I/O接口功能
<ul>
<li>设备寻址</li>
<li>数据交互</li>
<li>设备控制</li>
<li>状态检测</li>
<li>数据缓冲</li>
<li>格式转换</li>
</ul></li>
<li>I/O接口编址
<ul>
<li>统一编址
<ul>
<li>内存映射编址（Memory-mapped）</li>
<li>外设地址与内存地址统一编址，同一个地址空间</li>
<li>不需要设置专用的I/O指令</li>
<li>采用访存指令访问外设，具体访问什么设备取决于地址</li>
</ul></li>
<li>独立编址
<ul>
<li>端口映射编址（Port-mapped）</li>
<li>I/O地址空间与主存地址空间相互独立</li>
<li>I/O地址又称为I/O端口</li>
<li>不同设备中的不同寄存器和存储器都又唯一的端口地址</li>
<li>使用I/O指令访问外设</li>
</ul></li>
</ul></li>
<li>I/O接口的软件
<ul>
<li>现代计算机中用户必须通过操作系统间接访问设备，屏蔽设备细节，更加方便。</li>
<li>与OS无关的I/O库（用户态）
<ul>
<li>如C语言中的标准I/O库stdio.h。用户程序主要通过调用I/O库访问设备，方便程序在不同OS间移植</li>
</ul></li>
<li>与设备无关的OS调用库（内核态）
<ul>
<li>open,read, write, seek,ioctl,close等</li>
</ul></li>
<li>独立的设备驱动程序（内核态）
<ul>
<li>设备驱动程序是与设备相关的I/O软件部分</li>
<li>不同设备对应不同的驱动程序</li>
<li>遵循具体设备的I/O接口约定，包含设备接口细节</li>
</ul></li>
</ul></li>
<li>I/O接口分类
<ul>
<li>按数据传送方式
<ul>
<li>并行</li>
<li>串行</li>
</ul></li>
<li>按接口的灵活性
<ul>
<li>可编程接口</li>
<li>不可变成接口</li>
</ul></li>
<li>按通用性
<ul>
<li>通用</li>
<li>专用</li>
</ul></li>
<li>按总线传输的通信方式
<ul>
<li>同步</li>
<li>异步</li>
</ul></li>
<li>按访问外设的方式
<ul>
<li>直接传送方式</li>
<li>程序控制方式</li>
<li>程序中断方式</li>
<li>DMA</li>
<li>通道处理机接口</li>
</ul></li>
</ul></li>
</ul>
<h2 id="数据传送控制方式"><a href="#数据传送控制方式" class="headerlink" title="数据传送控制方式"></a>数据传送控制方式</h2>
<ul>
<li>程序查询方式
<ul>
<li>轮询</li>
<li>定时</li>
</ul></li>
<li>程序中断方式</li>
<li>直接内存访问方式</li>
<li>通道方式</li>
<li>外围处理机方式 ## 程序控制方式</li>
</ul>
<h2 id="程序中断方式"><a href="#程序中断方式" class="headerlink" title="程序中断方式"></a>程序中断方式</h2>
<ul>
<li>提高了CPU的使用效率
<ul>
<li>主动告知机制避免了反复查询设备状态</li>
<li>仍需要CPU占用（中断服务子程序运行时间+中断开销）</li>
</ul></li>
<li>适合随机出现的服务</li>
<li>需要专门的硬件</li>
<li>子程序与中断服务子程序的异同
<ul>
<li>共同点：调用后要返回</li>
<li>差异：调用方式（显式/随机），保存寄存器（中断更多），返回位置与方式（调用位置/中断位置）</li>
</ul></li>
<li>当同时有多个中断的时候，要进行中断仲裁
<ul>
<li>优先级高的先响应</li>
<li>CPU优先级随不同中断服务程序而改变
<ul>
<li>执行某设备中断服务子程序，CPU优先级就与该设备的优先级一样</li>
</ul></li>
<li>单级中断与多重中断
<ul>
<li>单级中断
<ul>
<li>所有中断源同一个级别，离CPU近的优先级高</li>
<li>CPU处理某个中断时，不响应其它中断</li>
</ul></li>
<li>多重中断
<ul>
<li>优先级高的中断可以打断优先级低的中断服务程序</li>
<li>中断嵌套</li>
</ul></li>
</ul></li>
<li>划分优先级的一般规律
<ul>
<li>硬件故障中断属于最高级，其次是程序错误中断</li>
<li>非屏蔽中断优于可屏蔽中断</li>
<li>DMA请求优先于I/O设备传送的中断请求</li>
<li>告诉设备优于低俗设备</li>
<li>输入设备的中断优于输出设备</li>
<li>实时设备优先于普通设备</li>
</ul></li>
<li>中断屏蔽：动态改变各设备的处理优先级</li>
</ul></li>
<li>中断识别（寻找入口地址）
<ul>
<li>独立请求：向量中断
<ul>
<li>将服务程序入口（中断向量）组织在中断向量表中；响应时由硬件直接产生中断号（向量地址），查中断向量表取得服务程序入口，转入响应服务程序。</li>
<li>硬件查询法</li>
</ul></li>
<li>中断共享：非向量中断
<ul>
<li>将服务程序入口组织在查询程序中</li>
<li>响应时执行查询程序查询你中断源，查询特定端口GPIO识别中断源</li>
<li>程序识别（软件方法）</li>
</ul></li>
</ul></li>
<li>中断处理中的问题
<ul>
<li>中断响应条件
<ul>
<li>中断允许触发器IE=1</li>
<li>对应的中断未被屏蔽</li>
<li>无更高优先级的DMA请求</li>
<li>中断嵌套必须优先级更高</li>
<li>指令已经执行完最后一个机器周期
<ul>
<li>保证指令执行的完整性</li>
</ul></li>
</ul></li>
<li>保存现场，恢复现场
<ul>
<li>中断程序用到的通用寄存器，EPC，屏蔽字</li>
<li>缺页异常的断点和外部中断断点不一致</li>
</ul></li>
<li>中断过程由软硬件结合完成 ## DMA方式</li>
</ul></li>
<li>基本概念
<ul>
<li>外设于主存间建立一个由硬件管理的数据通路（虚拟通路，还是通过系统总线）</li>
<li>CPU不介入外设于主存的数据传送操作</li>
<li>减少CPU开销，提升效率</li>
</ul></li>
<li>与CPU访存冲突
<ul>
<li>停止CPU使用主存
<ul>
<li>DMA传送数据时，CPU停止使用主存</li>
<li>一批数据传送结束后，DMA再交还主存使用权</li>
<li>DMA传送过程中，CPU处于等待状态</li>
</ul></li>
<li>DMA与CPU交替使用主存
<ul>
<li>每个存储周期分成两段
<ul>
<li>一段用于DMA访问主存</li>
<li>一段用于CPU访问主存</li>
</ul></li>
<li>无主存使用权移交过程</li>
</ul></li>
<li>周期挪用法
<ul>
<li>DMA要求访问主存时，CPU暂停一个或多个存储周期。一个数据传送结束后，CPU继续运行</li>
<li>CPU现场没有变动，仅延缓了指令的执行</li>
<li>如发生访存冲突，DMA优先访问</li>
</ul></li>
</ul></li>
<li>DMA与程序中断的区别
<ul>
<li>中断通过程序传送数据，DMA靠硬件实现</li>
<li>中断实际为两指令之间，DMA响应实际为两存储周期之间</li>
<li>中断不仅具有数据传送能力，还能处理异常事件。DMA只能进行数据传送。</li>
<li>DMA仅挪用了一个存储周期，不改变CPU现场。</li>
<li>DMA请求的优先级比中断请求高。CPU优先响应DMA请求，是为了避免DMA所连接的告诉外设丢失数据</li>
<li>DMA利用了中断的技术 ## 通道方式</li>
</ul></li>
</ul>
<h2 id="常见io设备"><a href="#常见io设备" class="headerlink" title="常见io设备"></a>常见I/O设备</h2>
<h1 id="错题总结话术"><a href="#错题总结话术" class="headerlink" title="错题总结话术"></a>错题总结话术：</h1>
<ul>
<li>从软硬协同的角度分析运算器提供硬件溢出检测机制的意义：
<ul>
<li>硬件提供溢出检测后，程序员可以通过该溢出位判断溢出与否，而不再需要通过专门程序判断溢出，简化了程序设计，利于流水线CPU的高效运行。</li>
</ul></li>
<li>如果要将单周期CPU变成多周期，应该左什么变化
<ul>
<li>将指令存储器和数据存储器合二为一；每个功能部件后增加一个缓冲器，如主存、寄存器堆、ALU等部件后都要增加</li>
</ul></li>
<li>如果多周期MIPS
CPU采用微程序控制器，若要加入中断逻辑，应进行哪些扩展？
<ul>
<li>微程序中需要增加中断隐指令的微程序，该微程序的功能是保存断点，修改PC地址为中断程序入口地址，微指令P字段需要再增加一位用于中断判断<span
class="math inline">\(P_{end}\)</span>，每条指令对应微程序最后一条指令的中断判断位为1，如果当前有中断请求信号，要进行分支跳转中断隐指令对应的微程序</li>
</ul></li>
<li>在定长指令周期三级时许总线CPU实验中，测试程序预期功能是在0x80的内存数据单元进行排序，请问这个排序是降序还是升序？（<strong>降序</strong>）是由符号比较还是无符号比较？（<strong>有符号比较</strong>）为什么实际Educoder平台上通关的结果是在0x00处进行内存的安源数据排序的，而且代码区部分代码会被覆盖？
<ul>
<li>Z寄存器没有锁存控制，采用定长周期时，刚刚计算完的地址应该直接送AR，但是由于计算周期和执行周期之间插入了空周期，所以导致送入AR中的地址错误。</li>
</ul></li>
<li>如果要为CPU增加单级中断处理机制，需要增加哪些硬件单元，并叙述其功能。
<ul>
<li>EPC：保存断点</li>
<li>中断使能寄存器IE：开关中断</li>
<li>中断识别控制逻辑：中断识别</li>
</ul></li>
<li>如果要为CPU增加单级中断处理机制，在软件以及软硬系统方面需要进行哪些修改。
<ul>
<li>中断返回eret指令的支持</li>
<li>编写中断服务程序：保护线程、中断服务、恢复现场、中断返回</li>
</ul></li>
<li>CRC编码实验中，对16位汉字进行编码，选择生成多项式7位，余数6位，能够区分一位错和两位错，直接通过余数区分。</li>
</ul>
<!-- flag of hidden posts --><div id="paginator"></div></div><div id="post-footer"></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="回到顶部" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="文章目录">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="切换主题"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://cdn.luogu.com.cn/upload/image_hosting/8cc2fgam.png" alt="Logo" style="margin:0;border-radius:0;"></a><h1 id="Dr"><a href="/">lyx12138</a></h1><div id="description"><p></p></div></div><div id="aside-block"><div id="toc-div"><h1>目录</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">第一章 计算机系统概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%80%A7%E8%83%BD%E8%AF%84%E4%BB%B7"><span class="toc-number">1.1.</span> <span class="toc-text">计算机系统的性能评价</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E6%97%B6%E9%97%B4%E6%8C%87%E6%A0%87"><span class="toc-number">1.1.1.</span> <span class="toc-text">非时间指标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E6%8C%87%E6%A0%87"><span class="toc-number">1.1.2.</span> <span class="toc-text">时间指标</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-number">2.</span> <span class="toc-text">第二章 数据信息的表示</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-number">2.1.</span> <span class="toc-text">数值数据的表示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%9A%84%E6%9C%BA%E5%99%A8%E7%A0%81%E8%A1%A8%E7%A4%BA"><span class="toc-number">2.1.1.</span> <span class="toc-text">数的机器码表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E7%82%B9%E6%95%B0%E8%A1%A8%E7%A4%BA"><span class="toc-number">2.1.2.</span> <span class="toc-text">定点数表示</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%95%B4%E6%95%B0"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">C语言中的整数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E8%A1%A8%E7%A4%BA"><span class="toc-number">2.1.3.</span> <span class="toc-text">浮点数表示</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BF%A1%E6%81%AF%E7%9A%84%E6%A0%A1%E9%AA%8C"><span class="toc-number">2.2.</span> <span class="toc-text">数据信息的校验</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A0%81%E8%B7%9D%E4%B8%8E%E6%A0%A1%E9%AA%8C"><span class="toc-number">2.2.1.</span> <span class="toc-text">码距与校验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C"><span class="toc-number">2.2.2.</span> <span class="toc-text">奇偶校验</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C%E6%80%A7%E8%83%BD"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">奇偶校验性能</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%B7%E6%98%8E%E6%A0%A1%E9%AA%8C"><span class="toc-number">2.2.3.</span> <span class="toc-text">海明校验</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E6%A3%80%E4%B8%80%E4%BD%8D%E9%94%99%E6%B5%B7%E6%98%8E%E7%A0%81"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">可检一位错海明码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%B7%E6%98%8E%E7%A0%81%E7%89%B9%E7%82%B9"><span class="toc-number">2.2.3.2.</span> <span class="toc-text">海明码特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A0%A1%E9%AA%8C"><span class="toc-number">2.2.4.</span> <span class="toc-text">循环冗余校验</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A12%E8%BF%90%E7%AE%97%E8%A7%84%E5%88%99"><span class="toc-number">2.2.4.1.</span> <span class="toc-text">模2运算规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#crc%E7%BC%96%E7%A0%81%E8%A7%84%E5%88%99"><span class="toc-number">2.2.4.2.</span> <span class="toc-text">CRC编码规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%A4%9A%E9%A1%B9%E5%BC%8F"><span class="toc-number">2.2.4.3.</span> <span class="toc-text">生成多项式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A12%E9%99%A4%E6%B3%95%E6%BB%A1%E8%B6%B3%E7%BB%93%E5%90%88%E5%BE%8B"><span class="toc-number">2.2.4.4.</span> <span class="toc-text">模2除法满足结合律</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#crc-nk%E7%A0%81%E6%A3%80%E9%94%99%E6%80%A7%E8%83%BD"><span class="toc-number">2.2.4.5.</span> <span class="toc-text">CRC (n,k)码检错性能</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E4%B8%8E%E8%BF%90%E7%AE%97%E5%99%A8"><span class="toc-number">3.</span> <span class="toc-text">第三章 运算方法与运算器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E7%82%B9%E5%8A%A0%E5%87%8F%E6%B3%95%E8%BF%90%E7%AE%97"><span class="toc-number">3.1.</span> <span class="toc-text">定点加减法运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%A2%E5%87%BA%E5%8F%8A%E6%A3%80%E6%B5%8B"><span class="toc-number">3.1.1.</span> <span class="toc-text">溢出及检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E5%87%8F%E6%B3%95%E7%9A%84%E9%80%BB%E8%BE%91%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.1.2.</span> <span class="toc-text">加减法的逻辑实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%BD%8D%E5%85%A8%E5%8A%A0%E5%99%A8%E9%80%BB%E8%BE%91%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">一位全加器逻辑实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%8F%E6%B3%95%E7%9A%84%E7%90%83%E9%98%80"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">减法的球阀</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B2%E8%A1%8C%E5%8A%A0%E6%B3%95%E5%99%A8%E6%97%B6%E5%BB%B6"><span class="toc-number">3.1.2.3.</span> <span class="toc-text">串行加法器时延</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E5%8A%A0%E6%B3%95%E5%99%A8"><span class="toc-number">3.1.2.4.</span> <span class="toc-text">并行加法器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E7%9A%84%E4%B9%98%E8%BF%90%E7%AE%97"><span class="toc-number">3.1.2.5.</span> <span class="toc-text">整数的乘运算</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E7%82%B9%E9%99%A4%E6%B3%95%E8%BF%90%E7%AE%97"><span class="toc-number">3.2.</span> <span class="toc-text">定点除法运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%81%A2%E5%A4%8D%E4%BD%99%E6%95%B0%E7%9A%84%E9%99%A4%E6%B3%95"><span class="toc-number">3.2.0.1.</span> <span class="toc-text">恢复余数的除法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98"><span class="toc-number">3.2.0.2.</span> <span class="toc-text">精度问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B9%98%E6%B3%95%E8%BF%90%E7%AE%97"><span class="toc-number">3.2.1.</span> <span class="toc-text">浮点数乘法运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E9%99%A4%E6%B3%95%E8%BF%90%E7%AE%97"><span class="toc-number">3.2.2.</span> <span class="toc-text">浮点数除法运算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E5%99%A8"><span class="toc-number">3.3.</span> <span class="toc-text">运算器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E5%99%A8%E5%8A%9F%E8%83%BD"><span class="toc-number">3.3.1.</span> <span class="toc-text">运算器功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E5%99%A8%E4%B8%8E%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84"><span class="toc-number">3.3.2.</span> <span class="toc-text">运算器与总线结构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F"><span class="toc-number">4.</span> <span class="toc-text">第四章 存储系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0%E4%B8%8D%E9%87%8D%E8%A6%81"><span class="toc-number">4.1.</span> <span class="toc-text">存储器概述（不重要）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">4.2.</span> <span class="toc-text">半导体存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%88%B7%E6%96%B0"><span class="toc-number">4.2.0.1.</span> <span class="toc-text">存储器的刷新</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">4.2.1.</span> <span class="toc-text">半导体存储器的对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E5%AD%98%E7%9A%84%E7%BB%84%E7%BB%87%E4%BB%A5%E5%8F%8A"><span class="toc-number">4.3.</span> <span class="toc-text">主存的组织以及</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E6%89%A9%E5%B1%95"><span class="toc-number">4.3.1.</span> <span class="toc-text">存储器扩展</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E9%80%9F%E7%BC%93%E5%86%B2%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">4.4.</span> <span class="toc-text">高速缓冲存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cache%E5%86%99%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">4.4.1.</span> <span class="toc-text">cache写操作流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cache%E8%AF%BB%E5%86%99%E6%B5%81%E7%A8%8B"><span class="toc-number">4.4.2.</span> <span class="toc-text">cache读写流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF"><span class="toc-number">4.4.3.</span> <span class="toc-text">关键技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%9F%A5%E6%89%BE"><span class="toc-number">4.4.3.1.</span> <span class="toc-text">数据查找</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B8%E8%81%94%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">4.4.3.1.1.</span> <span class="toc-text">相联存储器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E7%9B%B8%E8%BF%9E%E6%98%A0%E5%B0%84"><span class="toc-number">4.4.3.1.2.</span> <span class="toc-text">直接相连映射</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%84%E7%9B%B8%E8%BF%9E%E5%AD%98%E5%82%A8%E5%99%A8%E7%A1%AC%E4%BB%B6%E5%BC%80%E9%94%80"><span class="toc-number">4.4.3.1.3.</span> <span class="toc-text">组相连存储器硬件开销</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2%E7%AD%96%E7%95%A5"><span class="toc-number">4.4.3.2.</span> <span class="toc-text">替换策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E5%85%A5%E7%AD%96%E7%95%A5"><span class="toc-number">4.4.3.3.</span> <span class="toc-text">写入策略</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cache%E5%AF%B9%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">4.4.4.</span> <span class="toc-text">cache对存储系统性能的影响</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cache%E5%91%BD%E4%B8%AD%E7%8E%87"><span class="toc-number">4.4.5.</span> <span class="toc-text">cache命中率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%88%B0%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80"><span class="toc-number">4.4.6.</span> <span class="toc-text">虚拟地址到物理地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8tlb%E6%8F%90%E9%AB%98%E9%80%9F%E5%BA%A6"><span class="toc-number">4.4.7.</span> <span class="toc-text">使用TLB提高速度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.</span> <span class="toc-text">第五章 指令系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="toc-number">5.1.</span> <span class="toc-text">指令格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E5%AF%BB%E5%9D%80"><span class="toc-number">5.1.1.</span> <span class="toc-text">操作数寻址</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E5%A0%86%E6%A0%88"><span class="toc-number">5.1.1.1.</span> <span class="toc-text">硬件堆栈</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#x86%E7%B3%BB%E5%88%97%E6%94%AF%E6%8C%81%E5%A4%9A%E7%A7%8D%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-number">5.1.2.</span> <span class="toc-text">x86系列支持多种寻址方式的意义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">5.2.</span> <span class="toc-text">指令格式设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cisc%E4%B8%8Erisc"><span class="toc-number">5.3.</span> <span class="toc-text">CISC与RISC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#risc"><span class="toc-number">5.3.1.</span> <span class="toc-text">RISC</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">6.</span> <span class="toc-text">第六章 中央处理器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">6.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F"><span class="toc-number">6.2.</span> <span class="toc-text">指令周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B"><span class="toc-number">6.2.1.</span> <span class="toc-text">指令执行一般流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">6.2.2.</span> <span class="toc-text">指令周期基本概念</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E5%8F%8A%E6%8C%87%E4%BB%A4%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">6.3.</span> <span class="toc-text">数据通路及指令操作流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#d%E8%A7%A6%E5%8F%91%E5%99%A8%E5%AE%9A%E6%97%B6%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.3.0.1.</span> <span class="toc-text">D触发器定时模型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E5%BA%8F%E4%B8%8E%E6%8E%A7%E5%88%B6"><span class="toc-number">6.4.</span> <span class="toc-text">时序与控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8%E6%97%B6%E5%BA%8F"><span class="toc-number">6.4.1.</span> <span class="toc-text">中央处理器时序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E4%B8%89%E7%BA%A7%E6%97%B6%E5%BA%8F"><span class="toc-number">6.4.1.1.</span> <span class="toc-text">传统三级时序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">6.4.2.</span> <span class="toc-text">控制方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E6%96%B9%E6%A1%86%E5%9B%BE"><span class="toc-number">6.4.3.</span> <span class="toc-text">指令周期方框图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E5%B8%83%E7%BA%BF%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">6.5.</span> <span class="toc-text">硬布线控制器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">6.6.</span> <span class="toc-text">微程序控制器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E6%80%BB%E7%BA%BFcpu%E5%BE%AE%E6%8C%87%E4%BB%A4%E6%9E%84%E9%80%A0"><span class="toc-number">6.6.1.</span> <span class="toc-text">单总线CPU微指令构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E5%91%BD%E4%BB%A4%E7%BC%96%E7%A0%81"><span class="toc-number">6.6.2.</span> <span class="toc-text">微命令编码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E4%B8%8E%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86"><span class="toc-number">6.7.</span> <span class="toc-text">异常与中断处理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F"><span class="toc-number">7.</span> <span class="toc-text">第九章 输入输出系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87%E4%B8%8E%E7%89%B9%E6%80%A7"><span class="toc-number">7.1.</span> <span class="toc-text">输入输出设备与特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%84%E6%88%90%E4%B8%8E%E5%8A%9F%E8%83%BD"><span class="toc-number">7.1.1.</span> <span class="toc-text">输入&#x2F;输出系统的组成与功能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#io%E6%8E%A5%E5%8F%A3"><span class="toc-number">7.2.</span> <span class="toc-text">I&#x2F;O接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">7.3.</span> <span class="toc-text">数据传送控制方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F"><span class="toc-number">7.4.</span> <span class="toc-text">程序中断方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81io%E8%AE%BE%E5%A4%87"><span class="toc-number">7.5.</span> <span class="toc-text">常见I&#x2F;O设备</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%94%99%E9%A2%98%E6%80%BB%E7%BB%93%E8%AF%9D%E6%9C%AF"><span class="toc-number">8.</span> <span class="toc-text">错题总结话术：</span></a></li></ol></div></div><footer><nobr>构建自 <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> 使用主题 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> 主题作者 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas></body></html>