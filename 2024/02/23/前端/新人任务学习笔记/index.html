<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title> 新人任务学习笔记 | lyx12138的博客</title><meta name="robots" content="noindex"><link rel="icon" type="image/x-icon" href="https://cdn.luogu.com.cn/upload/image_hosting/8cc2fgam.png"><link rel="preload" as="font" crossorigin="anonymous" href="/font/Bender.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/font/BenderLight.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="/font/JetBrainsMono-Regular.woff2"><link rel="stylesheet" href="/css/arknights.css"><style>@font-face {
  font-family: Bender;
  src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
  font-family: BenderLight;
  src: local('BenderLight'), url("/font/BenderLight.ttf");
}
@font-face {
  font-family: 'JetBrains Mono';
  src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}
</style><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 - $1 行","copy":"复制"}}</script><link type="text/css" rel="stylesheet" href="/lib/encrypt/hbe.style.css"><script src="//unpkg.com/mermaid@10.5.0/dist/mermaid.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
 menuSettings: {
   zoom: "None"
 },
 showMathMenu: false,
 jax: ["input/TeX","output/CommonHTML"],
 extensions: ["tex2jax.js"],
 TeX: {
   extensions: ["AMSmath.js","AMSsymbols.js"],
   equationNumbers: {
     autoNumber: "AMS"
   }
 },
 tex2jax: {
   inlineMath: [["\\(", "\\)"]],
   displayMath: [["\\[", "\\]"]]
 }
});</script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.woff2") format('woff2');
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
 --dark-background: url('https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg');
 --light-background: url('/img/bk.jpg');
 --theme-encrypt-confirm: '确认'
}</style><script defer src="/js/arknights.js"></script><script defer src="/js/search.js"></script><script defer type="module">import mermaid from '//unpkg.com/mermaid@10.5.0/dist/mermaid.esm.mjs';
window.mermaid = mermaid;
code.paintMermaid();
</script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
  menuSettings: {
    zoom: "None"
  },
  showMathMenu: false,
  jax: ["input/TeX","output/CommonHTML"],
  extensions: ["tex2jax.js"],
  TeX: {
    extensions: ["AMSmath.js","AMSsymbols.js"],
    equationNumbers: {
      autoNumber: "AMS"
    }
  },
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]]
  }
});
</script><script async src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script async src="/lib/encrypt/hbe.js"></script><script async src="/js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js','data-pjax','.busuanzi'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup" tabindex="0"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/Proverb/"><span class="navItemTitle">Proverb</span></a></li><li class="navItem"><a class="navBlock" href="/demo/Arrangement/"><span class="navItemTitle">Arrangement</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1> 新人任务学习笔记</h1><div id="post-info"><span>文章发布时间: <div class="control"><time datetime="2024-02-22T16:00:00.000Z" id="date"> 2024-02-23</time></div></span><br><span>最后更新时间: <div class="control"><time datetime="2025-10-19T08:45:22.508Z" id="updated"> 2025-10-19</time></div></span></div></div><hr><div id="post-content"><h1 id="新人任务学习笔记"><a href="#新人任务学习笔记" class="headerlink" title="新人任务学习笔记"></a>新人任务学习笔记</h1>
<h1 id="week-1-keyword加载刷新同步"><a href="#week-1-keyword加载刷新同步" class="headerlink" title="week-1-keyword加载刷新同步"></a>week 1 (keyword:加载/刷新/同步)</h1>
<p>更改css样式后需要html刷新一次才能更新</p>
<p>js是同步执行的，邻近的命令会一起执行</p>
<p>创造html子元素有函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(div);<br></code></pre></td></tr></table></figure>
<h1 id="week-2-虚拟-dom"><a href="#week-2-虚拟-dom" class="headerlink" title="week-2-虚拟-dom"></a>week 2 虚拟 DOM</h1>
<p><a
target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV12T411t796?p=4&amp;vd_source=610d5016ada513f5a725f4e7b2c16173">vdom学习视频
b站</a></p>
<p><a
target="_blank" rel="noopener" href="https://nosaid.com/article/virtual-dom#%E7%94%9F%E6%88%90%20VNode">Virtual
DOM 的设计与实现</a></p>
<p><a
target="_blank" rel="noopener" href="https://juejin.cn/post/6984784551503790116#heading-31">手把手教你手写vdom</a></p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2>
<p>性能：对 <code>dom</code>
的操作是昂贵的，最后在一个合适的时机去一次性更新真实
<code>dom</code></p>
<p>跨平台</p>
<h2 id="vnode"><a href="#vnode" class="headerlink" title="vnode"></a>VNode</h2>
<p>对象</p>
<h2 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h2>
<p>检查自从上一期patch后修改了哪些</p>
<p>同一个位置（可能是移动后）若新旧节点key和type一样，则复用（用旧的element（real
dom））</p>
<p>否则 重新建一个element（real dom）暴力新建和删除</p>
<h2 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h2>
<p>根据 diff 对比，把结果反馈到真实 dom 上</p>
<h2 id="一些方法"><a href="#一些方法" class="headerlink" title="一些方法"></a>一些方法</h2>
<p>insertBefore</p>
<p>appendChild（末尾）</p>
<p>（如果有，只是移动）</p>
<p>tagName（大写的标签名）</p>
<p>removeChild</p>
<p>document.createElement</p>
<p>string.toLowerCase();</p>
<p>Node.parentNode</p>
<p>Node.nextSibling</p>
<h2 id="vue3优化"><a href="#vue3优化" class="headerlink" title="vue3优化"></a>vue3优化</h2>
<p>事件缓存</p>
<p>静态节点标记</p>
<p>比较方式</p>
<ul>
<li>头和头比</li>
<li>尾和尾比</li>
<li>基于最长递增子序列进行移动/添加/删除</li>
</ul>
<h2 id="react-diff算法"><a href="#react-diff算法" class="headerlink" title="react-diff算法"></a>react diff算法</h2>
<p><a target="_blank" rel="noopener" href="https://www.jb51.net/article/277184.htm">111</a></p>
<p>直接用key比较，</p>
<p>if (nowindex (这一个新节点对应的老index) &lt; lastindex
(上一个新节点对应的老index，已移动过的) ) 移动</p>
<h2 id="emmet"><a href="#emmet" class="headerlink" title="emmet"></a>emmet</h2>
<p>https://juejin.cn/post/7018567571876102151</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2>
<ul>
<li>不用 for in 用 of</li>
<li>const t = [] 因为数组的地址不会改变</li>
<li><a
target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze">Object.freeze()</a></li>
</ul>
<h1 id="week-3-promise">week 3 <a
target="_blank" rel="noopener" href="https://space.bilibili.com/203376774/video">promise</a></h1>
<p><a
target="_blank" rel="noopener" href="http://blog.coderyq.cn/index.php/2022/09/22/promise%e7%9a%84%e4%bd%bf%e7%94%a8%e5%92%8c%e6%89%8b%e5%86%99/">参考代码（有些问题）</a></p>
<p><a
target="_blank" rel="noopener" href="https://juejin.cn/post/7043758954496655397">手把手教你</a></p>
<p>回调函数：把一个函数作为参数传到另一个函数中，这个作为参数的函数就是回调函数</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/column/6965423613981753380">JavaScript
异步编程指南</a></p>
<h2 id="for-in-for-of-遍历对象键值-js">for in &amp; for of 遍历对象键值
<a href="JS.md">JS</a></h2>
<ul>
<li>使用<code>for...in</code>循环遍历对象的可枚举属性（包括原型链上的属性）。</li>
<li>使用<code>for...of</code>循环遍历可迭代对象，如数组、字符串、Map、Set等。</li>
<li>在处理数组时，尽量避免使用<code>for...in</code>循环，以防止意外的结果和性能问题。</li>
<li>在JavaScript中，如果您想要遍历一个对象的键值对，您可以使用 <code>Object.entries()</code> 方法。这个方法会返回一个由键值对组成的数组，然后您可以使用 <code>for...of</code> 循环或数组的 <code>forEach()</code> 方法来遍历这些键值对。</li>
</ul>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;  <span class="hljs-comment">// 异步操作...  </span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-comment">/* 异步操作成功 */</span>) &#123;    <br>        <span class="hljs-title function_">resolve</span>(result); <span class="hljs-comment">// 将结果传递给resolve函数  </span><br>    &#125; <span class="hljs-keyword">else</span> &#123;    <br>        <span class="hljs-title function_">reject</span>(error); <span class="hljs-comment">// 将错误信息传递给reject函数  </span><br>    &#125; <br>&#125;); <br>promise  <br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    	<span class="hljs-comment">// 处理异步操作成功的结果  </span><br>	&#125;)  <br>    .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    	<span class="hljs-comment">// 处理异步操作失败的结果  </span><br>	&#125;);<br></code></pre></td></tr></table></figure>
<p>new promise时自动执行promise内函数</p>
<ul>
<li><p>then</p>
<p>then支持一个或两个函数参数：then(onFulfilled)，then(onFulfilled,
onRejected)</p>
<p>then的返回值是promise，是它的回调函数的返回值</p>
<p>若不传第二个参数，此promise为rejected时自动返回此promise</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">promise<br>    .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;1&quot;</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">111</span>&#125;);<br></code></pre></td></tr></table></figure></p>
<p>如果返回的不是promise对象，转换为一个状态为fulfilled，result为返回值的promise对象</p>
<p>执行时报错变成rejected</p></li>
<li><p>catch</p>
<p>如果此promise时fulfilled，则直接返回此promise</p>
<p>否则执行回调函数</p></li>
<li><p>finally</p>
<p>无论此promise的状态时fulfilled或者rejected，都执行回调函数</p>
<p>若函数返回rejected状态的promise或有错误，返回此promise或错误</p>
<p>否则返回原promise</p></li>
</ul>
<h2 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;promise&quot;</span>); <span class="hljs-keyword">return</span> <span class="hljs-title function_">resolve</span>(); &#125;)<br>&#125;);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;setTimeout&quot;</span>); &#125;);<br><br>p.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;then&quot;</span>)&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;common&quot;</span>);<br><br><span class="hljs-comment">//console : common promise then setTimeout</span><br></code></pre></td></tr></table></figure>
<p>创造微任务：queueMicrotask()</p>
<h2 id="高级操作"><a href="#高级操作" class="headerlink" title="高级操作"></a>高级操作</h2>
<h3 id="promise.all"><a href="#promise.all" class="headerlink" title="promise.all"></a>Promise.all</h3>
<p><code>Promise.all</code>方法接收一个由 Promise
实例组成的iterable对象（如数组）作为参数，并返回一个新的 Promise
实例。</p>
<p>若在数组中的所有 Promise
实例都变为<code>fulfilled</code>状态后，才会变为<code>fulfilled</code>状态，并将每个
Promise 实例的结果值组成一个数组作为自己的result。</p>
<p>如果出现一个变为rejected，立即变为rejected状态，且把第一个rejected的promise的result作为自己的result</p>
<h2 id="promise.allsettled"><a href="#promise.allsettled" class="headerlink" title="promise.allsettled"></a>Promise.allSettled()</h2>
<p>和all大致一样，但是其返回值result为<code>[&#123;state:...,result:...&#125;,&#123;state:...,result:...&#125;,&#123;state:...,result:...&#125;...]</code>，装所有promise的状态和res</p>
<h2 id="promise.race"><a href="#promise.race" class="headerlink" title="promise.race"></a>Promise.race</h2>
<p>只要有一个变成fulfilled或rejected状态，就变成那个状态，把这一个的result/error给回调函数</p>
<h2 id="promise.resolve"><a href="#promise.resolve" class="headerlink" title="promise.resolve"></a>Promise.resolve()</h2>
<p>若参数为promise对象，直接返回promise对象</p>
<p>否则 返回一个新的 Promise
对象，该实例的状态为<code>fulfilled</code>，并将传递的参数作为result。</p>
<h2 id="promise.reject"><a href="#promise.reject" class="headerlink" title="promise.reject"></a>Promise.reject</h2>
<p>返回的promise状态一定是rejected</p>
<h2 id="async-await"><a href="#async-await" class="headerlink" title="async-await"></a>async &amp; await</h2>
<p>async 函数中可能会有 await 表达式，async 函数执行时，如果遇到 await
就会先暂停执行 ，等到触发的异步操作完成后，恢复 async
函数的执行并返回解析值。</p>
<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2>
<p>function.bind(a);在运行此函数时把函数内的this绑定为a</p>
<p><strong><code>instanceof</code></strong>
<strong>运算符</strong>用于检测构造函数的 <code>prototype</code>
属性是否出现在某个实例对象的原型链上。</p>
<p>三个点（...）真名叫扩展运算符，不管是大括号（[]）、花括号（{}），统统不在话下，全部脱掉脱掉。但是只能脱掉一层，所以</p>
<p>A.call(B, a1, a2) 调用A方法，并且A中的this为B，a1，a2...为A的参数</p>
<p>箭头函数：this固定，不能是构造函数</p>
<h2 id="hardman"><a
target="_blank" rel="noopener" href="https://jasonlam0990.github.io/2019/04/02/%E5%BE%AE%E4%BF%A1%E4%BA%8B%E4%B8%9A%E7%BE%A4%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9AHardMan-LazyMan/">HardMan</a></h2>
<p>最近又复习到这里，说一下理解。就是如何让链式调用实现阻塞的效果，js
很难实现阻塞，只能你记住所有的 task，然后这个 task
搞完在回调函数里面调用下一个 task，或者用
await（但是因为返回的是promise，所以还是要记一下），所以这里链式调用都是同步的，最开始搞一个异步的，让所有链式调用都加载完之后调用），然后promise用函数包一下，settimeout回调记得resolve</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">_HardMan</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tasks</span> = [];<br><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-title function_">async</span> () =&gt; &#123;<br><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> task <span class="hljs-keyword">of</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">tasks</span>) &#123;<br><br>        <span class="hljs-keyword">await</span> <span class="hljs-title function_">task</span>();<br><br>      &#125;<br><br>    &#125;)<br><br>  &#125;<br><br>  <br><br>  <span class="hljs-title function_">fna</span>(<span class="hljs-params">delay</span>) &#123;<br><br>    <span class="hljs-keyword">let</span> t = <span class="hljs-variable language_">this</span>.<span class="hljs-property">tasks</span>.<span class="hljs-property">length</span>;<br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">tasks</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> &#123;<br><br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br><br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br><br>          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;fna&#x27;</span>, t);<br><br>          <span class="hljs-title function_">resolve</span>();<br><br>        &#125;, delay * <span class="hljs-number">1000</span>);<br><br>      &#125;);<br><br>    &#125;);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br><br>  &#125;<br><br>&#125;<br><br>  <br><br><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title function_">_HardMan</span>();<br><br>a.<span class="hljs-title function_">fna</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">fna</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">fna</span>(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure>
<h1 id="week-4-todelist"><a href="#week-4-todelist" class="headerlink" title="week-4-todelist"></a>week 4 TodeList</h1>
<h2 id="webpack"><a
target="_blank" rel="noopener" href="https://juejin.cn/post/7101643125117943839">webpack</a></h2>
<p>把所有js和css文件压缩成一个js文件</p>
<h2 id="杂项-1"><a href="#杂项-1" class="headerlink" title="杂项-1"></a>杂项</h2>
<ul>
<li><p><code>onclick</code>是一种直接在HTML标签中定义事件处理程序的简便方法，而<code>click</code>是通过JavaScript代码动态添加事件监听器的更灵活的方式。</p></li>
<li><p><code>indexOf()</code>：这个方法返回子串在字符串中第一次出现的索引位置。如果找不到子串，则返回-1</p></li>
<li><p>``` // 获取复选框元素 const checkbox =
document.getElementById("myCheckbox");</p>
<p>// 模拟点击复选框 checkbox.click(); <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">  <br>- `document.querySelector(selector);`<br><br>  其中，`selector`是一个字符串，表示要选择的元素的CSS选择器。它可以是元素的标签名、类名、ID、属性等。<br><br>  `querySelector`方法返回与选择器匹配的第一个元素，如果没有找到匹配的元素，则返回`null`。如`&#x27;div&#x27;,&#x27;#id&#x27;,&#x27;.class&#x27;,&#x27;[a=b]&#x27;`<br>  <br>- `splice` 方法可以用于在数组的指定位置插入元素。它还可以用于删除元素或同时删除和插入元素。<br><br></code></pre></td></tr></table></figure> const arr = [1, 2,
3, 4, 5]; arr.splice(2, 0, 6); console.log(arr); // 输出: [1, 2, 6, 3,
4, 5] <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br>## 响应式布局<br><br>响应式布局是一种设计方法，可以使网站或应用程序在不同设备和屏幕尺寸上提供最佳的用户体验。它可以根据用户的设备大小和屏幕分辨率自动调整和适应布局。可以使用媒体查询，弹性布局（flex）等办法。<br><br>## 媒体查询<br><br>媒体查询是CSS中的一种技术，它允许你根据设备的特性（如屏幕宽度、高度、方向等）应用不同的样式。你可以在CSS中使用媒体查询来定义不同屏幕尺寸下的样式规则。<br><br>```css<br>/* 在小屏幕上应用不同的样式 */<br>@media (max-width: 768px) &#123;<br>  /* 在屏幕宽度小于等于768px时应用的样式 */<br>&#125;<br><br>/* 在大屏幕上应用不同的样式 */<br>@media (min-width: 1200px) &#123;<br>  /* 在屏幕宽度大于等于1200px时应用的样式 */<br>&#125;<br></code></pre></td></tr></table></figure></p></li>
</ul>
<p>通过使用媒体查询，你可以根据不同的屏幕尺寸应用不同的样式，以适应不同的设备。</p>
<ul>
<li><p>html</p>
<p><code>&lt;link rel="stylesheet" href="small.css" media="(min-width: 20em)" /&gt;</code></p></li>
<li><p>css</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> <span class="hljs-keyword">only</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-device-width</span>: <span class="hljs-number">320px</span>) <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-device-width</span>: <span class="hljs-number">480px</span>) &#123;  <br><span class="hljs-selector-class">.card</span> &#123;    <br>	<span class="hljs-attribute">background</span>: <span class="hljs-number">#bada55</span>;  <br>	&#125; <br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>js</p>
<p><code>window.matchMedia()</code> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// Create a condition that targets viewports at least 768px wide</span><br><span class="hljs-keyword">const</span> mediaQuery = <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">matchMedia</span>(<span class="hljs-string">&#x27;(min-width: 768px)&#x27;</span>)<br>	<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleTabletChange</span>(<span class="hljs-params">e</span>) &#123;<br>  <span class="hljs-comment">// Check if the media query is true</span><br>  <span class="hljs-keyword">if</span> (e.<span class="hljs-property">matches</span>) &#123;<br>    <span class="hljs-comment">// Then log the following message to the console</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Media Query Matched!&#x27;</span>)<br>  &#125;<br>&#125;<br>	<br><span class="hljs-comment">// Register event listener</span><br>mediaQuery.<span class="hljs-title function_">addListener</span>(handleTabletChange)<br>	<br><span class="hljs-comment">// Initial check</span><br><span class="hljs-title function_">handleTabletChange</span>(mediaQuery)<br></code></pre></td></tr></table></figure></p></li>
</ul>
<figure>
<img
src="https://i0.wp.com/css-tricks.com/wp-content/uploads/2020/09/media-query-anatomy.jpg?resize=2048%2C135&amp;ssl=1"
alt="媒体查询结构" />
<figcaption aria-hidden="true">媒体查询结构</figcaption>
</figure>
<ul>
<li><p>media type：如all，print，screen（最常用），speech</p></li>
<li><p>madia
feature：如width，min-width，height，min-height，aspect-ratio（宽高比），orientation（屏幕的方向）……其他见文档</p></li>
<li><p>operator：<span class="citation" data-cites="media">@media</span>
约等于 if</p>
<blockquote>
<p>The <code>@media</code> rule is itself a logical operator that is
basically stating that “if” the following types and features are
matches, then do some stuff.</p>
</blockquote>
<p><code>and</code>，<code>,</code>（or的意思），not</p></li>
</ul>
<h2 id="客户端存储技术"><a href="#客户端存储技术" class="headerlink" title="客户端存储技术"></a>客户端存储技术</h2>
<h4 id="cookie少量不安全"><a href="#cookie少量不安全" class="headerlink" title="cookie少量不安全"></a>cookie（少量，不安全）</h4>
<p>https://cloud.tencent.com/developer/article/1861983</p>
<p>通过document.cookie直接设置cookie</p>
<p><strong>expires过期时间</strong>：表示什么时间删除<code>cookie</code>，即不再发送到服务器。默认情况下浏览器<strong>会话结束后</strong>会删除所有cookie。不过，可以设置删除<code>cookie</code>的具体时间，这样即使关闭浏览器<code>cookie</code>也会保存在用户的本机上。把过期时间设置为过去的时间就可以实现删除<code>cookie</code></p>
<p>document.cookie = '' 添加一个cookie，注意不是覆盖而是添加</p>
<h3 id="web-storage-localstorage-sessionstorage">Web Storage
(localStorage, sessionStorage)</h3>
<p><code>localstorage</code>的存储方式是以==<code>key-value</code>==的形式进行存储的，首先我们先了解以下其中的操作方法</p>
<ol type="1">
<li><code>localstorage.length</code>：获取当前存储中的键值对数量</li>
<li><code>localstorage.key(index)</code>：得到某个索引的键值</li>
<li><code>localstorage.getItem(key)</code>：读取对应键值的数据</li>
<li><code>localstorage.setItem(key,value)</code>：设置对应的键值对，保存数据</li>
<li><code>localstorage.remove(key)</code>：清除某个指定数据</li>
<li><code>localstorage.clear()</code>：清除存储的所有数据</li>
</ol>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3>
<ol type="1">
<li>cookie在每次请求时都会被发送到服务器，这样会浪费带宽</li>
<li>cookie中的操作方法需要自己封装，web
storage中有<code>setItem</code>，<code>getItem</code>等方法</li>
<li>cookie能够与服务器端交互，web Storage只是将数据保存在本地</li>
<li>存储数据的大小限制不一样，<code>cookie</code>一般4k，<code>web Storage</code>一般5M</li>
<li>数据的生命周期不一致，cookie能设置时间，本地存储是永久性的，临时存储可以说是一次性的</li>
<li>作用域不同，<code>sessionStorage</code>不在不同的浏览器窗口中共享，<code>localstorage</code>和<code>cookie</code>在所有同源窗口中都是共享的</li>
</ol>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2>
<ul>
<li><p>创建： <code>let a = /ab+c/;</code>
<code>let a = new RegExp("ab+c");</code></p></li>
<li><p><code>/ab+c/g</code> 全局匹配</p></li>
<li><p><code>String.prototype.match(regex);</code>
返回一个Array，装有所有匹配的字符串</p></li>
<li><p><code>String.prototype.search(regex);</code>
返回第一个匹配的索引位置</p></li>
<li><p><code>String.prototype.replace(regex);</code>
<code>String.prototype.split(regex);</code></p></li>
<li><p><code>RegExp.exec(String)</code>
返回详细信息（<code>[0]</code>匹配的字符串，<code>.index</code>，……）</p></li>
<li><p>查找所有匹配的索引位置 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&quot;hello, hello, hello!&quot;</span>;<br><span class="hljs-keyword">const</span> regex = <span class="hljs-regexp">/hello/g</span>;<br><span class="hljs-keyword">let</span> match;<br><span class="hljs-keyword">const</span> indexes = [];<br><span class="hljs-keyword">while</span> ((match = regex.<span class="hljs-title function_">exec</span>(str)) !== <span class="hljs-literal">null</span>) &#123;<br>  indexes.<span class="hljs-title function_">push</span>(match.<span class="hljs-property">index</span>);<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(indexes); <span class="hljs-comment">// 输出：[0, 7, 14]</span><br></code></pre></td></tr></table></figure>
regex内部有一个lastIndex属性</p></li>
</ul>
<h2 id="拷打问题"><a href="#拷打问题" class="headerlink" title="拷打问题"></a>拷打问题</h2>
<ul>
<li><p>用localstage</p></li>
<li><p>f12的应用可以查看cookie和localstage</p></li>
<li><p>-1 =&gt; 常量</p></li>
<li><p>模板字符串 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> message = <span class="hljs-string">`Hello, my name is <span class="hljs-subst">$&#123;name&#125;</span> and I am <span class="hljs-subst">$&#123;age&#125;</span> years old`</span>;<br><span class="hljs-keyword">const</span> multiLineString = <span class="hljs-string">`</span><br><span class="hljs-string">  This is a</span><br><span class="hljs-string">  multi-line</span><br><span class="hljs-string">  string.</span><br><span class="hljs-string">`</span>;<br></code></pre></td></tr></table></figure></p></li>
<li><p>序列化</p>
<p>内置的 <code>JSON.stringify()</code> 方法将对象序列化为 JSON
字符串，反之，如果要将 JSON 字符串反序列化为 JavaScript 对象，可以使用
<code>JSON.parse()</code> 方法</p></li>
<li><p>用find而不用for</p></li>
<li><p>控制台‘源代码’中的‘网页’可以拷到example的css源码</p></li>
</ul>
<h1 id="week-5-koa">Week 5 <a
target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1022910821149312/1099752344192192">koa</a></h1>
<h2 id="杂项-2"><a href="#杂项-2" class="headerlink" title="杂项-2"></a>杂项</h2>
<ul>
<li><p><code>&lt;form&gt;</code>标签是HTML中用于创建表单的元素。它用于包裹表单中的各种输入元素，例如文本框、复选框、单选按钮等。提交request，可以修改url和method。<code>action</code>属性指定了表单提交的目标URL，<code>method</code>属性指定了表单提交的HTTP方法（例如POST或GET）。浏览器会将每个表单字段的<code>name</code>属性与其对应的值一起发送到服务器</p></li>
<li><p><code>const files = fs.readdirSync(_dirname)</code> 然后调用
readdirSync
方法并传入要读取的目录的路径作为参数。该方法会返回一个包含目录中所有文件和子目录的名字的数组</p></li>
<li><p><code>Array.prototype.filter</code> :</p>
<p>过滤是指从数组中筛选出满足特定条件的元素，然后返回一个新的数组。<code>filter</code>
方法接受一个回调函数作为参数，该回调函数会对数组中的每个元素进行评估。如果回调函数返回
<code>true</code>，则该元素将被包含在新的数组中，否则将被排除。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">var js_files = files.filter((f) =&gt; &#123;<br>    return f.endsWith(&#x27;.js&#x27;);<br>&#125;);<br></code></pre></td></tr></table></figure></li>
<li><p><code>in</code>运算符用于检查对象<code>obj</code>是否具有指定的键。如果对象具有该键，则返回<code>true</code>，否则返回<code>false</code></p></li>
<li><p>计算属性名 <code>&#123;[name]:value&#125;</code>
把变量key的值作为key</p></li>
<li><p><code>mime.lookup</code>是一个函数，用于根据文件扩展名获取对应的
MIME 类型。MIME 类型是一种标识文件类型的方式，它在 Web
开发中常用于指定服务器响应的 Content-Type 头部。</p></li>
</ul>
<h2 id="koa2-基本使用"><a href="#koa2-基本使用" class="headerlink" title="koa2-基本使用"></a>koa2 基本使用</h2>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 导入koa，和koa 1.x不同，在koa2中，我们导入的是一个class，因此用大写的Koa表示:</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Koa</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa&#x27;</span>);<br><br><span class="hljs-comment">// 创建一个Koa对象表示web app本身:</span><br><span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Koa</span>();<br><br><span class="hljs-comment">// 对于任何请求，app将调用该异步函数处理请求：</span><br>app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">async</span> (ctx, next) =&gt; &#123;<br>  <span class="hljs-comment">// 参数ctx是由koa传入的封装了request和response的变量，我们可以通过它访问request和response，next是koa传入的将要处理的下一个异步函数</span><br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">next</span>();<br>  ctx.<span class="hljs-property">response</span>.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;text/html&#x27;</span>;<br>  ctx.<span class="hljs-property">response</span>.<span class="hljs-property">body</span> = <span class="hljs-string">&#x27;&lt;h1&gt;Hello, koa2!&lt;/h1&gt;&#x27;</span>;<br>&#125;);<br><br><span class="hljs-comment">// 在端口3000监听:</span><br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;app started at port 3000...&#x27;</span>);<br></code></pre></td></tr></table></figure>
<p>原因是koa把很多async函数组成一个处理链，每个async函数都可以做一些自己的事情，然后用<code>await next()</code>来调用下一个async函数。我们把每个async函数称为<strong>middleware</strong>，这些middleware可以组合起来，完成很多有用的功能。</p>
<p>( request的目标URL告诉服务器请求的资源在哪里可以找到。)</p>
<h3 id="koa-router"><a href="#koa-router" class="headerlink" title="koa-router"></a>koa-router</h3>
<p>为了处理URL，我们需要引入<code>koa-router</code>这个middleware，让它负责处理URL映射。我们使用<code>router.get('/path', async fn)</code>来处理一个GET请求。可以在请求路径中使用带变量的<code>/hello/:name</code>，变量可以通过<code>ctx.params.name</code>访问</p>
<p>要写一个 <code>app.use(router.routes());</code> 一般在最后</p>
<h3 id="koa-bodyparser"><a href="#koa-bodyparser" class="headerlink" title="koa-bodyparser"></a>koa-bodyparser</h3>
<p>另一个middleware来解析原始request请求，然后，把解析后的body对象，绑定到<code>ctx.request.body</code>中。</p>
<p>要写一个 <code>app.use(bodyParser());</code>
，必须在<code>router</code>之前被注册到<code>app</code>对象上</p>
<h3 id="模块化router"><a href="#模块化router" class="headerlink" title="模块化router"></a>模块化router</h3>
<p>把每个url的router都打包成一个js文件，放在<code>controllers</code>目录下，用一些方法让它自动扫描<code>controllers</code>目录，找到所有模块文件，导入，然后注册每个URL。模块文件的出口是一个对象，每个key值是request的method和url。</p>
<h2 id="nunjucks-模板引擎"><a href="#nunjucks-模板引擎" class="headerlink" title="nunjucks-模板引擎"></a>Nunjucks 模板引擎</h2>
<h3 id="nunjucks.configure-配置"><a href="#nunjucks.configure-配置" class="headerlink" title="nunjucks.configure-配置"></a>nunjucks.configure() 配置</h3>
<p>指定模板文件的位置，配置其他属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">nunjucks.configure(&#x27;views&#x27;, &#123;<br>  autoescape: true<br>&#125;);<br></code></pre></td></tr></table></figure>
<p>在上面的代码中，我们将模板文件（xxx.njk）存放在名为<code>views</code>的文件夹中。<code>autoescape</code>选项用于自动转义输出的内容，以防止XSS攻击。</p>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3>
<p>我们使用了<code>&#123;&#123; a &#125;&#125;</code>来包裹变量（变量名为a），使用<code>&#123;% %&#125;</code>来包裹一些语句（如：if，endif，for，endfor，block
aaa，endblock）</p>
<h3 id="nunjucks.render"><a href="#nunjucks.render" class="headerlink" title="nunjucks.render"></a>nunjucks.render()</h3>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> renderedHtml = nunjucks.<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;template.njk&#x27;</span>, &#123; <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;My Page&#x27;</span>, <span class="hljs-attr">items</span>: [<span class="hljs-string">&#x27;Item 1&#x27;</span>, <span class="hljs-string">&#x27;Item 2&#x27;</span>, <span class="hljs-string">&#x27;Item 3&#x27;</span>] &#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(renderedHtml);<br></code></pre></td></tr></table></figure>
<p>在上面的代码中，我们使用<code>render</code>方法来渲染名为<code>template.njk</code>的模板，并传递一个包含<code>title</code>和<code>items</code>的对象作为模板中的变量。</p>
<h3 id="重定义继承"><a href="#重定义继承" class="headerlink" title="重定义继承"></a>重定义（继承）</h3>
<p>base.html</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;html&gt;&lt;body&gt;<br>&#123;% block header %&#125; &lt;h3&gt;Unnamed&lt;/h3&gt; &#123;% endblock %&#125;<br>&#123;% block body %&#125; &lt;div&gt;No body&lt;/div&gt; &#123;% endblock %&#125;<br>&#123;% block footer %&#125; &lt;div&gt;copyright&lt;/div&gt; &#123;% endblock %&#125;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure>
<p>a.html</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&#123;% extends &#x27;base.html&#x27; %&#125;<br>&#123;% block header %&#125;&lt;h1&gt;&#123;&#123; header &#125;&#125;&lt;/h1&gt;&#123;% endblock %&#125;<br>&#123;% block body %&#125;&lt;p&gt;&#123;&#123; body &#125;&#125;&lt;/p&gt;&#123;% endblock %&#125;<br></code></pre></td></tr></table></figure>
<p>ctx.render</p>
<h2 id="mvc"><a href="#mvc" class="headerlink" title="mvc"></a>MVC</h2>
<p>MVC：Model-View-Controller，中文名“模型-视图-控制器”</p>
<h2 id="拷打问题-1"><a href="#拷打问题-1" class="headerlink" title="拷打问题-1"></a>拷打问题</h2>
<ul>
<li>cors()</li>
<li>日志文件</li>
<li>.env</li>
<li>每个response都要有token</li>
<li>前后端分离</li>
<li>加密存储</li>
</ul>
<h1 id="week-6-css"><a href="#week-6-css" class="headerlink" title="week-6-css"></a>Week 6 css</h1>
<p>学习的前置知识详见css.md</p>
<p><a
target="_blank" rel="noopener" href="https://tailwindcss.com/docs/installation">tailwindcss</a></p>
<h2 id="src.htmljs"><a href="#src.htmljs" class="headerlink" title="src.htmljs"></a><code>./src/**/*.&#123;html,js&#125;</code></h2>
<p>是一个文件路径模式，用于匹配指定目录下的所有子目录中的 HTML 和
JavaScript 文件。</p>
<p>解析该模式的方式如下：</p>
<ul>
<li><code>./src/</code>：表示从当前目录开始，进入 <code>src</code>
目录。</li>
<li><code>**/</code>：表示匹配任意深度的子目录。</li>
<li><code>*.&#123;html,js&#125;</code>：表示匹配任意文件名以 <code>.html</code> 或
<code>.js</code> 结尾的文件。</li>
</ul>
<h3 id="before"><a href="#before" class="headerlink" title="before"></a><code>:before</code></h3>
<p>是一个 CSS
伪元素选择器，用于在选中元素的内容之前插入生成的内容。它可以用于在元素前面添加装饰性的内容或图标，而无需修改
HTML 结构。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">.my-element:before &#123;<br>  content: &quot;→&quot;;<br>  color: red;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="tailwindcss"><a href="#tailwindcss" class="headerlink" title="tailwindcss"></a>tailwindcss</h2>
<h3 id="配置时注意"><a href="#配置时注意" class="headerlink" title="配置时注意"></a>配置时注意</h3>
<p>在tailwind.config.js的content中写入所有需要使用tailwindcss的文件名</p>
<h3 id="基本样式"><a href="#基本样式" class="headerlink" title="基本样式"></a>基本样式</h3>
<ol type="1">
<li><strong>背景颜色</strong>：<code>bg-gray-200</code>：设置背景颜色为灰色（可以根据需求使用不同的颜色代码）。</li>
</ol>
<p>颜色类名后面的数字从 100 到
900，表示不同的颜色强度。数字越小，颜色越浅，数字越大，颜色越深。</p>
<ol start="2" type="1">
<li><p><strong>文本颜色</strong>：text-red-200
text-sky-400/50（opacity）</p></li>
<li><p><strong>字体大小</strong>：</p></li>
</ol>
<ul>
<li><code>text-xs</code>：设置字体大小为额外小号。</li>
<li><code>text-lg</code>：设置字体大小为大号。</li>
</ul>
<ol start="4" type="1">
<li><p>字体粗细：</p>
<ul>
<li>font-bold</li>
<li>font-normal</li>
<li>font-thin</li>
<li>font-black 巨粗</li>
</ul></li>
<li><p><strong>内边距和外边距</strong>：</p></li>
</ol>
<ul>
<li><code>p-4</code>：设置元素的内边距为 4 个间距单位。</li>
<li><code>m-2</code>：设置元素的外边距为 2 个间距单位。</li>
</ul>
<ol start="5" type="1">
<li><strong>宽度和高度</strong>：</li>
</ol>
<ul>
<li><p><code>w-full</code>：设置元素的宽度为父元素的 100%。</p></li>
<li><p><code>h-1</code>：设置元素的高度为。</p>
<p>当使用 Tailwind CSS 中的 <code>rem</code>
单位时，它是相对于根元素（<code>&lt;html&gt;</code>）的字体大小（<code>font-size</code>）的倍数。默认情况下，根元素的字体大小是
<code>16px</code>。</p></li>
</ul>
<ol start="6" type="1">
<li><strong>文本对齐</strong>：</li>
</ol>
<ul>
<li><code>text-left</code>：将文本左对齐。</li>
<li><code>text-center</code>：将文本居中对齐。</li>
</ul>
<ol start="7" type="1">
<li><strong>弹性布局</strong>：</li>
</ol>
<ul>
<li><code>flex</code>：将元素设置为弹性容器。</li>
<li><code>justify-center</code>：在弹性容器中水平居中对齐子元素。</li>
</ul>
<ol start="8" type="1">
<li><strong>边框</strong>：</li>
</ol>
<ul>
<li><code>border</code>：为元素添加默认的边框样式。</li>
<li><code>border-gray-300</code>：为元素添加灰色边框（可以根据需求使用不同的颜色代码）。</li>
<li><code>transition</code> 过渡， duration-150 过渡时间（ms）</li>
</ul>
<h3 id="高级样式"><a href="#高级样式" class="headerlink" title="高级样式"></a>高级样式</h3>
<ul>
<li><p>"hover:bg-violet-600 active:bg-violet-700"</p></li>
<li><p>"odd:bg-white" 当此元素是第奇数个子元素是，使用白色背景</p></li>
<li><p>*当您需要根据 某些父元素的状态
设置元素的样式时，请使用类<code>group</code>标记父元素，并使用<code>group-*</code>修饰符<code>group-hover</code>来设置目标元素的样式</p></li>
<li><p>使用和修饰符设置<code>::before</code>和<code>::after</code>伪元素的样式：<code>before``after</code></p>
<p><code>"after:content-['*'] after:ml-0.5 after:text-red-500"</code>
(如果没有content，默认为空字符)</p></li>
<li><p>响应式 Tailwind 提供五个默认的断点<code>sm</code>
&gt;=640px<code>md</code> 768px<code>lg</code> 1024px<code>xl</code>
1280px<code>2xl</code> 1536px</p>
<p><code>&lt;img class="w-16 md:w-32 lg:w-48" src="..."&gt;</code></p></li>
</ul>
<h3 id="包装class时使用tailwindcss"><a href="#包装class时使用tailwindcss" class="headerlink" title="包装class时使用tailwindcss"></a>包装class时使用tailwindcss</h3>
<ul>
<li><p><code>@apply</code> 语法</p>
<p><code>.menu &#123;  **@apply** p-2 text-gray-900 font-semibold; &#125;</code></p>
<p>尽管使用<code>@apply</code>语法可以解决样式复用的问题，但并不推荐在早期就进行抽象，<strong>因为自定义class的做法会生成更多的样式代码，造成生成的css文件变得更大</strong>。</p></li>
<li><p>还有一个理由可以证明不使用自定义class会更好：你完全可以通过循环的语法来解决此问题：</p>
<p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div<br>    v-for=&quot;menu in [&#x27;首页&#x27;, &#x27;学习TailwindCSS&#x27;, &#x27;TailwindCSS的设计哲学&#x27;, &#x27;最佳实践&#x27;]&quot;<br>    :key=&quot;menu&quot;<br>    class=&quot;p-2 text-gray-900 font-semibold&quot;&gt;&#123;&#123;&#123; menu &#125;&#125;&#125;&lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure></p></li>
</ul>
<h2 id="杂项-3"><a href="#杂项-3" class="headerlink" title="杂项-3"></a>杂项</h2>
<ul>
<li><code>object-fit</code>属性：可以控制图片在容器中的尺寸和位置。将object-fit属性设置为contain可以保持图片的原始比例，并在容器中适应最大尺寸。将object-fit属性设置为cover可以填充整个容器，但可能会裁剪部分图片
<a
target="_blank" rel="noopener" href="https://www.bitdegree.org/learn/responsive-image">aaa</a>。</li>
<li>要在 <code>&lt;div&gt;</code> 元素内实现文本内容的换行，你可以使用
CSS 的 <code>white-space</code> 属性。将 <code>white-space</code>
属性设置为 <code>pre-wrap</code>
可以保留文本中的换行符，并在需要时自动换行</li>
<li>使用 <code>join()</code>
方法，它将数组的所有元素连接成一个字符串，并使用指定的分隔符分隔它们</li>
</ul>
<!-- flag of hidden posts --><div id="paginator"></div></div><div id="post-footer"></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="回到顶部" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="文章目录">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="切换主题"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://cdn.luogu.com.cn/upload/image_hosting/8cc2fgam.png" alt="Logo" style="margin:0;border-radius:0;"></a><h1 id="Dr"><a href="/">lyx12138</a></h1><div id="description"><p></p></div></div><div id="aside-block"><div id="toc-div"><h1>目录</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B0%E4%BA%BA%E4%BB%BB%E5%8A%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0"><span class="toc-number">1.</span> <span class="toc-text">新人任务学习笔记</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#week-1-keyword%E5%8A%A0%E8%BD%BD%E5%88%B7%E6%96%B0%E5%90%8C%E6%AD%A5"><span class="toc-number">2.</span> <span class="toc-text">week 1 (keyword:加载&#x2F;刷新&#x2F;同步)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#week-2-%E8%99%9A%E6%8B%9F-dom"><span class="toc-number">3.</span> <span class="toc-text">week 2 虚拟 DOM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">3.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vnode"><span class="toc-number">3.2.</span> <span class="toc-text">VNode</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#diff"><span class="toc-number">3.3.</span> <span class="toc-text">diff</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#patch"><span class="toc-number">3.4.</span> <span class="toc-text">patch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95"><span class="toc-number">3.5.</span> <span class="toc-text">一些方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue3%E4%BC%98%E5%8C%96"><span class="toc-number">3.6.</span> <span class="toc-text">vue3优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#react-diff%E7%AE%97%E6%B3%95"><span class="toc-number">3.7.</span> <span class="toc-text">react diff算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#emmet"><span class="toc-number">3.8.</span> <span class="toc-text">emmet</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">3.9.</span> <span class="toc-text">问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#week-3-promise"><span class="toc-number">4.</span> <span class="toc-text">week 3 promise</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#for-in-for-of-%E9%81%8D%E5%8E%86%E5%AF%B9%E8%B1%A1%E9%94%AE%E5%80%BC-js"><span class="toc-number">4.1.</span> <span class="toc-text">for in &amp; for of 遍历对象键值
JS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">4.2.</span> <span class="toc-text">基本操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E4%BB%BB%E5%8A%A1"><span class="toc-number">4.3.</span> <span class="toc-text">微任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E6%93%8D%E4%BD%9C"><span class="toc-number">4.4.</span> <span class="toc-text">高级操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#promise.all"><span class="toc-number">4.4.1.</span> <span class="toc-text">Promise.all</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#promise.allsettled"><span class="toc-number">4.5.</span> <span class="toc-text">Promise.allSettled()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#promise.race"><span class="toc-number">4.6.</span> <span class="toc-text">Promise.race</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#promise.resolve"><span class="toc-number">4.7.</span> <span class="toc-text">Promise.resolve()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#promise.reject"><span class="toc-number">4.8.</span> <span class="toc-text">Promise.reject</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#async-await"><span class="toc-number">4.9.</span> <span class="toc-text">async &amp; await</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%82%E9%A1%B9"><span class="toc-number">4.10.</span> <span class="toc-text">杂项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hardman"><span class="toc-number">4.11.</span> <span class="toc-text">HardMan</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#week-4-todelist"><span class="toc-number">5.</span> <span class="toc-text">week 4 TodeList</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#webpack"><span class="toc-number">5.1.</span> <span class="toc-text">webpack</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%82%E9%A1%B9-1"><span class="toc-number">5.2.</span> <span class="toc-text">杂项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF"><span class="toc-number">5.3.</span> <span class="toc-text">客户端存储技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#cookie%E5%B0%91%E9%87%8F%E4%B8%8D%E5%AE%89%E5%85%A8"><span class="toc-number">5.3.0.1.</span> <span class="toc-text">cookie（少量，不安全）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#web-storage-localstorage-sessionstorage"><span class="toc-number">5.3.1.</span> <span class="toc-text">Web Storage
(localStorage, sessionStorage)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">5.3.2.</span> <span class="toc-text">区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">5.4.</span> <span class="toc-text">正则表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%B7%E6%89%93%E9%97%AE%E9%A2%98"><span class="toc-number">5.5.</span> <span class="toc-text">拷打问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#week-5-koa"><span class="toc-number">6.</span> <span class="toc-text">Week 5 koa</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%82%E9%A1%B9-2"><span class="toc-number">6.1.</span> <span class="toc-text">杂项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#koa2-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">6.2.</span> <span class="toc-text">koa2 基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#koa-router"><span class="toc-number">6.2.1.</span> <span class="toc-text">koa-router</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#koa-bodyparser"><span class="toc-number">6.2.2.</span> <span class="toc-text">koa-bodyparser</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96router"><span class="toc-number">6.2.3.</span> <span class="toc-text">模块化router</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nunjucks-%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E"><span class="toc-number">6.3.</span> <span class="toc-text">Nunjucks 模板引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#nunjucks.configure-%E9%85%8D%E7%BD%AE"><span class="toc-number">6.3.1.</span> <span class="toc-text">nunjucks.configure() 配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">6.3.2.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nunjucks.render"><span class="toc-number">6.3.3.</span> <span class="toc-text">nunjucks.render()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF"><span class="toc-number">6.3.4.</span> <span class="toc-text">重定义（继承）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mvc"><span class="toc-number">6.4.</span> <span class="toc-text">MVC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%B7%E6%89%93%E9%97%AE%E9%A2%98-1"><span class="toc-number">6.5.</span> <span class="toc-text">拷打问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#week-6-css"><span class="toc-number">7.</span> <span class="toc-text">Week 6 css</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#src.htmljs"><span class="toc-number">7.1.</span> <span class="toc-text">.&#x2F;src&#x2F;**&#x2F;*.{html,js}</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#before"><span class="toc-number">7.1.1.</span> <span class="toc-text">:before</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tailwindcss"><span class="toc-number">7.2.</span> <span class="toc-text">tailwindcss</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%97%B6%E6%B3%A8%E6%84%8F"><span class="toc-number">7.2.1.</span> <span class="toc-text">配置时注意</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A0%B7%E5%BC%8F"><span class="toc-number">7.2.2.</span> <span class="toc-text">基本样式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E6%A0%B7%E5%BC%8F"><span class="toc-number">7.2.3.</span> <span class="toc-text">高级样式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E8%A3%85class%E6%97%B6%E4%BD%BF%E7%94%A8tailwindcss"><span class="toc-number">7.2.4.</span> <span class="toc-text">包装class时使用tailwindcss</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%82%E9%A1%B9-3"><span class="toc-number">7.3.</span> <span class="toc-text">杂项</span></a></li></ol></li></ol></div></div><footer><nobr>构建自 <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> 使用主题 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> 主题作者 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas></body></html>